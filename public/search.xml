<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>建站首发</title>
    <url>/2020/11/28/%E5%BB%BA%E7%AB%99%E9%A6%96%E5%8F%91/</url>
    <content><![CDATA[<h1 id="建站第一篇博客"><a href="#建站第一篇博客" class="headerlink" title="建站第一篇博客"></a>建站第一篇博客</h1><p>欢迎来到与李的个人博客，我会在这里记录我的漫漫编程路！</p>
<p>个人联系方式：</p>
<ul>
<li><p>QQ 1451633962</p>
</li>
<li><p>微信 HGL19970730</p>
</li>
</ul>
<p>  其他博客：</p>
<ul>
<li>CSDN（与李）：<a href="https://blog.csdn.net/qq_37171817">https://blog.csdn.net/qq_37171817</a></li>
<li> 掘金（与李）：<a href="https://juejin.im/user/5d3e80235188253c143b92d4/posts">https://juejin.im/user/5d3e80235188253c143b92d4/posts</a></li>
<li> 简书（与李_han）：<a href="https://www.jianshu.com/u/58b4076f1f1a">https://www.jianshu.com/u/58b4076f1f1a</a> </li>
<li>博客园（与李）：<a href="https://www.cnblogs.com/yl-space/">https://www.cnblogs.com/yl-space/</a></li>
</ul>
<p>  我会等着你们的消息哟！</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/1.gif"></p>
]]></content>
      <categories>
        <category>blog</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>首发</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建个人网站</title>
    <url>/2020/12/09/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="一、搭建GithubPages"><a href="#一、搭建GithubPages" class="headerlink" title="一、搭建GithubPages"></a>一、搭建GithubPages</h1><p>1、在GitHub上创建一个名为”yourname.github.io”的仓库</p>
<p>如我的GitHub账户名称为hanguilin，那么我就需要创建一个名为hanguilin.github.io的仓库</p>
<p>2、进入仓库，进入Settings</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209141316842.png"></p>
<p>找到GitHub Pages</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209141506534.png"></p>
<p>第一部分是个人主页访问地址，初始化应该为<a href="http://yourname.github.io./">http://yourname.github.io。</a></p>
<p>第二部分是表示网站根目录/与gh-pages分支进行关联。</p>
<p>第三部分是选择GitHub自带的主题。</p>
<p>第四部分是关联到自定义域名，你的自定义域名需要解析到yourname.github.io域名上。拿阿里云举例，需要进入域名控制台进行域名解析，选择CNAME方式将自定义域名解析到yourname.github.io域名。</p>
<p>第五部分是使用https，勾选之后，会自动为你的域名添加https支持。</p>
<p>我们在这里去选择一个主题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209142202883.png"></p>
<p>选择之后根据提示将初始化代码进行提交。</p>
<p>访问<a href="http://yourname.github.io,就可以看到初始化的个人主页./">http://yourname.github.io，就可以看到初始化的个人主页。</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209142419146.png"></p>
<h1 id="二、使用Hexo模板"><a href="#二、使用Hexo模板" class="headerlink" title="二、使用Hexo模板"></a>二、使用Hexo模板</h1><p>个人主页搭建好之后，发现页面很简单，没办法支撑自己更多的功能展现。所以我们可以用其他技术来美化我们的页面，如hexo。</p>
<h2 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h2><p>hexo官网： <a href="https://hexo.io/">hexo</a></p>
<p>hexo简介：是一个基于nodejs 的静态博客网站生成器，只需一条指令即可部署到 GitHub Pages, Heroku 或其他平台。</p>
<p>因为hexo基于nodejs，所以使用hexo之前需要安装node环境，安装过程可以浏览器搜索，网上很多相关教程。</p>
<p>初始化一个hexo项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 安装hexo脚手架</span><br>npm install hexo-cli -g<br><span class="hljs-meta">#</span><span class="bash"> 创建一个blog的项目</span><br>hexo init blog<br><span class="hljs-meta">#</span><span class="bash"> 进入blog文件夹</span><br>cd blog<br><span class="hljs-meta">#</span><span class="bash"> 下载库包</span><br>npm install<br><span class="hljs-meta">#</span><span class="bash"> 本地运行，默认端口4000</span><br>hexo server<br></code></pre></td></tr></table></figure>

<h2 id="替换hexo项目默认模板"><a href="#替换hexo项目默认模板" class="headerlink" title="替换hexo项目默认模板"></a>替换hexo项目默认模板</h2><p>如果hexo项目的默认模板（landscape）不符合你的审美，那可以在hexo主题库中挑选主题进行替换。</p>
<p>hexo主题库：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a></p>
<p>将下载好的主题库放入blog/themes中，再打开blog目录下的_config.yml配置文件，修改其中的theme参数，值为blog/themes中你新加主题的名字。</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209144247346.png" style="zoom:67%;" />

<h2 id="设置github仓库"><a href="#设置github仓库" class="headerlink" title="设置github仓库"></a>设置github仓库</h2><p>打开blog目录下的_config.yml配置文件，修改其中的deploy参数</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209144704847.png" style="zoom:67%;" />

<p>type: git表示代码用git进行管理</p>
<p>repo表示仓库路径</p>
<p>branch表示推送的分支</p>
<h2 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h2><ul>
<li><p>hexo clean </p>
<p>清空public文件夹</p>
</li>
<li><p>hexo g </p>
<p>根据md文件生成对应的html</p>
</li>
<li><p>hexo s </p>
<p>在本地运行</p>
</li>
<li><p>hexo d</p>
<p>发布到Github Pages中</p>
</li>
</ul>
<h1 id="三、本地化Markdown编辑器"><a href="#三、本地化Markdown编辑器" class="headerlink" title="三、本地化Markdown编辑器"></a>三、本地化Markdown编辑器</h1><p>推荐使用Typora+PicGo+GitHub图床，具体方法请参考博客<a href="https://blog.javayuli.cn/2020/11/29/MarkDown%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91%E7%A5%9E%E7%BB%84%E5%90%88/">《MarkDown本地编辑神组合》</a>。</p>
]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>个人网站</tag>
        <tag>GitHubPages</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudGateway初探</title>
    <url>/2020/12/23/SpringCloudGateway%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>SpringCloud全家桶中有个很重要的组件就是网关，在1.X版本中都是采用zuul网关，在2.X版本中，zuul的升级一直跳票，SpringCloud最后自己研发了一个网关替带zuul——SpringCloud Gateway 。换言之，gateway就是原zuul1.X版 的替代。</p>
<p>Gateway是在spring生态系统上构建的api网关服务，基于Spring5，SpringBoot2和Project Reactor等技术。Gateway旨在提供一种简单而有效的方式来对api进行路由，以提供一些强大的过滤功能，例如熔断、限流、重试等。</p>
<p>为了提升网关性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层使用了高性能的Reactor通信框架Netty。SpringCloud Gateway的目标提供统一的路由方式，且基于Filter链的方式提供了网关基本的功能，例如安全、监控/指标、限流。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>基于Spring FremeWork5，Project Reactor和Spring Boot2.0进行构建；</p>
<p>动态路由：能够匹配任何请求属性；</p>
<p>可以对路由指定Predictate（断言）和Filter（过滤器）；</p>
<p>集成Hystrix的断路器功能；</p>
<p>集成SpringCloud的服务发现功能；</p>
<p>请求限流功能；</p>
<p>支持路径重写。</p>
<h2 id="与Zuul的区别"><a href="#与Zuul的区别" class="headerlink" title="与Zuul的区别"></a>与Zuul的区别</h2><p>在SpringCloud Finchley 正式版之前，Spring Cloud推荐的网关是 Netflix提供的Zuul:</p>
<p>1、Zuul 1.x，是一个基于阻塞I/O的API Gateway；</p>
<p>2、Zuul 1.x基于Servlet 2.5使用阻塞架构，它不支持任何长连接(如WebSocket)。Zuul的设计模式和Nginx较像，每次I/О操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx用C++实现，Zuul用Java实现，而JVM本身会有第—次加载较慢的情况，使得Zuul的性能相对较差。</p>
<p>3、Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。Zuul 2.x的性能较Zuul 1.x有较大提升。在性能方面，根据官方提供的基准测试，Spring Cloud Gateway的RPS(每秒请求数）是Zuul的1.6倍。</p>
<p>4、Spring Cloud Gateway建立在Spring Framework 5、ProjectReactor和Spring Boot2之上，使用非阻塞API。</p>
<p>5、Spring Cloud Gateway还支持WebSocket，并且与Spring紧密集成拥有更好的开发体验</p>
<blockquote>
<p>WebFlux</p>
</blockquote>
<p>传统的Web框架，比如说: struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的。但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty,Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程（Spring5必须让你使用java8）</p>
<p>Spring WebFlux是Spring 5.0引入的新的响应式框架，区别于Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于Reactor来实现响应式流规范。</p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="ROUTE（路由）"><a href="#ROUTE（路由）" class="headerlink" title="ROUTE（路由）"></a>ROUTE（路由）</h3><p>路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true，则匹配该路由。</p>
<h3 id="PREDICATE（断言）"><a href="#PREDICATE（断言）" class="headerlink" title="PREDICATE（断言）"></a>PREDICATE（断言）</h3><p>参考的是Java8的java.util.function.Predictate，开发人员可以匹配HTTP请求中的所有内容（例如请求头或请求参数），如果请求与路由相匹配则进行路由。</p>
<h3 id="FILTER（过滤）"><a href="#FILTER（过滤）" class="headerlink" title="FILTER（过滤）"></a>FILTER（过滤）</h3><p>指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由之前或之后对请求进行修改。</p>
<p>web请求，通过一些匹配条件，定位到真正的服务节点，并在这个转发过程的前后，进行一些精细化控制。Predicate就是我们的匹配条件，而filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由。</p>
<h2 id="GATEWEY工作流程"><a href="#GATEWEY工作流程" class="headerlink" title="GATEWEY工作流程"></a>GATEWEY工作流程</h2><p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/09fcaab25d7f444ffdcbd3fa3435501b.png"></p>
<p>客户端向Spring Cloud Gateway发出请求。然后在Gateway Handler Mapping中找到与请求相匹配的路由，将其发送到Gateway Web Handler。</p>
<p>Handler再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回。<br>过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前（“pre”）或之后（“post”）执行业务逻辑的加强或其他处理。</p>
<p>Filter 在 “pre” 类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等；在 “post” 类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等，有着非常重要的作用</p>
<p>Gatewey的核心逻辑就是**路由转发+执行过滤链</p>
<h1 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h1><p>本例中使用Nacos作为注册和配置中心，系列源代码GitHub地址<a href="https://github.com/hanguilin/SpringCloudDemo">SpringCloudDemo</a></p>
<p>创建api-gateway子项目</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201223110133035.png"></p>
<p>完整<code>pom.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;<br>         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;<br>    &lt;parent&gt;<br>        &lt;artifactId&gt;nacos&lt;&#x2F;artifactId&gt;<br>        &lt;groupId&gt;cn.javayuli&lt;&#x2F;groupId&gt;<br>        &lt;version&gt;1.0.0&lt;&#x2F;version&gt;<br>    &lt;&#x2F;parent&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;<br><br>    &lt;artifactId&gt;api-gatewey&lt;&#x2F;artifactId&gt;<br>    &lt;description&gt;api网关&lt;&#x2F;description&gt;<br><br>    &lt;dependencies&gt;<br>        &lt;!--gateway 网关依赖,内置webflux 依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--注册中心客户端--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--配置中心客户端--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!--断路器依赖--&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br><br>    &lt;&#x2F;dependencies&gt;<br><br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;<br>            &lt;&#x2F;plugin&gt;<br>        &lt;&#x2F;plugins&gt;<br>    &lt;&#x2F;build&gt;<br>&lt;&#x2F;project&gt;<br></code></pre></td></tr></table></figure>

<p>启动类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javayuli.gateway;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.SpringCloudApplication;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 网关服务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringCloudApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(GatewayApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>api-provider</code>项目作为接口提供者，提供了一个/hello接口，端口8000，访问路径<a href="">http://localhost:8000/hello?s=1</a>。<code>api-provider</code>项目在nacos中的服务名称为<code>api-provider</code>。</p>
<p><code>api-gateway</code>配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201223110719972.png"></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8001</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">gateway:</span><br>      <span class="hljs-attr">routes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">id:</span> <span class="hljs-string">api-provider</span><br>        <span class="hljs-attr">uri:</span> <span class="hljs-string">lb://api-provider</span><br>        <span class="hljs-attr">predicates:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/provider/**</span><br>        <span class="hljs-attr">filters:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">RewritePath=/provider/(?&lt;segment&gt;.*),</span> <span class="hljs-string">/$\&#123;segment&#125;</span><br></code></pre></td></tr></table></figure>

<p><code>spring.cloud.gateway.routes</code>是对路由的配置</p>
<p><code>spring.cloud.gateway.routes.id</code>是唯一的，需要自己定义，一般是用项目名称作为id</p>
<p><code>spring.cloud.gateway.routes.uri</code>表示资源请求的真实路径</p>
<ul>
<li><p>lb</p>
<p>在SpringCloud Gateway官方文档中有这么一句话</p>
<p><code>Note that this example also demonstrates (optional) Spring Cloud Netflix Ribbon load-balancing via the lb prefix on the destination URI.</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201223112024559.png"></p>
<p>意为如果项目中使用了Spring Cloud Netflix Ribbon，就可以用lb://${applicationName}的形式表示服务访问路径</p>
<p>或者还可以直接使用请求路径，如<a href="http://localhost:8001/">http://localhost:8001</a></p>
</li>
</ul>
<p><code>spring.cloud.gateway.routes.predicates</code> -Path表示请求路径匹配到此表达式的请求将由此规则进行转发</p>
<p><code>spring.cloud.gateway.routes.filters</code> - RewritePath表示重写路由，此处可以将/provider/hello重写成/hello</p>
<p>启动api-gateway与api-provider服务，无需分先后</p>
<p>通过网关端口访问api-provider的接口</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201223111623761.png"></p>
<p>最后放上<a href="https://docs.spring.io/spring-cloud-gateway/docs/2.2.5.RELEASE/reference/html/#gateway-request-predicates-factories">spring-cloud-gateway.2.2.RELEASE</a>的文档</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>Spring Cloud Gateway</tag>
        <tag>网关</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba之Sentinel介绍</title>
    <url>/2020/12/21/SpringCloudAlibaba%E4%B9%8BSentinel%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="Sentinel-是什么"><a href="#Sentinel-是什么" class="headerlink" title="Sentinel 是什么"></a>Sentinel 是什么</h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel 是面向分布式服务架构的流量控制组件，主要以流量为切入点，从限流、流量整形、熔断降级、系统负载保护、热点防护等多个维度来帮助开发者保障微服务的稳定性。</p>
<h3 id="Sentinel-的历史"><a href="#Sentinel-的历史" class="headerlink" title="Sentinel 的历史"></a>Sentinel 的历史</h3><ul>
<li>2012 年，Sentinel 诞生，主要功能为入口流量控制。</li>
<li>2013-2017 年，Sentinel 在阿里巴巴集团内部迅速发展，成为基础技术模块，覆盖了所有的核心场景。Sentinel 也因此积累了大量的流量归整场景以及生产实践。</li>
<li>2018 年，Sentinel 开源，并持续演进。</li>
<li>2019 年，Sentinel 朝着多语言扩展的方向不断探索，推出 <a href="https://github.com/alibaba/sentinel-cpp">C++ 原生版本</a>，同时针对 Service Mesh 场景也推出了 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-cluster/sentinel-cluster-server-envoy-rls">Envoy 集群流量控制支持</a>，以解决 Service Mesh 架构下多语言限流的问题。</li>
<li>2020 年，推出 <a href="https://github.com/alibaba/sentinel-golang">Sentinel Go 版本</a>，继续朝着云原生方向演进。</li>
</ul>
<h2 id="Sentinel-基本概念"><a href="#Sentinel-基本概念" class="headerlink" title="Sentinel 基本概念"></a>Sentinel 基本概念</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>资源是 Sentinel 的关键概念。它可以是 Java 应用程序中的任何内容，例如，由应用程序提供的服务，或由应用程序调用的其它应用提供的服务，甚至可以是一段代码。在接下来的文档中，我们都会用资源来描述代码块。</p>
<p>只要通过 Sentinel API 定义的代码，就是资源，能够被 Sentinel 保护起来。大部分情况下，可以使用方法签名，URL，甚至服务名称作为资源名来标示资源。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>围绕资源的实时状态设定的规则，可以包括流量控制规则、熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</p>
<h2 id="Sentinel-功能和设计理念"><a href="#Sentinel-功能和设计理念" class="headerlink" title="Sentinel 功能和设计理念"></a>Sentinel 功能和设计理念</h2><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><h4 id="什么是流量控制"><a href="#什么是流量控制" class="headerlink" title="什么是流量控制"></a>什么是流量控制</h4><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状。</p>
<h4 id="流量控制设计理念"><a href="#流量控制设计理念" class="headerlink" title="流量控制设计理念"></a>流量控制设计理念</h4><p>流量控制有以下几个角度:</p>
<ul>
<li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li>
<li>运行指标，例如 QPS、线程池、系统负载等；</li>
<li>控制的效果，例如直接限流、冷启动、排队等。</li>
</ul>
<p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p>
<h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><h4 id="什么是熔断降级"><a href="#什么是熔断降级" class="headerlink" title="什么是熔断降级"></a>什么是熔断降级</h4><p>除了流量控制以外，及时对调用链路中的不稳定因素进行熔断也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，可能会导致请求发生堆积，进而导致级联错误。</p>
<p>Sentinel 和 Hystrix 的原则是一致的: 当检测到调用链路中某个资源出现不稳定的表现，例如请求响应时间长或异常比例升高的时候，则对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联故障。</p>
<h4 id="熔断降级设计理念"><a href="#熔断降级设计理念" class="headerlink" title="熔断降级设计理念"></a>熔断降级设计理念</h4><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p>
<p>Hystrix 通过 <a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools">线程池隔离</a> 的方式，来对依赖（在 Sentinel 的概念中对应 <em>资源</em>）进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本（过多的线程池导致线程数目过多），还需要预先给各个资源做线程池大小的分配。</p>
<p>Sentinel 对这个问题采取了两种手段:</p>
<ul>
<li>通过并发线程数进行限制</li>
</ul>
<p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p>
<ul>
<li>通过响应时间对资源进行降级</li>
</ul>
<p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p>
<h3 id="系统自适应保护"><a href="#系统自适应保护" class="headerlink" title="系统自适应保护"></a>系统自适应保护</h3><p>Sentinel 同时提供系统维度的自适应保护能力。防止雪崩，是系统防护中重要的一环。当系统负载较高的时候，如果还持续让请求进入，可能会导致系统崩溃，无法响应。在集群环境下，网络负载均衡会把本应这台机器承载的流量转发到其它的机器上去。如果这个时候其它的机器也处在一个边缘状态的时候，这个增加的流量就会导致这台机器也崩溃，最后导致整个集群不可用。</p>
<p>针对这个情况，Sentinel 提供了对应的保护机制，让系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理最多的请求。</p>
<h2 id="Sentinel-是如何工作的"><a href="#Sentinel-是如何工作的" class="headerlink" title="Sentinel 是如何工作的"></a>Sentinel 是如何工作的</h2><p>Sentinel 的主要工作机制如下：</p>
<ul>
<li>对主流框架提供适配或者显示的 API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。</li>
<li>根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel 提供开放的接口，方便您定义及改变规则。</li>
<li>Sentinel 提供实时的监控系统，方便您快速了解目前系统的状态。</li>
</ul>
]]></content>
      <categories>
        <category>SpringCloudAlibaba</category>
      </categories>
      <tags>
        <tag>SpringCloudAlibaba</tag>
        <tag>Sentiel</tag>
        <tag>熔断</tag>
        <tag>流控</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba之Sentinel流控熔断</title>
    <url>/2020/12/21/SpringCloudAlibaba%E4%B9%8BSentinel%E6%B5%81%E6%8E%A7%E7%86%94%E6%96%AD/</url>
    <content><![CDATA[<p>Sentinel 的使用可以分为两个部分:</p>
<ul>
<li>核心库（Java 客户端）：不依赖任何框架/库，能够运行于 Java 7 及以上的版本的运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持（见 <a href="https://github.com/alibaba/Sentinel/wiki/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E9%80%82%E9%85%8D">主流框架适配</a>）。</li>
<li>控制台（Dashboard）：控制台主要负责管理推送规则、监控、集群限流分配管理、机器发现等。</li>
</ul>
<h1 id="1-引入-Sentinel-依赖"><a href="#1-引入-Sentinel-依赖" class="headerlink" title="1. 引入 Sentinel 依赖"></a>1. 引入 Sentinel 依赖</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>	&lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h1 id="2-入门案例"><a href="#2-入门案例" class="headerlink" title="2. 入门案例"></a>2. 入门案例</h1><p><strong>资源</strong> 是 Sentinel 中的核心概念之一。最常用的资源是我们代码中的 Java 方法。 当然，您也可以更灵活的定义你的资源，例如，把需要控制流量的代码用 Sentinel API <code>SphU.entry(&quot;HelloWorld&quot;)</code> 和 <code>entry.exit()</code> 包围起来即可。在下面的例子中，我们将 <code>System.out.println(&quot;hello world&quot;);</code> 作为资源（被保护的逻辑），用 API 包装起来。参考代码如下:</p>
<p><code>SentinelService.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javayuli.service;<br><br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.Entry;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.SphU;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.RuleConstant;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRule;<br><span class="hljs-keyword">import</span> com.alibaba.csp.sentinel.slots.block.flow.FlowRuleManager;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限流测试</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentinelService</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理请求</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRquest</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 配置规则.</span><br>        initFlowRules();<br><br>        <span class="hljs-comment">// 1.5.0 版本开始可以直接利用 try-with-resources 特性，自动 exit entry</span><br>        <span class="hljs-keyword">try</span> (Entry entry = SphU.entry(<span class="hljs-string">&quot;HelloWorld&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 被保护的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (BlockException ex) &#123;<br>            <span class="hljs-comment">// 处理被流控的逻辑</span><br>            System.out.println(<span class="hljs-string">&quot;blocked!&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置流控规则， QPS最大20</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initFlowRules</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;FlowRule&gt; rules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        FlowRule rule = <span class="hljs-keyword">new</span> FlowRule();<br>        rule.setResource(<span class="hljs-string">&quot;HelloWorld&quot;</span>);<br>        rule.setGrade(RuleConstant.FLOW_GRADE_QPS);<br>        <span class="hljs-comment">// Set limit QPS to 20.</span><br>        rule.setCount(<span class="hljs-number">20</span>);<br>        rules.add(rule);<br>        FlowRuleManager.loadRules(rules);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>SentinelController.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javayuli.controller;<br><br><span class="hljs-keyword">import</span> cn.javayuli.service.SentinelService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 限流测试</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SentinelController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SentinelService sentinelService;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 请求资源</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;getSource&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGetSource</span> <span class="hljs-params">()</span> </span>&#123;<br>        sentinelService.handleRquest();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="3-检查结果"><a href="#3-检查结果" class="headerlink" title="3.检查结果"></a>3.检查结果</h1><p>启动项目，并使用Jmeter进行压测</p>
<p>配置1秒发送18个请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221210010658.png"></p>
<p>配置访问接口</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221205645682.png"></p>
<p>控制台正常打印<code>hello world</code></p>
<p>现在把18调成30，发现已经被锁住了</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221210231967.png"></p>
<p>Demo 运行之后，我们可以在日志 <code>$&#123;currentUser&#125;/logs/csp/$&#123;appName&#125;-metrics.log.xxx</code> 里看到下面的输出:</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221210608596.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">|--timestamp-|------date time----|--resource-|p |block|s |e|rt<br>1608555871000|2020-12-21 21:04:31|&#x2F;getSource|10|0|10|0|42|0|0|1<br>1608555871000|2020-12-21 21:04:31|HelloWorld|10|0|10|0|0|0|0|0<br>1608555871000|2020-12-21 21:04:31|__total_inbound_traffic__|10|0|10|0|42|0|0|0<br>1608555872000|2020-12-21 21:04:32|&#x2F;getSource|20|0|20|0|1|0|0|1<br>1608555872000|2020-12-21 21:04:32|HelloWorld|15|5|15|0|0|0|0|0<br>1608555872000|2020-12-21 21:04:32|__total_inbound_traffic__|20|0|20|0|1|0|0|0<br></code></pre></td></tr></table></figure>

<p>其中 <code>p</code> 代表通过的请求, <code>block</code> 代表被阻止的请求, <code>s</code> 代表成功执行完成的请求个数, <code>e</code> 代表用户自定义的异常, <code>rt</code> 代表平均响应时长。</p>
<h1 id="4-熔断降级"><a href="#4-熔断降级" class="headerlink" title="4.熔断降级"></a>4.熔断降级</h1><p>Sentinel 提供了 <code>@SentinelResource</code> 注解用于定义资源，并提供了 AspectJ 的扩展用于自动定义资源、处理 <code>BlockException</code> 等</p>
<p><code>@SentinelResource</code> 用于定义资源，并提供可选的异常处理和 fallback 配置项。 <code>@SentinelResource</code> 注解包含以下属性：</p>
<ul>
<li><p><code>value</code>：资源名称，必需项（不能为空）</p>
</li>
<li><p><code>entryType</code>：entry 类型，可选项（默认为 <code>EntryType.OUT</code>）</p>
</li>
<li><p><code>blockHandler</code> / <code>blockHandlerClass</code>: <code>blockHandler</code> 对应处理 <code>BlockException</code> 的函数名称，可选项。blockHandler 函数访问范围需要是 <code>public</code>，返回类型需要与原方法相匹配，参数类型需要和原方法相匹配并且最后加一个额外的参数，类型为 <code>BlockException</code>。blockHandler 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>blockHandlerClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</p>
</li>
<li><p><code>fallback</code>/<code>fallbackClass</code></p>
<p>：fallback 函数名称，可选项，用于在抛出异常的时候提供 fallback 处理逻辑。fallback 函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code>里面排除掉的异常类型）进行处理。fallback 函数签名和位置要求：</p>
<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要和原函数一致，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li>
<li>fallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li><p><code>defaultFallback</code>（since 1.6.0）：默认的 fallback 函数名称，可选项，通常用于通用的 fallback 逻辑（即可以用于很多服务或方法）。默认 fallback 函数可以针对所有类型的异常（除了<code>exceptionsToIgnore</code>里面排除掉的异常类型）进行处理。若同时配置了 fallback 和 defaultFallback，则只有 fallback 会生效。defaultFallback 函数签名要求：</p>
<ul>
<li>返回值类型必须与原函数返回值类型一致；</li>
<li>方法参数列表需要为空，或者可以额外多一个 <code>Throwable</code> 类型的参数用于接收对应的异常。</li>
<li>defaultFallback 函数默认需要和原方法在同一个类中。若希望使用其他类的函数，则可以指定 <code>fallbackClass</code> 为对应的类的 <code>Class</code> 对象，注意对应的函数必需为 static 函数，否则无法解析。</li>
</ul>
</li>
<li><p><code>exceptionsToIgnore</code>（since 1.6.0）：用于指定哪些异常被排除掉，不会计入异常统计中，也不会进入 fallback 逻辑中，而是会原样抛出。</p>
</li>
</ul>
<p>1.8.0 版本开始，<code>defaultFallback</code> 支持在类级别进行配置。</p>
<blockquote>
<p>注：1.6.0 之前的版本 fallback 函数只针对降级异常（<code>DegradeException</code>）进行处理，<strong>不能针对业务异常进行处理</strong>。</p>
</blockquote>
<p>特别地，若 blockHandler 和 fallback 都进行了配置，则被限流降级而抛出 <code>BlockException</code> 时只会进入 <code>blockHandler</code> 处理逻辑。若未配置 <code>blockHandler</code>、<code>fallback</code> 和 <code>defaultFallback</code>，则被限流降级时会将 <code>BlockException</code> <strong>直接抛出</strong>（若方法本身未定义 throws BlockException 则会被 JVM 包装一层 <code>UndeclaredThrowableException</code>）。</p>
<p>从 1.4.0 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.4.0 以前的版本需要自行调用 <code>Tracer.trace(ex)</code> 来记录业务异常。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h3><p>若您是通过 <a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">Spring Cloud Alibaba</a> 接入的 Sentinel，则无需额外进行配置即可使用 <code>@SentinelResource</code> 注解。</p>
<h3 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h3><p>若您的应用使用了 Spring AOP（无论是 Spring Boot 还是传统 Spring 应用），您需要通过配置的方式将 <code>SentinelResourceAspect</code> 注册为一个 Spring Bean：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@Configuration<br>public class SentinelAspectConfiguration &#123;<br><br>    @Bean<br>    public SentinelResourceAspect sentinelResourceAspect() &#123;<br>        return new SentinelResourceAspect();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们提供了 Spring AOP 的示例，可以参见 <a href="https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-annotation-spring-aop">sentinel-demo-annotation-spring-aop</a>。</p>
<h3 id="AspectJ"><a href="#AspectJ" class="headerlink" title="AspectJ"></a>AspectJ</h3><p>若您的应用直接使用了 AspectJ，那么您需要在 <code>aop.xml</code> 文件中引入对应的 Aspect：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;aspects&gt;<br>    &lt;aspect name&#x3D;&quot;com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect&quot;&#x2F;&gt;<br>&lt;&#x2F;aspects&gt;<br></code></pre></td></tr></table></figure>

<h2 id="DEMO"><a href="#DEMO" class="headerlink" title="DEMO"></a>DEMO</h2><p>系列源代码GitHub地址<a href="https://github.com/hanguilin/SpringCloudDemo">SpringCloudDemo</a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * hello</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SentinelResource(value = &quot;hello&quot;, blockHandler = &quot;exceptionHandler&quot;, fallback = &quot;helloFallback&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-keyword">long</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Hello at %d&quot;</span>, s);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Fallback 函数，函数签名与原函数一致或加一个 Throwable 类型的参数.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloFallback</span><span class="hljs-params">(<span class="hljs-keyword">long</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;Halooooo %d&quot;</span>, s);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Block 异常处理函数，参数最后多一个 BlockException，其余与原函数一致.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> ex</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">exceptionHandler</span><span class="hljs-params">(<span class="hljs-keyword">long</span> s, BlockException ex)</span> </span>&#123;<br>    <span class="hljs-comment">// Do some log here.</span><br>    ex.printStackTrace();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Oops, error occurred at &quot;</span> + s;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h3><p>传入参数1</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222133054691.png"></p>
<p>测试结果为正常调用的结果</p>
<p><img  src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222133146397.png"  ><span class="image-caption">image-20201222133146396</span></p>
<p>参数0，测试结果为回调结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222134202104.png"></p>
<h1 id="5-Sentinel控制台"><a href="#5-Sentinel控制台" class="headerlink" title="5.Sentinel控制台"></a>5.Sentinel控制台</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Sentinel 提供一个轻量级的开源控制台，它提供机器发现以及健康情况管理、监控（单机和集群），规则管理和推送的功能。另外，鉴权在生产环境中也必不可少。这里，我们将会详细讲述如何通过<a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#2-%E5%90%AF%E5%8A%A8%E6%8E%A7%E5%88%B6%E5%8F%B0">简单的步骤</a>就可以使用这些功能。</p>
<p>接下来，我们将会逐一介绍如何整合 Sentinel 核心库和 Dashboard，让它发挥最大的作用。同时我们也在阿里云上提供企业级的控制台：<a href="https://github.com/alibaba/Sentinel/wiki/AHAS-Sentinel-%E6%8E%A7%E5%88%B6%E5%8F%B0">AHAS Sentinel 控制台</a>，您只需要几个简单的步骤，就能最直观地看到控制台如何实现这些功能。</p>
<p>Sentinel 控制台包含如下功能:</p>
<ul>
<li><a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#4-%E6%9F%A5%E7%9C%8B%E6%9C%BA%E5%99%A8%E5%88%97%E8%A1%A8%E4%BB%A5%E5%8F%8A%E5%81%A5%E5%BA%B7%E6%83%85%E5%86%B5"><strong>查看机器列表以及健康情况</strong></a>：收集 Sentinel 客户端发送的心跳包，用于判断机器是否在线。</li>
<li><a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#5-%E7%9B%91%E6%8E%A7"><strong>监控 (单机和集群聚合)</strong></a>：通过 Sentinel 客户端暴露的监控 API，定期拉取并且聚合应用监控信息，最终可以实现秒级的实时监控。</li>
<li><a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#6-%E8%A7%84%E5%88%99%E7%AE%A1%E7%90%86%E5%8F%8A%E6%8E%A8%E9%80%81"><strong>规则管理和推送</strong></a>：统一管理推送规则。</li>
<li><a href="https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#%E9%89%B4%E6%9D%83"><strong>鉴权</strong></a>：生产环境中鉴权非常重要。这里每个开发者需要根据自己的实际情况进行定制。</li>
</ul>
<blockquote>
<p>注意：Sentinel 控制台目前仅支持单机部署。</p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul>
<li>jar包可以在<a href="https://github.com/alibaba/Sentinel/releases">release</a>页面进行下载</li>
<li>或者下载源码，运行时需要自行打包</li>
</ul>
<blockquote>
<p><strong>注意</strong>：启动 Sentinel 控制台需要 JDK 版本为 1.8 及以上版本。</p>
</blockquote>
<h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p>从 Sentinel 1.5.0 开始，控制台提供通用的鉴权接口 <a href="https://github.com/alibaba/Sentinel/blob/master/sentinel-dashboard/src/main/java/com/alibaba/csp/sentinel/dashboard/auth/AuthService.java">AuthService</a>，用户可根据需求自行实现。</p>
<p>从 Sentinel 1.6.0 起，Sentinel 控制台引入基本的<strong>登录</strong>功能，默认用户名和密码都是 <code>sentinel</code>。</p>
<p>用户可以通过如下参数进行配置：</p>
<ul>
<li><code>-Dsentinel.dashboard.auth.username=sentinel</code> 用于指定控制台的登录用户名为 <code>sentinel</code>；</li>
<li><code>-Dsentinel.dashboard.auth.password=123456</code> 用于指定控制台的登录密码为 <code>123456</code>；如果省略这两个参数，默认用户和密码均为 <code>sentinel</code>；</li>
<li><code>-Dserver.servlet.session.timeout=7200</code> 用于指定 Spring Boot 服务端 session 的过期时间，如 <code>7200</code> 表示 7200 秒；<code>60m</code> 表示 60 分钟，默认为 30 分钟；</li>
</ul>
<p>同样也可以直接在 Spring properties 文件中进行配置。</p>
<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>使用如下命令启动控制台：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">java -Dserver.port&#x3D;8080 -Dcsp.sentinel.dashboard.server&#x3D;localhost:8080 -Dproject.name&#x3D;sentinel-dashboard -jar sentinel-dashboard.jar<br></code></pre></td></tr></table></figure>

<p>如若8080端口冲突，可使用 <code>-Dserver.port=新端口</code> 进行设置。</p>
<p>浏览器打开localhost:8080，用户名和密码均为sentinel</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222140202124.png"></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>在application.yml中加入如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">spring:<br>  cloud:<br>    sentinel:<br>      transport:<br>        port: 8719<br>        dashboard: localhost:8080<br></code></pre></td></tr></table></figure>

<p>如果是用nacos作为配置中心，需要在nacos中配置应用的配置文件</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222141249143.png"></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如果我们想使用Sentinel的限流和熔断功能，除了在代码中可以硬编码外，也可直接通过控制台进行粗略的对接口进行限流和熔断。</p>
<p>在Controller中加入测试方法，注意此Controller使用的时@RestController注解，如果是@Controller，请给方法加上@ResponseBody注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求资源</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@GetMapping(&quot;/testReq&quot;)</span><br><span class="hljs-meta">@SentinelResource(&quot;testSource&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doTest</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>先调用一次该方法，方便被簇点链路收集，调用后，可在控制台-&gt;簇点链路中看到该资源</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222143641431.png"></p>
<p>点击<code>+流控</code>新增规则</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222143739655.png" style="zoom:67%;" />

<p>使用Jmeter进行测试，每秒执行10个请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222162100220.png"></p>
<p>http请求</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222144632025.png"></p>
<p>发现此处通过QPS最大限定值后，其余请求都被拒绝</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201222162035491.png"></p>
]]></content>
      <categories>
        <category>SpringCloudAlibaba</category>
      </categories>
      <tags>
        <tag>SpringCloudAlibaba</tag>
        <tag>熔断</tag>
        <tag>流控</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba之Nacos配置Mysql数据库</title>
    <url>/2020/12/21/SpringCloudAlibaba%E4%B9%8BNacos%E9%85%8D%E7%BD%AEMysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Surport-Mysql"><a href="#Surport-Mysql" class="headerlink" title="Surport Mysql"></a>Surport Mysql</h1><p>在0.7版本之前Nacos是不支持Mysql数据库的，是使用的本地的derby数据库。这样虽然方便，不用进行额外的配置，但是不能很好的观察到数据的基本情况，也就是不好可视化。在0.7及之后，Nacos支持外部Mysql数据库存储数据，这可以在<a href="https://github.com/alibaba/nacos/releases">nacos release</a>中找到公示。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221201249189.png"></p>
<h1 id="Config-Mysql"><a href="#Config-Mysql" class="headerlink" title="Config Mysql"></a>Config Mysql</h1><p>本文以Nacos1.3.2为例，首先在<a href="https://github.com/alibaba/nacos/releases">nacos release</a>下载1.3.2的压缩包，下载解压后找到<code>/conf/nacos-mysql.sql</code></p>
<p>在数据库新建一个数据库，并导入sql文件，此时会生成下列表</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221201755871.png"></p>
<p>此时需要配置<code>/conf/application.properties</code>，告诉nacos使用外部mysql</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221201940234.png"></p>
<p>此时再启动nacos就会基于外部mysql数据库进行工作</p>
]]></content>
      <categories>
        <category>SpringCloudAlibaba</category>
      </categories>
      <tags>
        <tag>SpringCloudAlibaba</tag>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba之Nacos配置与注册</title>
    <url>/2020/12/21/SpringCloudAlibaba%E4%B9%8BNacos%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%B3%A8%E5%86%8C/</url>
    <content><![CDATA[<h1 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h1><p>编辑器：IDEA</p>
<p>系列源代码GitHub地址<a href="https://github.com/hanguilin/SpringCloudDemo">SpringCloudDemo</a></p>
<h2 id="创建父项目"><a href="#创建父项目" class="headerlink" title="创建父项目"></a>创建父项目</h2><p>File-&gt;New-&gt;Project</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221171651514.png"  />

<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221172848985.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221173008882.png"></p>
<h2 id="父项目引入依赖"><a href="#父项目引入依赖" class="headerlink" title="父项目引入依赖"></a>父项目引入依赖</h2><p>注意添加<code>&lt;packaging&gt;pom&lt;/packaging&gt;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;<br>         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;<br><br>    &lt;groupId&gt;cn.javayuli&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;nacos&lt;&#x2F;artifactId&gt;<br>    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;<br>    &lt;version&gt;1.0.0&lt;&#x2F;version&gt;<br><br>    &lt;parent&gt;<br>        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;<br>        &lt;version&gt;2.3.6.RELEASE&lt;&#x2F;version&gt;<br>    &lt;&#x2F;parent&gt;<br><br>    &lt;properties&gt;<br>        &lt;spring-boot.version&gt;2.3.6.RELEASE&lt;&#x2F;spring-boot.version&gt;<br>        &lt;spring-cloud.version&gt;Hoxton.SR9&lt;&#x2F;spring-cloud.version&gt;<br>        &lt;spring-cloud-alibaba.version&gt;2.2.3.RELEASE&lt;&#x2F;spring-cloud-alibaba.version&gt;<br>        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;<br>        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;<br>        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;<br>    &lt;&#x2F;properties&gt;<br><br>    &lt;dependencyManagement&gt;<br>        &lt;dependencies&gt;<br>            &lt;dependency&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;<br>                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;&#x2F;version&gt;<br>                &lt;type&gt;pom&lt;&#x2F;type&gt;<br>                &lt;scope&gt;import&lt;&#x2F;scope&gt;<br>            &lt;&#x2F;dependency&gt;<br>            &lt;dependency&gt;<br>                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;<br>                &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;&#x2F;version&gt;<br>                &lt;type&gt;pom&lt;&#x2F;type&gt;<br>                &lt;scope&gt;import&lt;&#x2F;scope&gt;<br>            &lt;&#x2F;dependency&gt;<br>            &lt;!--spring cloud alibaba--&gt;<br>            &lt;dependency&gt;<br>                &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;<br>                &lt;version&gt;$&#123;spring-cloud-alibaba.version&#125;&lt;&#x2F;version&gt;<br>                &lt;type&gt;pom&lt;&#x2F;type&gt;<br>                &lt;scope&gt;import&lt;&#x2F;scope&gt;<br>            &lt;&#x2F;dependency&gt;<br>            &lt;!--web 模块--&gt;<br>            &lt;dependency&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>                &lt;version&gt;$&#123;spring-boot.version&#125;&lt;&#x2F;version&gt;<br>            &lt;&#x2F;dependency&gt;<br>        &lt;&#x2F;dependencies&gt;<br>    &lt;&#x2F;dependencyManagement&gt;<br><br>    &lt;build&gt;<br>        &lt;finalName&gt;$&#123;project.name&#125;&lt;&#x2F;finalName&gt;<br>        &lt;resources&gt;<br>            &lt;resource&gt;<br>                &lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;<br>                &lt;filtering&gt;true&lt;&#x2F;filtering&gt;<br>            &lt;&#x2F;resource&gt;<br>        &lt;&#x2F;resources&gt;<br>        &lt;pluginManagement&gt;<br>            &lt;plugins&gt;<br>                &lt;plugin&gt;<br>                    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;<br>                    &lt;version&gt;$&#123;spring-boot.version&#125;&lt;&#x2F;version&gt;<br>                    &lt;configuration&gt;<br>                        &lt;finalName&gt;$&#123;project.build.finalName&#125;&lt;&#x2F;finalName&gt;<br>                    &lt;&#x2F;configuration&gt;<br>                    &lt;executions&gt;<br>                        &lt;execution&gt;<br>                            &lt;goals&gt;<br>                                &lt;goal&gt;repackage&lt;&#x2F;goal&gt;<br>                            &lt;&#x2F;goals&gt;<br>                        &lt;&#x2F;execution&gt;<br>                    &lt;&#x2F;executions&gt;<br>                &lt;&#x2F;plugin&gt;<br><br>            &lt;&#x2F;plugins&gt;<br>        &lt;&#x2F;pluginManagement&gt;<br>    &lt;&#x2F;build&gt;<br><br>    &lt;repositories&gt;<br>        &lt;!--阿里云主仓库，代理了maven central和jcenter仓库--&gt;<br>        &lt;repository&gt;<br>            &lt;id&gt;aliyun&lt;&#x2F;id&gt;<br>            &lt;name&gt;aliyun&lt;&#x2F;name&gt;<br>            &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt;<br>            &lt;releases&gt;<br>                &lt;enabled&gt;true&lt;&#x2F;enabled&gt;<br>            &lt;&#x2F;releases&gt;<br>            &lt;snapshots&gt;<br>                &lt;enabled&gt;false&lt;&#x2F;enabled&gt;<br>            &lt;&#x2F;snapshots&gt;<br>        &lt;&#x2F;repository&gt;<br>    &lt;&#x2F;repositories&gt;<br><br>    &lt;pluginRepositories&gt;<br>        &lt;pluginRepository&gt;<br>            &lt;id&gt;aliyun-plugin&lt;&#x2F;id&gt;<br>            &lt;url&gt;https:&#x2F;&#x2F;maven.aliyun.com&#x2F;repository&#x2F;public&lt;&#x2F;url&gt;<br>            &lt;releases&gt;<br>                &lt;enabled&gt;true&lt;&#x2F;enabled&gt;<br>            &lt;&#x2F;releases&gt;<br>            &lt;snapshots&gt;<br>                &lt;enabled&gt;false&lt;&#x2F;enabled&gt;<br>            &lt;&#x2F;snapshots&gt;<br>        &lt;&#x2F;pluginRepository&gt;<br>    &lt;&#x2F;pluginRepositories&gt;<br><br>    &lt;profiles&gt;<br>        &lt;profile&gt;<br>            &lt;id&gt;dev&lt;&#x2F;id&gt;<br>            &lt;properties&gt;<br>                &lt;!-- 环境标识，需要与配置文件的名称相对应 --&gt;<br>                &lt;profiles.active&gt;dev&lt;&#x2F;profiles.active&gt;<br>            &lt;&#x2F;properties&gt;<br>            &lt;activation&gt;<br>                &lt;!-- 默认环境 --&gt;<br>                &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;<br>            &lt;&#x2F;activation&gt;<br>        &lt;&#x2F;profile&gt;<br>    &lt;&#x2F;profiles&gt;<br><br>&lt;&#x2F;project&gt;<br></code></pre></td></tr></table></figure>

<p>删除其src文件夹</p>
<p>注意版本SpringBoot、springCloud、SpringCloudAlibaba的版本搭配</p>
<h2 id="组件版本关系"><a href="#组件版本关系" class="headerlink" title="组件版本关系"></a>组件版本关系</h2><table>
<thead>
<tr>
<th>Spring Cloud Alibaba Version</th>
<th>Sentinel Version</th>
<th>Nacos Version</th>
<th>RocketMQ Version</th>
<th>Dubbo Version</th>
<th align="center">Seata Version</th>
</tr>
</thead>
<tbody><tr>
<td>2.2.3.RELEASE or 2.1.3.RELEASE or 2.0.3.RELEASE</td>
<td>1.8.0</td>
<td>1.3.3</td>
<td>4.4.0</td>
<td>2.7.8</td>
<td align="center">1.3.0</td>
</tr>
<tr>
<td>2.2.1.RELEASE or 2.1.2.RELEASE or 2.0.2.RELEASE</td>
<td>1.7.1</td>
<td>1.2.1</td>
<td>4.4.0</td>
<td>2.7.6</td>
<td align="center">1.2.0</td>
</tr>
<tr>
<td>2.2.0.RELEASE</td>
<td>1.7.1</td>
<td>1.1.4</td>
<td>4.4.0</td>
<td>2.7.4.1</td>
<td align="center">1.0.0</td>
</tr>
<tr>
<td>2.1.1.RELEASE or 2.0.1.RELEASE or 1.5.1.RELEASE</td>
<td>1.7.0</td>
<td>1.1.4</td>
<td>4.4.0</td>
<td>2.7.3</td>
<td align="center">0.9.0</td>
</tr>
<tr>
<td>2.1.0.RELEASE or 2.0.0.RELEASE or 1.5.0.RELEASE</td>
<td>1.6.3</td>
<td>1.1.1</td>
<td>4.4.0</td>
<td>2.7.3</td>
<td align="center">0.7.1</td>
</tr>
</tbody></table>
<h2 id="毕业版本依赖关系-推荐使用"><a href="#毕业版本依赖关系-推荐使用" class="headerlink" title="毕业版本依赖关系(推荐使用)"></a>毕业版本依赖关系(推荐使用)</h2><table>
<thead>
<tr>
<th>Spring Cloud Version</th>
<th>Spring Cloud Alibaba Version</th>
<th>Spring Boot Version</th>
</tr>
</thead>
<tbody><tr>
<td>Spring Cloud Hoxton.SR8</td>
<td>2.2.3.RELEASE</td>
<td>2.3.2.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Greenwich.SR6</td>
<td>2.1.3.RELEASE</td>
<td>2.1.13.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Hoxton.SR3</td>
<td>2.2.1.RELEASE</td>
<td>2.2.5.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Hoxton.RELEASE</td>
<td>2.2.0.RELEASE</td>
<td>2.2.X.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Greenwich</td>
<td>2.1.2.RELEASE</td>
<td>2.1.X.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Finchley</td>
<td>2.0.3.RELEASE</td>
<td>2.0.X.RELEASE</td>
</tr>
<tr>
<td>Spring Cloud Edgware</td>
<td>1.5.1.RELEASE(停止维护，建议升级)</td>
<td>1.5.X.RELEASE</td>
</tr>
</tbody></table>
<p>顺带提一个需要注意的点，<font color=red>低版本的spring-cloud-alibaba-dependencies和高版本的group-id是不同的</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221195213323.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221195253428.png"></p>
<h2 id="创建子项目"><a href="#创建子项目" class="headerlink" title="创建子项目"></a>创建子项目</h2><p>右键nacos项目，new-&gt;module</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221173722014.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221173849254.png"></p>
<p>需要使用nacos配置功能需要引入<code>spring-cloud-starter-alibaba-nacos-config</code>依赖，</p>
<p>需要使用nacos注册功能需要引入<code>spring-cloud-starter-alibaba-nacos-discovery</code>依赖</p>
<h2 id="子项目引入依赖"><a href="#子项目引入依赖" class="headerlink" title="子项目引入依赖"></a>子项目引入依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;<br>         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;<br><br>    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;<br>    &lt;artifactId&gt;api-provider&lt;&#x2F;artifactId&gt;<br><br>    &lt;parent&gt;<br>        &lt;artifactId&gt;nacos&lt;&#x2F;artifactId&gt;<br>        &lt;groupId&gt;cn.javayuli&lt;&#x2F;groupId&gt;<br>        &lt;version&gt;1.0.0&lt;&#x2F;version&gt;<br>    &lt;&#x2F;parent&gt;<br><br>    &lt;properties&gt;<br>        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;<br>    &lt;&#x2F;properties&gt;<br><br>    &lt;dependencies&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>        &lt;!-- nacos配置依赖 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>		&lt;!-- nacos注册依赖 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;<br>        &lt;&#x2F;dependency&gt;<br>    &lt;&#x2F;dependencies&gt;<br><br>    &lt;!--maven的插件--&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;<br>            &lt;&#x2F;plugin&gt;<br><br>        &lt;&#x2F;plugins&gt;<br>    &lt;&#x2F;build&gt;<br>&lt;&#x2F;project&gt;<br></code></pre></td></tr></table></figure>

<p>子项目新增启动类<code>ProviderApplication.java</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221180819858.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javayuli;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产者</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDiscoveryClient</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProviderApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ProviderApplication.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>增加测试类<code>TestController.java</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221181128070.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.javayuli.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.annotation.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试获取nacos中的配置</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/config&quot;)</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;useLocalCache:false&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> useLocalCache;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/get&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> useLocalCache;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>api-provider</code>项目增加<code>bootstrap.yml</code>配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221174658787.png"></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">@artifactId@</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-string">$&#123;spring.cloud.nacos.discovery.server-addr&#125;</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yml</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">@profiles.active@</span><br></code></pre></td></tr></table></figure>

<p><code>spring.application.name</code>表示应用的名称</p>
<p><code>spring.cloud.nacos.discovery.server-addr</code>表示注册中心的地址</p>
<p><code>spring.cloud.nacos.config.server-addr</code>表示配置中心的地址</p>
<p><code>spring.cloud.nacos.config.file-extension</code>表示配置内容的数据格式，目前只支持 <code>properties</code> 和 <code>yaml</code> 类型。</p>
<p><code>spring.profiles.active</code>表示当前项目激活的配置文件，如果值为dev，那么在普通SpringBoot项目中激活的配置文件就是<code>application-dev.properties</code>或者<code>application-dev.yml</code>。这里<code>@profiles.active@</code>表示从pom.xml中获取到的变量值（这个值在父pom中已配置）。</p>
<h1 id="Nacos添加配置"><a href="#Nacos添加配置" class="headerlink" title="Nacos添加配置"></a>Nacos添加配置</h1><p>启动Nacos后，在浏览器打开localhost:8848/nacos，并输入用户名nacos和密码nacos进入管理中心。</p>
<p>点击右侧加号添加配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221175617205.png"></p>
<p>Data ID为spring.application.name+spring.profiles.active+spring.cloud.nacos.config.file-extension，配置内容为正常的SpringBoot配置，配置好后点击发布</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221181405454.png"></p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>启动项目，可看到tomcat启动端口为8000</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221181227009.png"></p>
<p>打开IDEA自带的接口测试工具</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221181613282.png"></p>
<p>填入接口信息后点击测试，发现可以获取到Nacos配置的值，即Nacos成功作为配置中心</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221181704768.png"></p>
<p>编辑<code>api-provider-dev.yml</code>中的值，将<code>useLocalCache</code>更改为<code>false</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221182037747.png"></p>
<p>再次请求接口，值已经改为false，说明成功动态读取配置</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221182148697.png"></p>
<p>在Nacos中可以看到注册的服务实例，说明Nacos成功作为服务注册中心</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201221181832754.png"></p>
]]></content>
      <categories>
        <category>SpringCloudAlibaba</category>
      </categories>
      <tags>
        <tag>SpringCloudAlibaba</tag>
        <tag>Nacos</tag>
        <tag>注册中心</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba之NacosServer</title>
    <url>/2020/12/21/SpringCloudAlibaba%E4%B9%8BNacosServer/</url>
    <content><![CDATA[<h1 id="Nacos-Server"><a href="#Nacos-Server" class="headerlink" title="Nacos Server"></a>Nacos Server</h1><h2 id="1-版本选择"><a href="#1-版本选择" class="headerlink" title="1.版本选择"></a>1.版本选择</h2><p>可以在Nacos的<a href="https://github.com/alibaba/nacos/releases">Nacos release</a>中找到每个版本发行的日志，当前推荐的稳定版本1.3.1。</p>
<h2 id="2-环境配置"><a href="#2-环境配置" class="headerlink" title="2.环境配置"></a>2.环境配置</h2><p>Nacos 依赖 <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">Java</a> 环境来运行。如果您是从代码开始构建并运行Nacos，还需要为此配置 <a href="https://maven.apache.org/index.html">Maven</a>环境，请确保是在以下版本环境中安装使用:</p>
<ol>
<li>64 bit OS，支持 Linux/Unix/Mac/Windows，推荐选用 Linux/Unix/Mac。</li>
<li>64 bit JDK 1.8+；<a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">下载</a> &amp; <a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">配置</a>。</li>
<li>Maven 3.2.x+；<a href="https://maven.apache.org/download.cgi">下载</a> &amp; <a href="https://maven.apache.org/settings.html">配置</a>。</li>
</ol>
<p>你可以通过源码和发行包两种方式来获取 Nacos。</p>
<h2 id="3-下载源码或者安装包"><a href="#3-下载源码或者安装包" class="headerlink" title="3.下载源码或者安装包"></a>3.下载源码或者安装包</h2><h3 id="从-Github-上下载源码方式"><a href="#从-Github-上下载源码方式" class="headerlink" title="从 Github 上下载源码方式"></a>从 Github 上下载源码方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/alibaba/nacos.git<br><span class="hljs-built_in">cd</span> nacos/<br>mvn -Prelease-nacos -Dmaven.test.skip=<span class="hljs-literal">true</span> clean install -U  <br>ls -al distribution/target/<br><br>// change the <span class="hljs-variable">$version</span> to your actual path<br><span class="hljs-built_in">cd</span> distribution/target/nacos-server-<span class="hljs-variable">$version</span>/nacos/bin<br></code></pre></td></tr></table></figure>

<h3 id="下载编译后压缩包方式"><a href="#下载编译后压缩包方式" class="headerlink" title="下载编译后压缩包方式"></a>下载编译后压缩包方式</h3><p>您可以从 <a href="https://github.com/alibaba/nacos/releases">最新稳定版本</a> 下载 <code>nacos-server-$version.zip</code> 包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">unzip nacos-server-<span class="hljs-variable">$version</span>.zip 或者 tar -xvf nacos-server-<span class="hljs-variable">$version</span>.tar.gz<br><span class="hljs-built_in">cd</span> nacos/bin<br></code></pre></td></tr></table></figure>

<h2 id="4-启动服务器"><a href="#4-启动服务器" class="headerlink" title="4.启动服务器"></a>4.启动服务器</h2><h3 id="Linux-Unix-Mac"><a href="#Linux-Unix-Mac" class="headerlink" title="Linux/Unix/Mac"></a>Linux/Unix/Mac</h3><p>启动命令(standalone代表着单机模式运行，非集群模式):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sh startup.sh -m standalone<br></code></pre></td></tr></table></figure>

<p>如果您使用的是ubuntu系统，或者运行脚本报错提示[[符号找不到，可尝试如下运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">bash startup.sh -m standalone<br></code></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>启动命令(standalone代表着单机模式运行，非集群模式):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cmd startup.cmd -m standalone<br></code></pre></td></tr></table></figure>

<h2 id="5-服务注册-amp-发现和配置管理"><a href="#5-服务注册-amp-发现和配置管理" class="headerlink" title="5.服务注册&amp;发现和配置管理"></a>5.服务注册&amp;发现和配置管理</h2><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -X POST <span class="hljs-string">&#x27;http://127.0.0.1:8848/nacos/v1/ns/instance?serviceName=nacos.naming.serviceName&amp;ip=20.18.7.10&amp;port=8080&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -X GET <span class="hljs-string">&#x27;http://127.0.0.1:8848/nacos/v1/ns/instance/list?serviceName=nacos.naming.serviceName&#x27;</span><br></code></pre></td></tr></table></figure>

<h3 id="发布配置"><a href="#发布配置" class="headerlink" title="发布配置"></a>发布配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -X POST <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&amp;content=HelloWorld&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="获取配置"><a href="#获取配置" class="headerlink" title="获取配置"></a>获取配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">curl -X GET <span class="hljs-string">&quot;http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.cfg.dataId&amp;group=test&quot;</span><br></code></pre></td></tr></table></figure>

<h2 id="6-关闭服务器"><a href="#6-关闭服务器" class="headerlink" title="6.关闭服务器"></a>6.关闭服务器</h2><h3 id="Linux-Unix-Mac-1"><a href="#Linux-Unix-Mac-1" class="headerlink" title="Linux/Unix/Mac"></a>Linux/Unix/Mac</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sh shutdown.sh<br></code></pre></td></tr></table></figure>

<h3 id="Windows-1"><a href="#Windows-1" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">cmd shutdown.cmd<br></code></pre></td></tr></table></figure>

<p>或者双击shutdown.cmd运行文件。</p>
]]></content>
      <categories>
        <category>SpringCloudAlibaba</category>
      </categories>
      <tags>
        <tag>SpringCloudAlibaba</tag>
        <tag>Nacos</tag>
        <tag>NacosServer</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloudAlibaba之Nacos初探</title>
    <url>/2020/12/21/SpringCloudAlibaba%E4%B9%8BNacos%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="什么是-Nacos"><a href="#什么是-Nacos" class="headerlink" title="什么是 Nacos"></a>什么是 Nacos</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>欢迎来到 Nacos 的世界！</p>
<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
<h2 id="什么是-Nacos？"><a href="#什么是-Nacos？" class="headerlink" title="什么是 Nacos？"></a>什么是 Nacos？</h2><p>服务（Service）是 Nacos 世界的一等公民。Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理：</p>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/service/">Kubernetes Service</a></p>
<p><a href="https://grpc.io/docs/guides/concepts.html#service-definition">gRPC</a> &amp; <a href="https://dubbo.incubator.apache.org/">Dubbo RPC Service</a></p>
<p><a href="https://spring.io/understanding/REST">Spring Cloud RESTful Service</a></p>
<p>Nacos 的关键特性包括:</p>
<ul>
<li><p><strong>服务发现和服务健康监测</strong></p>
<p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a>、或一个<a href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a>查找和发现服务。</p>
<p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>
</li>
<li><p><strong>动态配置服务</strong></p>
<p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
<p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p>
<p>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p>
<p>Nacos 提供了一个简洁易用的UI (<a href="http://console.nacos.io/nacos/index.html">控制台样例 Demo</a>) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>
</li>
<li><p><strong>动态 DNS 服务</strong></p>
<p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</p>
<p>Nacos 提供了一些简单的 <a href="https://nacos.io/zh-cn/docs/xx">DNS APIs TODO</a> 帮助您管理服务的关联域名和可用的 IP:PORT 列表.</p>
</li>
<li><p><strong>服务及其元数据管理</strong></p>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>
</li>
<li><p><a href="https://nacos.io/zh-cn/docs/roadmap.html">更多的特性列表 …</a></p>
</li>
</ul>
<h2 id="Nacos-地图"><a href="#Nacos-地图" class="headerlink" title="Nacos 地图"></a>Nacos 地图</h2><p>一图看懂 Nacos，下面架构部分会详细介绍。 </p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/nacosMap.jpg"></p>
<ul>
<li>特性大图：要从功能特性，非功能特性，全面介绍我们要解的问题域的特性诉求</li>
<li>架构大图：通过清晰架构，让您快速进入 Nacos 世界</li>
<li>业务大图：利用当前特性可以支持的业务场景，及其最佳实践</li>
<li>生态大图：系统梳理 Nacos 和主流技术生态的关系</li>
<li>优势大图：展示 Nacos 核心竞争力</li>
<li>战略大图：要从战略到战术层面讲 Nacos 的宏观优势</li>
</ul>
<h2 id="Nacos-生态图"><a href="#Nacos-生态图" class="headerlink" title="Nacos 生态图"></a>Nacos 生态图</h2><p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/1533045871534-e64b8031-008c-4dfc-b6e8-12a597a003fb.png"></p>
<p>如 Nacos 全景图所示，Nacos 无缝支持一些主流的开源生态，例如</p>
<ul>
<li><a href="https://nacos.io/en-us/docs/quick-start-spring-cloud.html">Spring Cloud</a></li>
<li><a href="https://nacos.io/zh-cn/docs/use-nacos-with-dubbo.html">Apache Dubbo and Dubbo Mesh</a></li>
<li><a href="https://nacos.io/zh-cn/docs/use-nacos-with-kubernetes.html">Kubernetes and CNCF</a>。</li>
</ul>
<p>使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。</p>
<p>关于如何在这些生态中使用 Nacos，请参考以下文档：</p>
<p><a href="https://nacos.io/zh-cn/docs/use-nacos-with-springcloud.html">Nacos与Spring Cloud一起使用</a></p>
<p><a href="https://nacos.io/zh-cn/docs/use-nacos-with-kubernetes.html">Nacos与Kubernetes一起使用</a></p>
<p><a href="https://nacos.io/zh-cn/docs/use-nacos-with-dubbo.html">Nacos与Dubbo一起使用</a></p>
<p><a href="https://nacos.io/zh-cn/docs/roadmap.html">Nacos与gRPC一起使用</a></p>
<p><a href="https://nacos.io/zh-cn/docs/use-nacos-with-istio.html">Nacos与Istio一起使用</a></p>
]]></content>
      <categories>
        <category>SpringCloudAlibaba</category>
      </categories>
      <tags>
        <tag>SpringCloudAlibaba</tag>
        <tag>Nacos</tag>
        <tag>分布式</tag>
        <tag>注册中心</tag>
        <tag>配置中心</tag>
      </tags>
  </entry>
  <entry>
    <title>搞定Spring的BeanFactory和FactoryBean</title>
    <url>/2020/12/15/%E6%90%9E%E5%AE%9ASpring%E7%9A%84BeanFactory%E5%92%8CFactoryBean/</url>
    <content><![CDATA[<p>Spring的核心是IOC和AOP，面试Java的基本上都会被问到它们是干什么的，可能你就简单的说了是控制反转与面向切面编程，那么具体细节就很可能被问懵。今天我们来讲一下IOC中围绕Bean的一个知识点，BeanFactory与FactoryBean。每天搞懂一个知识点，长期下来会让你受益匪浅。</p>
<h1 id="一、区别"><a href="#一、区别" class="headerlink" title="一、区别"></a>一、区别</h1><ul>
<li><p>相同点：</p>
<p>BeanFactory是接口，提供了IOC容器最基本的形式，也就是SpringIOC所遵循的最底层和最基本的编程规范。</p>
<p>FactoryBean是接口，实现这个接口的类，在注册到BeanFactory中时，并不像其他类暴露的是自己，而是FactoryBean中的getObject()方法的返回对象。</p>
</li>
<li><p>不同点：</p>
<p>BeanFactory是个factory，也就是IOC容器或者对相关工厂，在Spring中，所有的Bean都是由BeanFactory，也就是IOC容器来进行管理的。</p>
<p>FactoryBean是个Bean，但是这个Bean不是一个简单的Bean，而是一个能生产或者修饰对象的工厂Bean，它的实现类似于设计模式中的工厂模式或者装饰者模式。</p>
</li>
</ul>
<h1 id="二、BeanFactory"><a href="#二、BeanFactory" class="headerlink" title="二、BeanFactory"></a>二、BeanFactory</h1><p>比较熟悉的DefaultListableBeanFactory、XmlBeanFactory、ApplicationContext类都是BeanFactory的子类。</p>
<p>BeanFacotry是spring中比较原始的Factory。如XMLBeanFactory就是一种典型的BeanFactory。</p>
<p>原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。ApplicationContext接口，它由BeanFactory接口派生而来，ApplicationContext包含BeanFactory的所有功能，通常建议比BeanFactory优先 。</p>
<p>ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承，ApplicationContext包还提供了以下的功能： </p>
<ul>
<li>MessageSource, 提供国际化的消息访问； </li>
<li>资源访问，如URL和文件；</li>
<li>事件传播；</li>
<li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层；</li>
</ul>
<p>BeanFactory源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br><br>	String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>	<span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>	<span class="hljs-comment">// 根据名称和类型获取，如果名称对应的bean不是requiredType类型的，就抛出错误</span><br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>	<span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>	&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;<br><br>	&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>	<span class="hljs-meta">@Nullable</span><br>	Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>	<span class="hljs-meta">@Nullable</span><br>	Class&lt;?&gt; getType(String name, <span class="hljs-keyword">boolean</span> allowFactoryBeanInit) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>	String[] getAliases(String name);<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>方法简介：</p>
<ul>
<li><p><strong>boolean containsBean(String beanName)</strong> </p>
<p>判断工厂中是否包含给定名称的bean定义，若有则返回true</p>
</li>
<li><p><strong>Object getBean(String)</strong> </p>
<p>返回给定名称注册的bean实例。根据bean的配置情况，如果是singleton模式将返回一个共享实例，否则将返回一个新建的实例，如果没有找到指定bean,该方法可能会抛出异常</p>
</li>
<li><p><strong>Object getBean(String, Class)</strong> </p>
<p>返回以给定名称给定类型注册的bean实例，如果bean不是给定Class的类型就抛出错误</p>
</li>
<li><p><strong>Class getType(String name)</strong> </p>
<p>返回给定名称的bean的Class,如果没有找到指定的bean实例，则排除NoSuchBeanDefinitionException异常</p>
</li>
<li><p><strong>boolean isSingleton(String)</strong> </p>
<p>判断给定名称的bean定义是否为单例模式</p>
</li>
<li><p><strong>String[] getAliases(String name)</strong> </p>
<p>返回给定bean名称的所有别名 </p>
<h1 id="三、FactoryBean"><a href="#三、FactoryBean" class="headerlink" title="三、FactoryBean"></a>三、FactoryBean</h1><p>一般情况下，Spring通过反射机制利用&lt;bean&gt;的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在&lt;bean&gt;中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean&lt;T&gt;的形式</p>
</li>
</ul>
<p>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<T>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>BeanFactory</tag>
        <tag>FactoryBean</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署之私服管理</title>
    <url>/2020/12/15/Docker%E9%83%A8%E7%BD%B2%E4%B9%8B%E7%A7%81%E6%9C%8D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><p>docker私服是存放镜像的本地仓库，类似于docker hub。不过私服是本地的仓库，方便自己公司部署管理由微服务打包成的docker镜像。</p>
<p>话不多说，通过一个例子，教你快速搭建docker私服。</p>
<h1 id="二、registry搭建"><a href="#二、registry搭建" class="headerlink" title="二、registry搭建"></a>二、registry搭建</h1><ul>
<li>docker搭建</li>
</ul>
<p>如果没有安装虚拟机，可以参考文章《<a href="https://blog.csdn.net/qq_37171817/article/details/106713868">VMware安装Centos7并联网使用</a>》</p>
<p> docker安装参考文章《<a href="https://blog.csdn.net/qq_37171817/article/details/107179217">还不会安装docker？这里帮你搞定</a>》</p>
<ul>
<li>启动docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ systemctl start docker<br></code></pre></td></tr></table></figure>

<ul>
<li><p>拉取registry镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker pull registry<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200802090430860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
</li>
<li><p>查看已下载的镜像</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker images<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200802092104190.png"></p>
<ul>
<li>启动registry</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry docker.io/registry<br></code></pre></td></tr></table></figure>
<p>-d 表示后台运行；</p>
<p>-v 表示挂载目录，将容器内部的/var/lib/registry挂载到宿主机的/opt/registry；</p>
<p>–name 表示取别名；</p>
<p>-p 表示指定端口，第一个参数是外部访问端口，第二个是映射到内部的端口；</p>
<p>docker.io/registry表示镜像名称，如果要指定版本（TAG），需要docker.io/registry:1.0，（假设1.0为版本号）。</p>
<ul>
<li>查看正在运行的容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker ps<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200802092737903.png"></p>
<ul>
<li><p>浏览器中访问</p>
<p>虚拟机ip:5000/v2/_catalog，可以看到私服仓库的信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200802093031919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="三、测试私服仓库"><a href="#三、测试私服仓库" class="headerlink" title="三、测试私服仓库"></a>三、测试私服仓库</h1></li>
<li><p>将加速镜像改为私服地址</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi /etc/docker/daemon.json<br></code></pre></td></tr></table></figure>
<p>修改内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>:<br>    [<br>        <span class="hljs-string">&quot;http://172.20.10.6:5000&quot;</span>,<br>        <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br>        <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span><br>    ],<br>    <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<span class="hljs-string">&quot;172.20.10.6:5000&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>insecure-registries 表示支持http上传的列表，否则仅支持https上传。</p>
<p><img src="https://img-blog.csdnimg.cn/2020080210134174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>拉取镜像到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker pull docker.io/hello-world<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200802100736147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>打标签</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker tag docker.io/hello-world 172.20.10.6:5000/hello-world<br></code></pre></td></tr></table></figure>
<p>172.20.10.6:5000为私服地址。</p>
<p><img src="https://img-blog.csdnimg.cn/20200802100835615.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li><p>将本地镜像上传到私服</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker push 172.20.10.6:5000/hello-world<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200802100950871.png"></p>
</li>
<li><p>查看私服</p>
<p><img src="https://img-blog.csdnimg.cn/20200802101428638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>或使用curl测试：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ curl -XGET http://172.20.10.6:5000/v2/_catalog<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200802102047265.png"></p>
<h1 id="四、SpringBoot项目上传私服"><a href="#四、SpringBoot项目上传私服" class="headerlink" title="四、SpringBoot项目上传私服"></a>四、SpringBoot项目上传私服</h1><p>编辑/usr/lib/systemd/system/docker.service文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi /usr/lib/systemd/system/docker.service<br></code></pre></td></tr></table></figure>
<p>添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">-H tcp://0.0.0.0:2375 \<br>-H unix://var/run/docker.sock \<br></code></pre></td></tr></table></figure>
<p>目的是为了方便远程使用docker-maven-plugin插件上传镜像到私服。</p>
<p><img src="https://img-blog.csdnimg.cn/20200802173307828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>重启docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ systemctl daemon-reload<br>$ systemctl restart docker<br></code></pre></td></tr></table></figure>
<p>docker-maven-plugin配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;plugin&gt;<br>	&lt;groupId&gt;io.fabric8&lt;/groupId&gt;<br>	&lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;<br>	&lt;version&gt;<span class="hljs-variable">$&#123;docker.plugin.version&#125;</span>&lt;/version&gt;<br>	&lt;configuration&gt;<br>		&lt;!-- Docker Remote Api--&gt;<br>		&lt;dockerHost&gt;http://172.20.10.6:2375&lt;/dockerHost&gt;<br>		&lt;!-- Docker 镜像私服--&gt;<br>		&lt;registry&gt;172.20.10.6:5000&lt;/registry&gt;<br>		&lt;images&gt;<br>			&lt;image&gt;<br>				&lt;name&gt;172.20.10.6:5000/library/<span class="hljs-variable">$&#123;project.name&#125;</span>:<span class="hljs-variable">$&#123;project.version&#125;</span>&lt;/name&gt;<br>				&lt;build&gt;<br>					&lt;dockerFile&gt;<span class="hljs-variable">$&#123;project.basedir&#125;</span>/Dockerfile&lt;/dockerFile&gt;<br>				&lt;/build&gt;<br>			&lt;/image&gt;<br>		&lt;/images&gt;<br>	&lt;/configuration&gt;<br>&lt;/plugin&gt;<br></code></pre></td></tr></table></figure>
<p>${project.basedir}是项目根目录。</p>
<p>Dockefile配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">FROM openjdk:8-jdk-alpine<br><br>MAINTAINER wangiegie@gmail.com<br><br>ENV TZ=Asia/Shanghai<br><br>RUN ln -sf /usr/share/zoneinfo/<span class="hljs-variable">$TZ</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$TZ</span> &gt; /etc/timezone<br><br>RUN mkdir -p /pig-register<br><br>WORKDIR /pig-register<br><br>EXPOSE 8848<br><br>ADD ./target/pig-register.jar ./<br><br>CMD sleep 30;java -Djava.security.egd=file:/dev/./urandom -jar pig-register.jar<br></code></pre></td></tr></table></figure>
<p>此处不做过多Dockerfile配置说明。</p>
<p>依次执行：</p>
<p>maven clean -&gt; maven install -&gt; docker build -&gt; docker push</p>
<p><img src="https://img-blog.csdnimg.cn/20200802174707732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/2020080217475742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>查看私服镜像仓库：</p>
<p><img src="https://img-blog.csdnimg.cn/20200802174843525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200802174914347.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Docker私服</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令小白篇</title>
    <url>/2020/12/15/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%99%BD%E7%AF%87/</url>
    <content><![CDATA[<h1 id="一、Docker常用命令"><a href="#一、Docker常用命令" class="headerlink" title="一、Docker常用命令"></a>一、Docker常用命令</h1><ul>
<li><p><strong>systemctl start docker</strong></p>
<p>  启动docker</p>
</li>
<li><p><strong>systemctl restart  docker</strong></p>
<p>  重启docker</p>
</li>
<li><p><strong>systemctl stop docker</strong></p>
<p>  停止docker</p>
</li>
<li><p><strong>systemctl status docker</strong></p>
<p>  查看docker状态</p>
</li>
<li><p><strong>docker search [name]</strong></p>
<p>  搜索名为name的镜像，如docker search tomcat</p>
</li>
<li><p><strong>docker pull [name]:[version]</strong></p>
<p>  拉取版本为version的name镜像到本地，如docker pull tomcat:8.5</p>
</li>
<li><p><strong>docker images</strong></p>
<p>  显示所有本地镜像</p>
</li>
<li><p><strong>docker –version</strong></p>
<p>  查看docker版本</p>
</li>
<li><p><strong>docker exec [container id]</strong></p>
<p>  进入id为container id的容器</p>
</li>
<li><p><strong>docker exec -it [name] /bin/bash</strong></p>
<p>  进入名称为name的容器</p>
</li>
<li><p><strong>docker ps</strong></p>
<p>  查看正在运行的容器</p>
</li>
<li><p><strong>docker ps -a</strong></p>
<p>  查看所有容器</p>
</li>
<li><p><strong>docker start [container id]</strong></p>
<p>  启动id为container id的容器</p>
</li>
<li><p><strong>docker stop [container id]</strong></p>
<p>  停止id为container id的容器，删除容器前必须先停止容器</p>
</li>
<li><p><strong>docker rm [container id]</strong></p>
<p>  删除id为container id的容器</p>
</li>
<li><p><strong>docker rmi [image id]</strong></p>
<p>  删除id为image id的镜像</p>
</li>
<li><p><strong>docker logs [container id]</strong></p>
<p>  查看容器id为container id的日志</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个SpringCloud2项目</title>
    <url>/2020/12/15/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASpringCloud2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<p>&emsp;首先创建一个Maven项目：</p>
<img src="https://img-blog.csdnimg.cn/2020072112400676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>&emsp;配置pom.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencyManagement&gt;<br>		&lt;dependencies&gt;<br>			&lt;!-- Spring cloud 依赖管理 --&gt;<br>			&lt;dependency&gt;<br>				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;<br>				&lt;version&gt;Greenwich.SR1&lt;&#x2F;version&gt;<br>				&lt;type&gt;pom&lt;&#x2F;type&gt;<br>				&lt;scope&gt;runtime&lt;&#x2F;scope&gt;<br>			&lt;&#x2F;dependency&gt;<br>			&lt;!-- Spring boot 依赖管理 --&gt;<br>			&lt;dependency&gt;<br>				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>				&lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;<br>				&lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;<br>				&lt;type&gt;pom&lt;&#x2F;type&gt;<br>				&lt;scope&gt;import&lt;&#x2F;scope&gt;<br>			&lt;&#x2F;dependency&gt;<br>		&lt;&#x2F;dependencies&gt;<br>	&lt;&#x2F;dependencyManagement&gt;<br></code></pre></td></tr></table></figure>
<p>&emsp;添加上面的代码，dependencyManagement用于依赖管理，其中定义了许多常用包的版本号，这些包可以在引入dependency时不填写版本号。使用默认配置的好处在于不用花时间解决版本冲突的问题。</p>
<p>&emsp;那么在哪里能看到定义的默认版本号呢？</p>
<p>&emsp;首先找到spring-boot-dependencies在你本地maven仓库的位置：</p>
<p><img src="https://img-blog.csdnimg.cn/20200721130036438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>&emsp;spring-boot-dependencies-2.1.5.RELEASE.pom中定义了版本号等一些配置：</p>
<p><img src="https://img-blog.csdnimg.cn/20200721130142382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;在项目的pom.xml中引入spring-boot-starter-web:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependencies&gt;<br>	&lt;!-- web --&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>		&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>	&lt;&#x2F;dependency&gt;<br>&lt;&#x2F;dependencies&gt;<br></code></pre></td></tr></table></figure>
<p>&emsp;在项目的pom.xml中引入Feign、Hystrix、Eureka:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- feign --&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- hystrix --&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;!-- eureka --&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>&emsp;这里可以不用定义版本号，使用缺省值。</p>
<p><img src="https://img-blog.csdnimg.cn/20200721130357125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200721131851942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;完整的pom.xml配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;<br>	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;<br>	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;<br>	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;<br>	&lt;groupId&gt;com.yl&lt;&#x2F;groupId&gt;<br>	&lt;artifactId&gt;demo-cloud&lt;&#x2F;artifactId&gt;<br>	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;<br><br>	&lt;dependencies&gt;<br>		&lt;!-- web --&gt;<br>		&lt;dependency&gt;<br>			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>		&lt;&#x2F;dependency&gt;<br>		&lt;!-- feign --&gt;<br>		&lt;dependency&gt;<br>			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>			&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;<br>		&lt;&#x2F;dependency&gt;<br>		&lt;!-- hystrix --&gt;<br>		&lt;dependency&gt;<br>			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>			&lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;&#x2F;artifactId&gt;<br>		&lt;&#x2F;dependency&gt;<br>		&lt;!-- eureka --&gt;<br>		&lt;dependency&gt;<br>			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>			&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;<br>		&lt;&#x2F;dependency&gt;<br>	&lt;&#x2F;dependencies&gt;<br><br>	&lt;dependencyManagement&gt;<br>		&lt;dependencies&gt;<br>			&lt;!-- Spring cloud 依赖管理 --&gt;<br>			&lt;dependency&gt;<br>				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;<br>				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;<br>				&lt;version&gt;Greenwich.SR1&lt;&#x2F;version&gt;<br>				&lt;type&gt;pom&lt;&#x2F;type&gt;<br>				&lt;scope&gt;import&lt;&#x2F;scope&gt;<br>			&lt;&#x2F;dependency&gt;<br>			&lt;!-- Spring boot 依赖管理 --&gt;<br>			&lt;dependency&gt;<br>				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>				&lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;<br>				&lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;<br>				&lt;type&gt;pom&lt;&#x2F;type&gt;<br>				&lt;scope&gt;import&lt;&#x2F;scope&gt;<br>			&lt;&#x2F;dependency&gt;<br>		&lt;&#x2F;dependencies&gt;<br>	&lt;&#x2F;dependencyManagement&gt;<br>&lt;&#x2F;project&gt;<br></code></pre></td></tr></table></figure>
<p>&emsp;SpringBoot项目启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloudApplication</span> </span>&#123;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		SpringApplication.run(CloudApplication.class, args);<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&emsp;SpringCloud项目可以使用@SpringCloudApplication，但是需要注意，使用@SpringCloudApplication时需要配置Feign、Hystrix和Eureka，不然会报错。</p>
<p>&emsp;至于Feign、Hystrix和Eureka，他们都是SpringCloud生态中的一部分，分别运用在微服务之间接口调用、服务降级、服务发现与注册中，在后续文章中会一一进行讲解。</p>
<p>&emsp;新建一个controller，注意包位置，SpringBoot项目默认会扫描启动类包路径的子路径中的Bean。</p>
<p>&emsp;这里放出项目结构图：</p>
<p><img src="https://img-blog.csdnimg.cn/202007211322439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>&emsp;在TestController中开发一个最基本的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@GetMapping(&quot;/hello&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doTest</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello word!&quot;</span>;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&emsp;在application.properties中设置项目端口：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">server.port=8080</span><br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2020072113243174.png"></p>
<p>访问接口：</p>
<p><img src="https://img-blog.csdnimg.cn/20200721132507174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈JPA</title>
    <url>/2020/12/15/%E6%B5%85%E8%B0%88JPA/</url>
    <content><![CDATA[<h1 id="一、关于JPA"><a href="#一、关于JPA" class="headerlink" title="一、关于JPA"></a>一、关于JPA</h1><p>&emsp;JPA全称Java Persistence API，是Sun官方在JDK5.0后提出的Java持久化规范（JSR 338），这些类存在于java.persistence包中。JPA的出现主要是为了简化持久层开发以及整合ORM实体映射技术，结束Hibernate、TopLink、ORM各自为营的局面。</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/20200718202041189.png"><br>&emsp;JPA是吸收现有ORM架构的基础再发展，它易于使用，伸缩性强。总的来说，其具有以下三个特点：</p>
<ul>
<li>ORM映射元数据<br>支持xml和注解两种形式，元数据描述对象和表之间的映射关系。</li>
<li>API<br>操作实体对象来进行数据库CRUD。</li>
<li>查询语言<br>通过面向对象，而非面向数据库的查询语言查询数据，降低与数据库的耦合。<h2 id="二、Spring-Data-JPA"><a href="#二、Spring-Data-JPA" class="headerlink" title="二、Spring Data JPA"></a>二、Spring Data JPA</h2>&emsp;官方网址：<a href="https://spring.io/projects/spring-data-jpa">https://spring.io/projects/spring-data-jpa</a><br><img src="https://img-blog.csdnimg.cn/20200718202404362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></li>
</ul>
<p>&emsp;官方给出的说明中总结几点：</p>
<ol>
<li>Spring Data JPA是开源项目Spring Data中的一员。</li>
<li>可以轻松的实现基于JPA的存储库。</li>
<li>让你Spring项目中操作数据库更简便。</li>
<li>不用再书写太多样板化的代码。</li>
<li>可以基于一定规则给你自动提供实现。<h1 id="三、JPA、Hibernate、Spring-Data-JPA三者之间的关系"><a href="#三、JPA、Hibernate、Spring-Data-JPA三者之间的关系" class="headerlink" title="三、JPA、Hibernate、Spring Data JPA三者之间的关系"></a>三、JPA、Hibernate、Spring Data JPA三者之间的关系</h1>&emsp;JPA是一种规范，内部是由接口和抽象类组成的。而Hibernate是一套成熟的ORM框架，且实现了JPA规范，理论上来说也可以成其为JPA的一种实现方式。Spring Data JPA是Spring中提供的一套基于JPA规范封装的更高级的框架，它的基础实现还是使用Hibernate。<h1 id="四、Spring-Data-JPA在Java中的实现"><a href="#四、Spring-Data-JPA在Java中的实现" class="headerlink" title="四、Spring Data JPA在Java中的实现"></a>四、Spring Data JPA在Java中的实现</h1><h2 id="1-1-创建并配置SpringBoot项目"><a href="#1-1-创建并配置SpringBoot项目" class="headerlink" title="1.1 创建并配置SpringBoot项目"></a>1.1 创建并配置SpringBoot项目</h2>本例直接在官网上创建和下载，创建SpringBoot项目可以参考《<a href="https://blog.csdn.net/qq_37171817/article/details/107413296">从零到一搭建一个SpringBoot2.0项目</a>》</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200718205126450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;查看mysql-connector-java版本，如果用的6.0以上，数据库驱动类就要用com.mysql.cj.jdbc.Driver而不是com.mysql.jdbc.Driver，并且给数据库连接就爱上serverTimezone参数，否则就会报错。</p>
<p><img src="https://img-blog.csdnimg.cn/20200718210759613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;mysql配置名称在SpringBoot2.x和1.x之间还有区别，所以配置的时候先看org.springframework.boot.autoconfigure.jdbc.DataSourceProperties类：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718211941142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;根据名称来对应，比如驱动类的配置就需要spring.datasource.driverClassName。</p>
<p>&emsp;mysql连接配置（在application.properties中配置）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># mysql连接配置</span><br><span class="hljs-string">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="hljs-string">spring.datasource.url=jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;nullCatalogMeansCurrent=true&amp;serverTimezone=GMT</span><br><span class="hljs-string">spring.datasource.username=root</span><br><span class="hljs-string">spring.datasource.password=root</span><br></code></pre></td></tr></table></figure>
<p>&emsp;同样JPA的配置名称也可以在JpaProperties中找，完整路径：org.springframework.boot.autoconfigure.orm.jpa.JpaProperties</p>
<p><img src="https://img-blog.csdnimg.cn/20200718212240208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;jpa配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Spring Data JPA配置</span><br><span class="hljs-string">spring.jpa.show-sql=true</span><br><span class="hljs-string">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="hljs-string">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br></code></pre></td></tr></table></figure>
<p>&emsp;hbm2ddl.auto的四种选项：</p>
<ul>
<li>create<br>每次运行该程序，没有表格会新建表格，表内有数据会清空；</li>
<li>create-drop<br>每次程序结束的时候会清空表；</li>
<li>update<br>每次运行程序，没有表格会新建表格，表内有数据不会清空，只会更新；</li>
<li>validate<br>运行程序会校验数据与数据库的字段类型是否相同，不同会报错；</li>
</ul>
<p>&emsp;完整配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-string">server.port=8080</span><br><br><span class="hljs-comment"># mysql连接配置</span><br><span class="hljs-string">spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver</span><br><span class="hljs-string">spring.datasource.url=jdbc:mysql://localhost:3306/demo?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;nullCatalogMeansCurrent=true&amp;serverTimezone=GMT</span><br><span class="hljs-string">spring.datasource.username=root</span><br><span class="hljs-string">spring.datasource.password=root</span><br><br><span class="hljs-comment"># Spring Data JPA配置</span><br><span class="hljs-string">spring.jpa.show-sql=true</span><br><span class="hljs-string">spring.jpa.properties.hibernate.hbm2ddl.auto=update</span><br><span class="hljs-string">spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect</span><br></code></pre></td></tr></table></figure>
<h2 id="1-2-简单接口调用"><a href="#1-2-简单接口调用" class="headerlink" title="1.2 简单接口调用"></a>1.2 简单接口调用</h2><p>&emsp;项目结构：<br><img src="https://img-blog.csdnimg.cn/20200718220958211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;新建<strong>学生</strong>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.entity;<br><br><span class="hljs-keyword">import</span> javax.persistence.Column;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-keyword">import</span> org.hibernate.annotations.GenericGenerator;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;student&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Id</span><br>	<span class="hljs-meta">@GenericGenerator(name = &quot;uuidGenerator&quot;, strategy = &quot;uuid&quot;)</span><br>	<span class="hljs-meta">@GeneratedValue(generator = &quot;uuidGenerator&quot;)</span><br>	<span class="hljs-keyword">private</span> String id;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> String name;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> Integer age;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>@Entity<br>表示其是ORM实体;</li>
<li>@Table(name = “student”)<br>表示对应表的名称为student；</li>
<li>@Id<br>表示本字段为主键；</li>
<li>@GenericGenerator(name = “uuidGenerator”, strategy = “uuid”)<br>表示主键生成器，命名为uuidGenerator，策略为uuid；</li>
<li>@GeneratedValue(generator = “uuidGenerator”)<br>自动生成值，生成规则为上面定义的名称；</li>
<li>@column<br>表示是表中的一个字段，名称会根据驼峰自动映射。如果该实体中某字段不需要称为表中一个字段，需要在字段上加@Transient注解。<br><img src="https://img-blog.csdnimg.cn/20200718220235782.png"></li>
</ul>
<p>&emsp;这种形式表示主键自动递增。</p>
<p>&emsp;数据访问层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.dao;<br><br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-keyword">import</span> com.yl.jpa.entity.Student;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">Student</span>, <span class="hljs-title">String</span>&gt; </span>&#123;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;需要加上@Repository注解，继承JpaRepository，Studnet为其实体类，String为主键类型。</p>
<p>&emsp;继承类之后，就可以调用默认方法了，如：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718220704568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;业务层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.service.impl;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> com.yl.jpa.dao.StudentDao;<br><span class="hljs-keyword">import</span> com.yl.jpa.entity.Student;<br><span class="hljs-keyword">import</span> com.yl.jpa.service.IStudentService;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IStudentService</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-keyword">private</span> StudentDao studentDao;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>		studentDao.save(student);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;业务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.service;<br><br><span class="hljs-keyword">import</span> com.yl.jpa.entity.Student;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IStudentService</span> </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Student student)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;控制层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> com.yl.jpa.entity.Student;<br><span class="hljs-keyword">import</span> com.yl.jpa.service.IStudentService;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/student&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentController</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-keyword">private</span> IStudentService studentService;<br>	<br>	<span class="hljs-meta">@PostMapping(&quot;/save&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doSave</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Student student)</span> </span>&#123;<br>		studentService.save(student);<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>&emsp;启动项目，项目启动成功后，可以看到自动运行了创建表语句：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718221343257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200718221315401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;使用postman进行接口测试：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718221443470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;控制台中打印insert语句：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718221505899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>&emsp;查看新增的记录：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718221542222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="1-3-查询"><a href="#1-3-查询" class="headerlink" title="1.3 查询"></a>1.3 查询</h2><h3 id="1-3-1-名称匹配查询"><a href="#1-3-1-名称匹配查询" class="headerlink" title="1.3.1 名称匹配查询"></a>1.3.1 名称匹配查询</h3><p>&emsp;在Spring Data JPA中，只要你根据规则写了repository方法，就不用自己写sql语句，JPA会自动生成对应的sql语句。<br>| 关键词           | 示例                          | 生成语句                          |<br>| —————- | —————————– | ——————————— |<br>| And              | findByNameAndAge              | where name = ?1 and age = ?2      |<br>| Or               | findByNameOrAge               | where name = ?1 or age = ?2       |<br>| Is,Equals        | findByNameIs,findByNameEquals | where name = ?1                   |<br>| Between          | findByAgeBetween              | where age between ?1 and ?2       |<br>| LessThan         | findByAgeLessThan             | where age &lt; ?1                    |<br>| LessThanEqual    | findByAgeLessThanEqual        | where age &lt;= ?1                   |<br>| GreaterThan      | findByAgeGreaterThan          | where age &gt; ?1                    |<br>| GreaterThanEqual | findByAgeGreaterThanEqual     | where age &gt;= ?1                   |<br>| After            | findByCreateDateAfter         | where create_date &gt; ?1            |<br>| Before           | findByCreateDateBefore        | where create_date &lt; ?1            |<br>| IsNull           | findByAgeIsNull               | where age is null                 |<br>| IsNotNull        | findByAgeIsNotNull            | where age is not null             |<br>| Like             | findByNameLike                | where name like %?1%              |<br>| NotLike          | findByNameNotLike             | where name not like %?1%          |<br>| OrderBy          | findByNameOrderByAgeDesc      | where name = ?1 order by age desc |<br>| In               | findByNameIn                  | where name in (?1)                |<br>| NotIn            | findByNameNotIn               | where name not in (?1)            |<br>| …              |                               |                                   |</p>
<h3 id="1-3-2-限制查询"><a href="#1-3-2-限制查询" class="headerlink" title="1.3.2 限制查询"></a>1.3.2 限制查询</h3><table>
<thead>
<tr>
<th>关键词</th>
<th>示例</th>
<th>生成语句</th>
</tr>
</thead>
<tbody><tr>
<td>Top10</td>
<td>findTop10ByName</td>
<td>where name = ?1 limit 10</td>
</tr>
<tr>
<td>First</td>
<td>findFirstByName</td>
<td>where name =? limit 1</td>
</tr>
</tbody></table>
<h3 id="1-3-3-自定义查询"><a href="#1-3-3-自定义查询" class="headerlink" title="1.3.3 自定义查询"></a>1.3.3 自定义查询</h3><p>&emsp;使用@Query可以实现自定义查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Query(&quot;select s from Student s where name = :name&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">queryByName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span></span>;<br><br><span class="hljs-meta">@Query(&quot;select s from Student s where name = ?1&quot;)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">queryByName2</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;name&quot;)</span> String name)</span></span>;<br><br><span class="hljs-meta">@Query(value = &quot;select * from student where age = ?1&quot;, nativeQuery = true)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">queryByAge</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;age&quot;)</span> Integer age)</span></span>;<br><br><span class="hljs-meta">@Query(value = &quot;select * from student where age = :age&quot;, nativeQuery = true)</span><br><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">queryByAge2</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;age&quot;)</span> Integer age)</span></span>;<br></code></pre></td></tr></table></figure>
<p>&emsp;这四种方式都可以实现查询，但是需要注意，nativeQuery=true表示是原生sql查询，不能写入java实体，比如Student 。</p>
<h3 id="1-3-4-分页查询"><a href="#1-3-4-分页查询" class="headerlink" title="1.3.4 分页查询"></a>1.3.4 分页查询</h3><p>&emsp;可以使用PageRequest封装页码分页大小，排序数据，并传入findAll方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Page&lt;Student&gt; <span class="hljs-title">findPage</span><span class="hljs-params">(PageRequest pageRequest)</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> studentDao.findAll(pageRequest);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;page&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Page&lt;Student&gt; <span class="hljs-title">doGetPage</span><span class="hljs-params">(HttpServletRequest request)</span></span>&#123;<br>	Integer no = Integer.valueOf(request.getParameter(<span class="hljs-string">&quot;no&quot;</span>));<br>	Integer size = Integer.valueOf(request.getParameter(<span class="hljs-string">&quot;size&quot;</span>));<br>	Sort sort = Sort.by(Direction.DESC, <span class="hljs-string">&quot;age&quot;</span>);<br>	<span class="hljs-keyword">return</span> studentService.findPage(PageRequest.of(no, size, sort));<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-4-修改删除"><a href="#1-4-修改删除" class="headerlink" title="1.4 修改删除"></a>1.4 修改删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Modifying</span><br><span class="hljs-meta">@Query(&quot;delete from Student where name = ?1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteByName</span><span class="hljs-params">(String name)</span></span>;<br></code></pre></td></tr></table></figure>
<p>&emsp;需要在方法上添加@Modifying注解，且在调用方法内加@Transactional注解，否则报错。</p>
<h2 id="1-5-关联操作"><a href="#1-5-关联操作" class="headerlink" title="1.5 关联操作"></a>1.5 关联操作</h2><h3 id="1-5-1-多对多"><a href="#1-5-1-多对多" class="headerlink" title="1.5.1 多对多"></a>1.5.1 多对多</h3><p>&emsp;修改<strong>学生</strong>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.entity;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> javax.persistence.CascadeType;<br><span class="hljs-keyword">import</span> javax.persistence.Column;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.FetchType;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.JoinColumn;<br><span class="hljs-keyword">import</span> javax.persistence.JoinTable;<br><span class="hljs-keyword">import</span> javax.persistence.ManyToMany;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-keyword">import</span> org.hibernate.annotations.GenericGenerator;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;student&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Id</span><br>	<span class="hljs-meta">@GenericGenerator(name = &quot;uuidGenerator&quot;, strategy = &quot;uuid&quot;)</span><br>	<span class="hljs-meta">@GeneratedValue(generator = &quot;uuidGenerator&quot;)</span><br>	<span class="hljs-keyword">private</span> String id;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> String name;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> Integer age;<br>	<br>	<span class="hljs-meta">@ManyToMany(targetEntity = Course.class, cascade = CascadeType.ALL, fetch = FetchType.LAZY)</span><br>    <span class="hljs-meta">@JoinTable(name = &quot;student_course&quot;, joinColumns = &#123;@JoinColumn(name = &quot;student_id&quot;, referencedColumnName = &quot;id&quot;)&#125;,</span><br><span class="hljs-meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;course_id&quot;, referencedColumnName = &quot;id&quot;)&#125;)</span><br>	<span class="hljs-keyword">private</span> List&lt;Course&gt; courseList;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123; <br>		<span class="hljs-keyword">return</span> id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Course&gt; <span class="hljs-title">getCourseList</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> courseList;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCourseList</span><span class="hljs-params">(List&lt;Course&gt; courseList)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.courseList = courseList;<br>	&#125;<br>	<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>&emsp;新建<strong>课程</strong>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.entity;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> javax.persistence.Column;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.FetchType;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.JoinColumn;<br><span class="hljs-keyword">import</span> javax.persistence.JoinTable;<br><span class="hljs-keyword">import</span> javax.persistence.ManyToMany;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-keyword">import</span> org.hibernate.annotations.GenericGenerator;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;course&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Course</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Id</span><br>	<span class="hljs-meta">@GenericGenerator(name = &quot;uuidGenerator&quot;, strategy = &quot;uuid&quot;)</span><br>	<span class="hljs-meta">@GeneratedValue(generator = &quot;uuidGenerator&quot;)</span><br>	<span class="hljs-keyword">private</span> String id;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> String courseName;<br>	<br>	<span class="hljs-meta">@ManyToMany(targetEntity = Student.class, fetch = FetchType.LAZY)</span><br>    <span class="hljs-meta">@JoinTable(name = &quot;student_course&quot;, joinColumns = &#123;@JoinColumn(name = &quot;course_id&quot;, referencedColumnName = &quot;id&quot;)&#125;,</span><br><span class="hljs-meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;student_id&quot;, referencedColumnName = &quot;id&quot;)&#125;)</span><br>	<span class="hljs-keyword">private</span> List&lt;Student&gt; studentList;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCourseName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> courseName;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCourseName</span><span class="hljs-params">(String courseName)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.courseName = courseName;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;学生和课程是多对多，所以需要设置@ManyToMany。</p>
<p>&emsp;joinColumns表示当前对象的配置，其中course_id为表student_course中的字段，对应着本对象中的id值。</p>
<p>&emsp;inverseJoinColumns表示对方对象的配置，其中student_id为表student_course中的字段，对应着对方对象中的id值。<br>重启项目，会发现自动创建了student_course表：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718235712645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>&emsp;保存学生实体：</p>
<p><img src="https://img-blog.csdnimg.cn/20200719000121793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;其中的课程以及关联表也会新增：</p>
<p><img src="https://img-blog.csdnimg.cn/20200719000154831.png"><br><img src="https://img-blog.csdnimg.cn/20200719000208242.png"><br><img src="https://img-blog.csdnimg.cn/20200719000218539.png"><br>&emsp;查询学生实体：</p>
<p><img src="https://img-blog.csdnimg.cn/20200719000455963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>&emsp;关联信息也被查询出来。</p>
<h3 id="1-5-2-一对多"><a href="#1-5-2-一对多" class="headerlink" title="1.5.2 一对多"></a>1.5.2 一对多</h3><p>&emsp;新建Address类，学生对地址是一对多的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.entity;<br><br><span class="hljs-keyword">import</span> javax.persistence.CascadeType;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.JoinColumn;<br><span class="hljs-keyword">import</span> javax.persistence.ManyToOne;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-keyword">import</span> org.hibernate.annotations.GenericGenerator;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;address&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Id</span><br>	<span class="hljs-meta">@GenericGenerator(name = &quot;uuidGenerator&quot;, strategy = &quot;uuid&quot;)</span><br>	<span class="hljs-meta">@GeneratedValue(generator = &quot;uuidGenerator&quot;)</span><br>	<span class="hljs-keyword">private</span> String id;<br>	<br>	<span class="hljs-keyword">private</span> String address;<br>	<br>	<span class="hljs-meta">@ManyToOne(cascade = CascadeType.ALL)</span><br>	<span class="hljs-meta">@JoinColumn(name = &quot;student_id&quot;)</span><br>	<span class="hljs-keyword">private</span> Student student;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getStudent</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> student;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.student = student;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> address;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.address = address;<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>@JoinColumn(name = “student_id”)</p>
<p>表示在Address表中增加一列，列名叫做student_id，关联student的id。</p>
<h3 id="1-5-3-多对一"><a href="#1-5-3-多对一" class="headerlink" title="1.5.3 多对一"></a>1.5.3 多对一</h3><p>&emsp;地址对学生是多对一的关系，所以修改Student类：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.jpa.entity;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> javax.persistence.CascadeType;<br><span class="hljs-keyword">import</span> javax.persistence.Column;<br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.FetchType;<br><span class="hljs-keyword">import</span> javax.persistence.GeneratedValue;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.JoinColumn;<br><span class="hljs-keyword">import</span> javax.persistence.JoinTable;<br><span class="hljs-keyword">import</span> javax.persistence.ManyToMany;<br><span class="hljs-keyword">import</span> javax.persistence.OneToMany;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-keyword">import</span> org.hibernate.annotations.GenericGenerator;<br><br><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;student&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Id</span><br>	<span class="hljs-meta">@GenericGenerator(name = &quot;uuidGenerator&quot;, strategy = &quot;uuid&quot;)</span><br>	<span class="hljs-meta">@GeneratedValue(generator = &quot;uuidGenerator&quot;)</span><br>	<span class="hljs-keyword">private</span> String id;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> String name;<br>	<br>	<span class="hljs-meta">@Column</span><br>	<span class="hljs-keyword">private</span> Integer age;<br>	<br>	<span class="hljs-meta">@ManyToMany(targetEntity = Course.class, cascade = CascadeType.ALL, fetch = FetchType.LAZY)</span><br>    <span class="hljs-meta">@JoinTable(name = &quot;student_course&quot;, joinColumns = &#123;@JoinColumn(name = &quot;student_id&quot;, referencedColumnName = &quot;id&quot;)&#125;,</span><br><span class="hljs-meta">            inverseJoinColumns = &#123;@JoinColumn(name = &quot;course_id&quot;, referencedColumnName = &quot;id&quot;)&#125;)</span><br>	<span class="hljs-keyword">private</span> List&lt;Course&gt; courseList;<br>	<br>	<span class="hljs-meta">@OneToMany(mappedBy = &quot;student&quot;)</span><br>	<span class="hljs-keyword">private</span> List&lt;Address&gt; addressList;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123; <br>		<span class="hljs-keyword">return</span> id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.id = id;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.name = name;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.age = age;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Course&gt; <span class="hljs-title">getCourseList</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> courseList;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCourseList</span><span class="hljs-params">(List&lt;Course&gt; courseList)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.courseList = courseList;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Address&gt; <span class="hljs-title">getAddressList</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> addressList;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddressList</span><span class="hljs-params">(List&lt;Address&gt; addressList)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.addressList = addressList;<br>	&#125;<br>	<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li><p>@OneToMany(mappedBy = “student”)</p>
<p>表示关系由student方维护。</p>
<h2 id="1-6-对象状态"><a href="#1-6-对象状态" class="headerlink" title="1.6 对象状态"></a>1.6 对象状态</h2><p>&emsp;Spring Data JPA中对象的状态如下：</p>
</li>
<li><p>瞬时状态（new/transient）：没有主键，不与持久化上下文关联，即 new 出的对象（但不能指定id的值，若指定则是游离态而非瞬时态）</p>
</li>
<li><p>托管状态（persistent）：使用EntityManager进行find或者persist操作返回的对象即处于托管状态，此时该对象已经处于持久化上下文中（被EntityManager监控），任何对该实体的修改都会在提交事务时同步到数据库中。</p>
</li>
<li><p>游离状态（detached）：有主键，但是没有跟持久化上下文关联的实体对象。</p>
</li>
<li><p>删除状态 （deleted）：当调用EntityManger对实体进行remove后，该实体对象就处于删除状态。其本质也就是一个瞬时状态的对象。<br><img src="https://img-blog.csdnimg.cn/20200719005959685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
</li>
</ul>
<p>&emsp;需要注意的是，在一个事务方法中，即使你是在调用save方法之后对实体重新赋值，那么新赋的值也会被修改到数据库里。因为此时是在一个事务中，且对象还是托管状态。<br>如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>	studentDao.save(student);<br>	student.setAge(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>&emsp;save之后对age赋值。使用postman测试：</p>
<p><img src="https://img-blog.csdnimg.cn/20200719004018240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200719004031358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>&emsp;得出的结果是100，这显然不是我们预期的结果。</p>
<p>&emsp;我们可以用BeanUtils.copyProperties克隆一份对象进行操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>	studentDao.saveAndFlush(student);<br>	<br>	Student student2 = <span class="hljs-keyword">new</span> Student();<br>	BeanUtils.copyProperties(student, student2);<br>	student2.setAge(<span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JPA</category>
      </categories>
      <tags>
        <tag>JPA</tag>
        <tag>持久化</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂ThreadLocal原理</title>
    <url>/2020/12/15/%E6%90%9E%E6%87%82ThreadLocal%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、关于"><a href="#一、关于" class="headerlink" title="一、关于"></a>一、关于</h1><p>ThreadLocal不是一个线程，而是一个线程的本地化对象，当某个变量在使用ThreadLocal维护时，它会在每个线程中创建独立的一个副本，不同线程中对这个变量的修改不会影响到其他线程中这个变量的值。</p>
<p>ThreadLocal采用了空间换时间的思想，主要用来实现多线程环境下线程安全和保存线程上下文中的变量。</p>
<p>可以笼统的理解它为线程范围下的全局变量存储对象。</p>
<h1 id="二、API"><a href="#二、API" class="headerlink" title="二、API"></a>二、API</h1><ul>
<li><p>public void set(T value) {}</p>
<p>将T类型的值设置到ThreadLocal中</p>
</li>
<li><p>public T get() {}</p>
<p>获取ThreadLocal对象的值</p>
</li>
<li><p>public void remove() {}</p>
<p>移除ThreadLocal中的值</p>
<h1 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h1><h2 id="1-1set方法"><a href="#1-1set方法" class="headerlink" title="1.1set方法"></a>1.1set方法</h2></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);<br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>首先获取到当前线程。</li>
<li>根据getMap方法根据当前线程获取到ThreadLocalMap 。我们看一下getMap方法：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>直接返回的是t.threadLocals，threadLocals是Thread类的一个参数，类型是ThreadLocal中的内部类ThreadLocalMap，初始值为null。</p>
<p><img src="https://img-blog.csdnimg.cn/202007181358099.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>再看ThreadLocal类结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            Object value;<br><br>            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>                <span class="hljs-keyword">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>        ...............<br>        <span class="hljs-keyword">private</span> Entry[] table;<br>        ...............<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其内部维护了一个Entry数组，且注意Entry类是继承自WeakReference，弱引用对象，所以需要注意<strong>jvm回收</strong>引发的问题。</p>
<ol start="3">
<li>回到set方法</li>
</ol>
<ul>
<li>如果获取出来的map不为空，就将当前ThreadLocal对象和value值放进去。</li>
<li>如果map为空，就创建map</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    t.threadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="1-2get方法"><a href="#1-2get方法" class="headerlink" title="1.2get方法"></a>1.2get方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);<br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>) &#123;<br>        ThreadLocalMap.Entry e = map.getEntry(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            T result = (T)e.value;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> setInitialValue();<br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>获取当前线程。</li>
<li>获取当前线程的所有ThreadLocal对象（ThradLocalMap）。</li>
<li>如果map不为空，就根据ThreadLocal对象获取到存储在其中的值。</li>
<li>如果map为空，则初始化将当前ThreadLocal对象中的值设为null，并放入ThreadLocalMap。<h2 id="1-3remove方法"><a href="#1-3remove方法" class="headerlink" title="1.3remove方法"></a>1.3remove方法</h2></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>    ThreadLocalMap m = getMap(Thread.currentThread());<br>    <span class="hljs-keyword">if</span> (m != <span class="hljs-keyword">null</span>)<br>        m.remove(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>获取当前线程的所有ThreadLocal对象，并将当前对象从ThreadLocalMap 中移除。</p>
<p>这里需要着重注意，不然会引起jvm内存泄漏！</p>
<p>上面说到了Entry是继承WeakReference的对象就是弱引用对象，而调用构造方法时，也说明了Entry的key是指向当前ThreadLocal的弱引用对象。</p>
<p><img src="https://img-blog.csdnimg.cn/20200718143541533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200718143610192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
<p>如果Entry的key被回收了，那么其对应的值就不会被remove掉了。所以在使用完之后需要手动remove()。</p>
<h1 id="四、使用示例"><a href="#四、使用示例" class="headerlink" title="四、使用示例"></a>四、使用示例</h1><p>这里我们来模拟将用户登录信息存放到ThreadLocal中，项目为SpringBoot项目，结构为：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718144235328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>缓存工具类CacheUtil，此类用于提供对ThreadLocal增删查。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.demo.util;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheUtil</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; store = <span class="hljs-keyword">new</span> ThreadLocal&lt;String&gt;();<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getStore</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> store.get();<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStore</span><span class="hljs-params">(String value)</span> </span>&#123;<br>		store.set(value);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>		store.remove();<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>拦截器TestInterceptor，拦截所有请求，在进入控制器之前，在ThreadLocal中设置信息，在执行完控制器的方法后，移除ThreadLocal中的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.demo.interceptor;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> org.springframework.web.servlet.HandlerInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.ModelAndView;<br><br><span class="hljs-keyword">import</span> com.yl.demo.util.CacheUtil;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span></span>&#123;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		System.out.println(Thread.currentThread().getName());<br>		CacheUtil.setStore(<span class="hljs-string">&quot;这里面是用户登录信息&quot;</span>);<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span><br><span class="hljs-function"><span class="hljs-params">			ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		HandlerInterceptor.<span class="hljs-keyword">super</span>.postHandle(request, response, handler, modelAndView);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> Exception </span>&#123;<br>		CacheUtil.remove();<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>mvc配置类，让拦截器拦截所有路径。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.demo.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-keyword">import</span> com.yl.demo.interceptor.TestInterceptor;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>	<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> TestInterceptor <span class="hljs-title">testInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TestInterceptor();<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>		registry.addInterceptor(testInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>	&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>测试Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.demo.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> com.yl.demo.util.CacheUtil;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>	<span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doGet</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;-get : &quot;</span> + CacheUtil.getStore();<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>运行项目，在浏览器测试：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718144900708.png"><br><img src="https://img-blog.csdnimg.cn/20200718144917416.png"><br>可以看到，同一线程下都可以获取到ThreadLocal中的值。</p>
<h1 id="五、子线程获取父线程中ThreadLocal的值"><a href="#五、子线程获取父线程中ThreadLocal的值" class="headerlink" title="五、子线程获取父线程中ThreadLocal的值"></a>五、子线程获取父线程中ThreadLocal的值</h1><p>我们这里改造一下接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.demo.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> com.yl.demo.util.CacheUtil;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br><br>	<span class="hljs-meta">@GetMapping(&quot;/get&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doGet</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 新起一个线程获取值</span><br>		<span class="hljs-keyword">new</span> Thread(()-&gt; &#123;<br>			System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;-get : &quot;</span> + CacheUtil.getStore());<br>		&#125;).start();<br>		<span class="hljs-keyword">return</span> Thread.currentThread().getName()+<span class="hljs-string">&quot;-get : &quot;</span> + CacheUtil.getStore();<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>new Thread(()-&gt; {}).start()这种写法是java8中的写法，如果jdk低于1.8，就会报错，那么可以根据自己的实际情况来写，这里实现的就是新启动一个线程来获取存储在ThreadLocal中的值，看能否取到。</p>
<p><img src="https://img-blog.csdnimg.cn/20200718145533263.png"><br><img src="https://img-blog.csdnimg.cn/20200718145551253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>我们可以看到，新线程为什么取到的是null呢?</p>
<p>因为ThreadLocal是线程本地变量，设置值的时候是http-nio-8080-exec-1这个线程设置的，对其他线程没有影响，所以Thread-103-get线程是取不到值的。</p>
<p>在这个方法中，线程Thread-103-get就是线程http-nio-8080-exec-1的子线程。</p>
<p>那么我们如果想在子线程中获取父线程的ThreadLocal值，应该怎样去做呢？</p>
<p>只需要改变一个地方，那就是将ThreadLocal替换成InheritableThreadLocal：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718150134287.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>重启项目，测试：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718150224473.png"><br><img src="https://img-blog.csdnimg.cn/20200718150241703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>子线程中可以获取到父线程中ThreadLocal的值了！</p>
<h1 id="六、InheritableThreadLocal"><a href="#六、InheritableThreadLocal" class="headerlink" title="六、InheritableThreadLocal"></a>六、InheritableThreadLocal</h1><p><img src="https://img-blog.csdnimg.cn/20200718150454364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>InheritableThreadLocal是ThreadLocal的子类。</p>
<p>那么值究竟是从哪里获取出来的呢？</p>
<p>首先看一下InheritableThreadLocal类中相对于ThreadLocal的改动：</p>
<ul>
<li>重写了getMap方法：<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> t.inheritableThreadLocals;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>重写了createMap方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createMap</span><span class="hljs-params">(Thread t, T firstValue)</span> </span>&#123;<br>    t.inheritableThreadLocals = <span class="hljs-keyword">new</span> ThreadLocalMap(<span class="hljs-keyword">this</span>, firstValue);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再看一下Thread的创建过程：</p>
<p><img src="https://img-blog.csdnimg.cn/20200718161802957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200718161831361.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>最终init方法(省略版)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="hljs-function"><span class="hljs-params">                      <span class="hljs-keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;<br>		.................<br>        Thread parent = currentThread();<br>       	.................<br>        <span class="hljs-keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">this</span>.inheritableThreadLocals =<br>                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);<br>      	.................<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>此处的currentThread()线程就是上文中的http-nio-8080-exec-1（父）线程。</p>
<p>此时inheritThreadLocals为true，且parent线程的inheritableThreadLocals 不为空的，所以就会将parent的inheritableThreadLocals赋给新创建的线程的inheritableThreadLocals ，也就是上文中的Thread-103-get（子）线程。所以子线程中就有了父线程中所有ThreadLocal的值。</p>
]]></content>
      <categories>
        <category>线程</category>
      </categories>
      <tags>
        <tag>ThreadLocal</tag>
        <tag>线程本地变量</tag>
      </tags>
  </entry>
  <entry>
    <title>如何搭建一个SpringBoot2.0项目</title>
    <url>/2020/12/15/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AASpringBoot2%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h1 id="一、SpringBoot"><a href="#一、SpringBoot" class="headerlink" title="一、SpringBoot"></a>一、SpringBoot</h1><p><img src="https://img-blog.csdnimg.cn/20200717172720453.png"><br>&emsp;SpringBoot是由Pivotal团队在2013年开始研发、2014年4月发布第一个版本的全新开源的轻量级框架。它基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决。</p>
<p>&emsp;<strong>SpringBoot所具备的特征有</strong>：</p>
<ol>
<li>可以创建独立的Spring应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；</li>
<li>内嵌Tomcat或Jetty等Servlet容器；</li>
<li>提供自动配置的“starter”项目对象模型（POMS）以简化Maven配置；</li>
<li>尽可能自动配置Spring容器；</li>
<li>提供准备好的特性，如指标、健康检查和外部化配置；</li>
<li>绝对没有代码生成，不需要XML配置。<h1 id="二、创建项目"><a href="#二、创建项目" class="headerlink" title="二、创建项目"></a>二、创建项目</h1><h2 id="1-1从官网创建"><a href="#1-1从官网创建" class="headerlink" title="1.1从官网创建"></a>1.1从官网创建</h2>可以在官网（<a href="https://start.spring.io/">https://start.spring.io/</a>）填写配置信息，然后直接新建项目，并下载到本地，导入编辑器中。</li>
</ol>
<p>点击ADD DEPENDENCES，输入Spring Web，并选择：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717180104681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200717180225766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>信息填写好后点击生成，就可以下载项目。</p>
<p>将项目导入编辑器：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717173929114.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="1-2根据maven创建"><a href="#1-2根据maven创建" class="headerlink" title="1.2根据maven创建"></a>1.2根据maven创建</h2><p>本例中编辑器为eclipse，请点击顶部菜单栏File-&gt;New-&gt;Maven Project<br><img  src="https://img-blog.csdnimg.cn/20200717174220303.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_10,color_FFFFFF,t_70"   style="zoom:67%;" /><span class="image-caption">在这里插入图片描述</span><br><img src="https://img-blog.csdnimg.cn/202007171743598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_10,color_FFFFFF,t_70" style="zoom:67%;" /></p>
<p>填入必要信息，点击Finish。</p>
<p>在pom.xml中添加内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;parent&gt;<br>&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;<br>&lt;version&gt;2.3.1.RELEASE&lt;&#x2F;version&gt;<br>&lt;relativePath &#x2F;&gt; &lt;!-- lookup parent from repository --&gt;<br>&lt;&#x2F;parent&gt;<br>&lt;properties&gt;<br>   &lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;<br> &lt;&#x2F;properties&gt;<br> &lt;dependencies&gt;<br>   &lt;dependency&gt;<br>     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>     &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;<br>   &lt;&#x2F;dependency&gt;<br>   &lt;dependency&gt;<br>     &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>     &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;<br>     &lt;scope&gt;test&lt;&#x2F;scope&gt;<br>     &lt;exclusions&gt;<br>       &lt;exclusion&gt;<br>         &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;<br>         &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;<br>       &lt;&#x2F;exclusion&gt;<br>     &lt;&#x2F;exclusions&gt;<br>   &lt;&#x2F;dependency&gt;<br> &lt;&#x2F;dependencies&gt;<br> &lt;build&gt;<br>   &lt;plugins&gt;<br>     &lt;plugin&gt;<br>       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;<br>       &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;<br>     &lt;&#x2F;plugin&gt;<br>   &lt;&#x2F;plugins&gt;<br> &lt;&#x2F;build&gt;<br></code></pre></td></tr></table></figure>
<h1 id="三、启动项目"><a href="#三、启动项目" class="headerlink" title="三、启动项目"></a>三、启动项目</h1><p>在application.properties中添加启动端口为8080：</p>
<p><img src="https://img-blog.csdnimg.cn/20200717174859107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>右键DemoApplication.java，选择Run As-&gt;Java Application</p>
<p><img src="https://img-blog.csdnimg.cn/20200717180414913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>项目运行成功。</p>
<p><img src="https://img-blog.csdnimg.cn/20200717180454449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>可以看到，容器已经运行成功了，只是没有写匹配的路径而报404。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中如何优雅对null值进行处理</title>
    <url>/2020/12/15/Java%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AF%B9null%E5%80%BC%E8%BF%9B%E8%A1%8C%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、空指针"><a href="#一、空指针" class="headerlink" title="一、空指针"></a>一、空指针</h1><p><img src="https://img-blog.csdnimg.cn/20200716124743446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70#pic_center"></p>
<p>NPE(NullPointerException)一直是让java程序员头疼的问题，稍微不注意被调用就会让功能无法使用。所以项目里面很多地方都需要对对象进行非空判断。</p>
<h1 id="二、非空处理"><a href="#二、非空处理" class="headerlink" title="二、非空处理"></a>二、非空处理</h1><p>那么我们通常是怎样的判空的呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (obj == <span class="hljs-keyword">null</span>) &#123;<br>	<span class="hljs-comment">// do something</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-comment">// do something</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码是不是很常见？如果obj为null，那么就执行一段逻辑，否则执行另外一段逻辑。</p>
<p>由于这样的逻辑会占用很多代码行，也会让代码看起来变得臃肿，所以java官方在java8中优化了相关的链式处理，比如java8中的stream流，而在这里，也有对应的Optional类来处理判空问题。</p>
<p>首先来解读一下Optional类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.util;<br><br><span class="hljs-keyword">import</span> java.util.function.Consumer;<br><span class="hljs-keyword">import</span> java.util.function.Function;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.function.Supplier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Optional</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>   <span class="hljs-comment">// 空的Optional对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Optional&lt;?&gt; EMPTY = <span class="hljs-keyword">new</span> Optional&lt;&gt;();<br><br>    <span class="hljs-comment">// 如果非空，就是value值，如果为空，就没有值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T value;<br><br>	<span class="hljs-comment">// 无参构造，将value初始化为null</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Optional</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>   <span class="hljs-comment">// 获取一个Optional对象，value为null</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T&gt; Optional&lt;T&gt; <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        Optional&lt;T&gt; t = (Optional&lt;T&gt;) EMPTY;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br><br>   <span class="hljs-comment">// 使用构造器生成一个Optional对象，如果value值为null，就抛出空指针异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Optional</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = Objects.requireNonNull(value);<br>    &#125;<br><br>	<span class="hljs-comment">// 使用静态方法获取一个Optional对象，如果value值为null，就抛出空指针异常</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">of</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Optional&lt;&gt;(value);<br>    &#125;<br><br>  	<span class="hljs-comment">// 如果value为null，返回value为null的Optional对象，否则生成一个value为传入value的对象</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">ofNullable</span><span class="hljs-params">(T value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value == <span class="hljs-keyword">null</span> ? empty() : of(value);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前Optional对象的value值，如果value为null，则抛出异常</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">&quot;No value present&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断当前Optional对象value值是否非空，不为null则返回true</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPresent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 对当前Optional对象的value值进行操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ifPresent</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> T&gt; consumer)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>)<br>        	<span class="hljs-comment">// 使用consumer消费者方法</span><br>            consumer.accept(value);<br>        <span class="hljs-comment">// 否则不做任何操作</span><br>    &#125;<br><br>    <span class="hljs-comment">// 根据条件过滤Optional对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;T&gt; <span class="hljs-title">filter</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)</span> </span>&#123;<br>    	 <span class="hljs-comment">// 如果predicate比较方法为null，则抛出空指针异常</span><br>        Objects.requireNonNull(predicate);<br>       	<span class="hljs-comment">// 如果value值为空，则返回当前Optional对象</span><br>        <span class="hljs-keyword">if</span> (!isPresent())<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">else</span><br>        	<span class="hljs-comment">// 如果value有值</span><br>        	<span class="hljs-comment">// 则使用predicate进行比较，如果匹配则返回当前Optional对象</span><br>        	<span class="hljs-comment">// 不匹配则返回一个value为null的Optional对象</span><br>            <span class="hljs-keyword">return</span> predicate.test(value) ? <span class="hljs-keyword">this</span> : empty();<br>    &#125;<br><br>	<span class="hljs-comment">// 将当前Optional对象的value根据mapper函数封装成另外的Optional对象</span><br>	<span class="hljs-comment">// mapper函数入参的类型为value类型的超类型，返回类型为U类型的子类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title">map</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper)</span> </span>&#123;<br>     	<span class="hljs-comment">// 如果mapper函数为null，则抛出空指针异常</span><br>        Objects.requireNonNull(mapper);<br>        <span class="hljs-comment">// 如果value值为空，则返回value为null的Optional对象</span><br>        <span class="hljs-keyword">if</span> (!isPresent())<br>            <span class="hljs-keyword">return</span> empty();<br>        <span class="hljs-keyword">else</span> &#123;<br>        	<span class="hljs-comment">// 如果value有值</span><br>        	<span class="hljs-comment">// 将mapper.apply(value)的返回值等装成一个Optional对象</span><br>            <span class="hljs-keyword">return</span> Optional.ofNullable(mapper.apply(value));<br>        &#125;<br>    &#125;<br><br>  	<span class="hljs-comment">// 将当前Optional对象的value根据mapper函数封装成另外的Optional对象</span><br>	<span class="hljs-comment">// mapper函数入参的类型为value类型的超类型，返回类型为value为U类型的Optional对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>&lt;U&gt; Optional&lt;U&gt; <span class="hljs-title">flatMap</span><span class="hljs-params">(Function&lt;? <span class="hljs-keyword">super</span> T, Optional&lt;U&gt;&gt; mapper)</span> </span>&#123;<br>    	<span class="hljs-comment">// 如果mapper函数为null，则抛出空指针异常</span><br>        Objects.requireNonNull(mapper);<br>        <span class="hljs-comment">// 如果value值为空，则返回value为null的Optional对象</span><br>        <span class="hljs-keyword">if</span> (!isPresent())<br>            <span class="hljs-keyword">return</span> empty();<br>        <span class="hljs-keyword">else</span> &#123;<br>        	<span class="hljs-comment">// 如果value有值</span><br>        	<span class="hljs-comment">// 如果mapper.apply(value)为null，则抛出空指针异常</span><br>        	<span class="hljs-comment">// 返回mapper.apply(value)</span><br>            <span class="hljs-keyword">return</span> Objects.requireNonNull(mapper.apply(value));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果value不为空则返回value，否则返回other</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElse</span><span class="hljs-params">(T other)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> ? value : other;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果value不为空则返回value，否则返回other.get()</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">orElseGet</span><span class="hljs-params">(Supplier&lt;? extends T&gt; other)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span> ? value : other.get();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果value不为空则返回value，否则抛出exceptionSupplier.get()定义的异常</span><br>    <span class="hljs-keyword">public</span> &lt;X extends Throwable&gt; <span class="hljs-function">T <span class="hljs-title">orElseThrow</span><span class="hljs-params">(Supplier&lt;? extends X&gt; exceptionSupplier)</span> <span class="hljs-keyword">throws</span> X </span>&#123;<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> exceptionSupplier.get();<br>        &#125;<br>    &#125;<br><br>   	<span class="hljs-comment">// 比较当前Optional对象与obj是否相等</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == obj) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (!(obj <span class="hljs-keyword">instanceof</span> Optional)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        Optional&lt;?&gt; other = (Optional&lt;?&gt;) obj;<br>        <span class="hljs-keyword">return</span> Objects.equals(value, other.value);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取当前value的hashcode</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Objects.hashCode(value);<br>    &#125;<br><br>    <span class="hljs-comment">// toString</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value != <span class="hljs-keyword">null</span><br>            ? String.format(<span class="hljs-string">&quot;Optional[%s]&quot;</span>, value)<br>            : <span class="hljs-string">&quot;Optional.empty&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>通过解读源代码，相信大家对Optional类有了一定的了解了吧！</p>
<p>那么我们来举几个实例，加深一下印象。</p>
<p>新建一个User实体，来进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户实体</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2020年7月16日 下午1:32:36</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 姓名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 年龄</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name, Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ol>
<li>如果user实例不为空，则打印年龄</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.test;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">null</span>;<br>        Optional&lt;User&gt; userOptional = Optional.ofNullable(user);<br>        userOptional.ifPresent(o -&gt; System.out.println(o.getAge()));<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>此时控制台没有任何输出。</p>
<p>我们来测试一下user有值的情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;han&quot;</span>, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure>
<p>此时：</p>
<p><img src="https://img-blog.csdnimg.cn/20200716134134102.png"></p>
<p>如果想将链式写法运用足，那么上面就可以缩写成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Optional.ofNullable(user).ifPresent(o -&gt; System.out.println(o.getAge()));<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>如果user实例不为空，则获取年龄，如果为空，新建一个实例，并获取年龄，此时获取的年龄为null</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.test;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;han&quot;</span>, <span class="hljs-number">20</span>);<br>        Integer age = Optional.ofNullable(user).orElse(<span class="hljs-keyword">new</span> User()).getAge();<br>        System.out.println(age);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ol start="3">
<li>如果user实例不为空，则获取年龄，如果为空，返回年龄为0</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.test;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">null</span>;<br>        Optional&lt;Integer&gt; map = Optional.ofNullable(user).map(User::getAge);<br>        Integer age = map.orElse(<span class="hljs-number">0</span>);<br>        System.out.println(age);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="4">
<li>判断对象是否有值</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.test;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">boolean</span> present = Optional.ofNullable(user).isPresent();<br>        System.out.println(present);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200716135125666.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx基础知识点</title>
    <url>/2020/12/15/Nginx%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="一、关于nginx"><a href="#一、关于nginx" class="headerlink" title="一、关于nginx"></a>一、关于nginx</h1><p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/nginx.jpg"></p>
<p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。<br>主要用途（包含但不仅限于）：</p>
<ul>
<li>Http静态资源服务器<br>  存储静态资源，如图片文件等。</li>
<li>负载均衡<br>  如果一台服务器不能承受并发访问压力时，我们可以新增一个服务，其中用nginx可以实现一个入口访问，然后根据nginx的分发策略将全部访问请求分发到不同的服务器上，分散访问压力，使得服务正常运行。</li>
<li>反向代理<br>  隐藏后端资源服务器信息，与正向代理相反。流程就是客户端发起请求到nginx，nginx经过查询配置，获取到后端真正服务器地址，请求后端服务，然后返回数据给客户端。<h1 id="二、反向代理"><a href="#二、反向代理" class="headerlink" title="二、反向代理"></a>二、反向代理</h1>那么怎样用nginx来实现一个反向代理服务器呢？</li>
</ul>
<p>首先启动一个tomcat服务器，用它来模拟后台服务。</p>
<p>配置文件为conf/server.xml。</p>
<p><img src="https://img-blog.csdnimg.cn/20200715132321169.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200715132544634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>我们不想让外界知道后台服务的地址，那么我们就需要配置nginx方向代理。</p>
<p>配置文件为conf/nginx.conf</p>
<p>删除默认的server配置：</p>
<img src="https://img-blog.csdnimg.cn/2020071513305142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>添加新的server配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">server &#123;<br>	listen       80;<br>       server_name  localhost;<br>	location &#x2F; &#123;<br>           proxy_pass http:&#x2F;&#x2F;localhost:8080;<br>           proxy_set_header Host $host:$server_port;<br>       &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200715133841645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>此配置意为监听localhost:80/，并将这上面的所有请求代理到localhost:8080服务。</p>
<p>启动nginx:</p>
<p>点击双击nginx.exe，黑窗口一闪而过</p>
<p><img src="https://img-blog.csdnimg.cn/20200715133343442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>那怎样查看是否启动成功呢？</p>
<p>打开任务管理器查看是否有两个nginx进程：</p>
<img src="https://img-blog.csdnimg.cn/20200715133935851.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>其中一个是nginx的守护进程。</p>
<p>当然也可以通过命令行来查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">tasklist | findstr nginx<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200715134050136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>特别需要注意的是，nginx的位置不能是中文文件夹下否则会报错。</p>
<p>错误日志可以在logs/error.log中查看：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715134220586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>浏览器访问80端口：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715134442597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>成功实现反向代理。</p>
<h1 id="三、负载均衡"><a href="#三、负载均衡" class="headerlink" title="三、负载均衡"></a>三、负载均衡</h1><p>nginx中，有多种负载均衡策略</p>
<ul>
<li><p>轮询<br>  在服务列表中根据时间将请求依次分配到服务器。</p>
</li>
<li><p>权重<br>  根据重要程度分配，权重值越大，转发到这台服务器的请求就会越多。</p>
</li>
<li><p>IP Hash<br>  根据客户端的ip进行hash算法，使得某ip访问的一直是固定的某台服务器，这样可以解决session的问题。</p>
</li>
<li><p>Url Hash<br>  需要安装第三方模块，根据url进行hash算法，使得某url对应的一直是固定的某台服务器。</p>
</li>
<li><p>Fair<br>  需要安装第三方模块，按照后端服务响应时间来分配，响应时间短的优先分配。</p>
<p>  我们主要来介绍一下轮询、权重、IP Hash这三种nginx自身能做的策略。</p>
<h2 id="1-1启动两个tomcat服务"><a href="#1-1启动两个tomcat服务" class="headerlink" title="1.1启动两个tomcat服务"></a>1.1启动两个tomcat服务</h2><p>刚刚我们已经启动了一个8080服务，现在将tomcat包复制一份</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200715135705645.png"><br>并修改其中的/conf/server.xml:</p>
<p>将shutdown端口由8005改为8006：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715135811505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>将http端口由8080改为8081：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715135847135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>将ajp端口由8009改为8010：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715140219138.png"></p>
<p>分别在两个tomcat的/webapps/ROOT/index.jsp中添加标识：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715140331374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>启动8081服务：</p>
<p><img src="https://img-blog.csdnimg.cn/202007151404332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="1-2轮询"><a href="#1-2轮询" class="headerlink" title="1.2轮询"></a>1.2轮询</h2><p>nginx配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">upstream local_server&#123;<br>        server localhost:8080;<br>        server localhost:8081;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>local_server使我们自己起的名字，server表示可用的后台服务。</p>
<p><img src="https://img-blog.csdnimg.cn/20200715140839408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>在nginx.exe所在目录打开命令行，执行重启命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">nginx -s reload<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200715142323935.png"></p>
<p>重新访问localhost，会看到在两个服务之间来回切换：</p>
<p><img src="https://img-blog.csdnimg.cn/20200715142443151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200715142510962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="1-3权重"><a href="#1-3权重" class="headerlink" title="1.3权重"></a>1.3权重</h2><p>nginx配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">upstream local_server&#123;<br>		server localhost:8080 weight&#x3D;8;<br>        server localhost:8081 weight&#x3D;2;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>重启nginx，并在页面访问localhost，发现8080页面出现频率要比8081高得多。</p>
<h2 id="1-4IP-Hash"><a href="#1-4IP-Hash" class="headerlink" title="1.4IP Hash"></a>1.4IP Hash</h2><p>nginx配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">upstream local_server&#123;<br>		ip_hash;<br>        server localhost:8080;<br>        server localhost:8081;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>测试方式同上。</p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>反向代理</tag>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>轻松搞定Eclipse中的代码格式化</title>
    <url>/2020/12/14/%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9AEclipse%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<p>本文以eclipse Oxygen.3a Release版本为例。</p>
<p>以下代码为格式化配置的代码，需要将代码另存为文件code_formatter.xml中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;13&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;CodeFormatterProfile&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code_formatter&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;13&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_ellipsis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_for_statment&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.new_lines_at_block_boundaries&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_after_imports&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_switch_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_javadoc_comments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indentation.size&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;8&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_enum_constant_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.disabling_tag&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;@formatter:off&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.continuation_indentation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_enum_constants&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_imports&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_after_package&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_binary_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_if_while_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.indent_root_tags&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.wrap_before_or_operator_multicatch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.enabling_tag&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;@formatter:on&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.count_line_length_from_starting_position&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_parameterized_type_references&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.problem.enumIdentifier&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_statements_compare_to_block&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.line_length&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;120&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.use_on_off_tags&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.preserve_white_space_between_code_and_line_comments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_union_type_in_multicatch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_binary_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_catch_clause&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_block&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_lambda_body&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.compact_else_if&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.problem.assertIdentifier&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_try&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_binary_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_unary_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.format_line_comment_starting_on_first_column&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_ellipsis&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_try_resources&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_line_comments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.align_type_members_on_columns&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_assignment&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_module_statements&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_conditional_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_block_in_case&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_header&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;enabled&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.join_wrapped_lines&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.wrap_before_conditional_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.align_fields_grouping_blank_lines&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2147483647&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.new_lines_at_javadoc_boundaries&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_resources_in_try&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_try_clause&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.source&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.tabulation.size&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_source_code&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_try&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_try_resources&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_field&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_method&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.wrap_before_assignment_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.codegen.targetPlatform&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_switch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_type_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_html&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_method_delcaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_compact_if&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_empty_lines&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_unary_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_label&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_member_type&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_semicolon&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_try&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_block_comments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_lambda_arrow&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_statements_compare_to_body&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_multiple_fields&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.wrap_before_binary_operator&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.compliance&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.parentheses_positions_in_lambda_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;common_lines&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.wrap_outer_expressions_when_nested&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.brace_position_for_type_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;end_of_line&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_package&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_expressions_in_for_loop_header&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_lambda_arrow&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.join_lines_in_comments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.indent_parameter_description&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.tabulation.char&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;space&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_between_import_groups&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.lineSplit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;120&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure>
<p>点击顶部菜单栏的window-&gt;preferencens-&gt;Java-&gt;Code Style-&gt;Formatter</p>
<p>点击import，导入配置文件:</p>
<img src="https://img-blog.csdnimg.cn/20200715101542746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>导入后点击右下角Apply应用。</p>
<p>进入Java-&gt;Editor-&gt;Save Actions，选择保存动作，如图选中下列选项:</p>
<img src="https://img-blog.csdnimg.cn/20200715102053652.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>此配置表示ctrl+s保存代码时，根据我们导入的格式化文件进行代码格式化。</p>
]]></content>
      <categories>
        <category>代码规范</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>代码格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Redis</title>
    <url>/2020/12/14/Docker%E5%AE%89%E8%A3%85Redis/</url>
    <content><![CDATA[<p>搜索redis镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker search redis<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200709091024363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>拉取最新版本的redis镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker pull redis<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200709091126944.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>查看已下载镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker images<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200709091233824.png"></p>
<p>在root目录下建立redis1目录，用来存放redis启动配置文件，方便后期挂载到容器中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ mkdir redis1<br></code></pre></td></tr></table></figure>

<p>在官网下载 <a href="http://download.redis.io/redis-stable/redis.conf">redis.conf</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200709110818102.png"></p>
<p> 修改redis.conf，设置可以远程通过密码访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /root/redis1<br>$ vi redis.conf<br></code></pre></td></tr></table></figure>

<p>注释bind 127.0.0.1（69行），去除仅限本地访问的限制</p>
<p><img src="https://img-blog.csdnimg.cn/20200709112004760.png"></p>
<p>修改protected-mode yes为protected-mode no（88行），关闭保护模式，开启时只能本地访问</p>
<p><img src="https://img-blog.csdnimg.cn/20200709112037361.png"></p>
<p>修改# requirepass foobared为requirepass newPassword（771行）设置访问密码为newPassword</p>
<p><img src="https://img-blog.csdnimg.cn/20200709112110541.png"></p>
<p>运行redis容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker run -p 6379:6379 -d -v /root/redis1/redis.conf:/etc/redis/redis.conf -v /root/redis1/data:/data --name redis1 docker.io/redis redis-server /etc/redis/redis.conf <br></code></pre></td></tr></table></figure>

<ul>
<li>-p </li>
</ul>
<p>指定端口映射</p>
<ul>
<li>-v</li>
</ul>
<p>挂载容器目录到宿主机目录，：前面的路径为宿主机目录，：后面的路径为</p>
<ul>
<li>–name</li>
</ul>
<p>设置容器名称</p>
<ul>
<li>redis-server /etc/redis/redis.conf</li>
</ul>
<p>容器启动后执行运行redis命令，此时redis.conf即为外部/root/redis1中的redis.conf</p>
<p>查看正在运行的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker ps<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200709113908131.png"></p>
<p>查看容器日志：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker logs [container id]<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200709114004525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>使用redis客户端连接：</p>
<img src="https://img-blog.csdnimg.cn/20200709113754328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>启动成功。 </p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装mysql57</title>
    <url>/2020/12/14/Docker%E5%AE%89%E8%A3%85mysql57/</url>
    <content><![CDATA[<p>搜索docker中的mysql镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker search mysql<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200708175314234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>拉取mysql57:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker pull docker.io/mysql:5.7<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020070817540399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>查看已下载的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker images<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200708180503607.png"></p>
<p>创建容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD&#x3D;root --restart&#x3D;always  docker.io&#x2F;mysql:5.7<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200708180538988.png"></p>
<p>查看已运行的容器，查看容器id：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker ps<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200708180603921.png"></p>
<p>进入容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it 146c196fef3a /bin/bash<br></code></pre></td></tr></table></figure>

<p>进入mysql:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">$ mysql -u root -p<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200708180914294.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>修改root用户允许远程访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;root&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> <span class="hljs-keyword">PRIVILEGES</span> <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span> <br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200708180935756.png"></p>
<p>通过navicat远程连接：</p>
<img src="https://img-blog.csdnimg.cn/20200708181015415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<p>安装成功。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署Tomcat项目</title>
    <url>/2020/12/14/Docker%E9%83%A8%E7%BD%B2Tomcat%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h2 id="1-设置yum源"><a href="#1-设置yum源" class="headerlink" title="1.设置yum源"></a>1.设置yum源</h2><p>下载yum工具</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ yum -y install yum-utils<br></code></pre></td></tr></table></figure>
<p>设置aliyun为yum源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">yum-config-manager --add-repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707140146330.png"></p>
<h2 id="2-搜索tomcat"><a href="#2-搜索tomcat" class="headerlink" title="2.搜索tomcat"></a>2.搜索tomcat</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ docker search tomcat<br></code></pre></td></tr></table></figure>
<p>如果出现：</p>
<p>Error response from daemon: Get <a href="https://index.docker.io/v1/search?q=tomcat&amp;n=25">https://index.docker.io/v1/search?q=tomcat&amp;n=25</a>: dial tcp: lookup index.docker.io on 61.128.128.68:53: no such host</p>
<p><img src="https://img-blog.csdnimg.cn/20200707140950166.png"></p>
<p>就需要修改DNS解析，首先查看你当前物理机的DNS地址：</p>
<p><img src="https://img-blog.csdnimg.cn/20200707142919329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ vi &#x2F;etc&#x2F;resolv.conf<br></code></pre></td></tr></table></figure>
<p>设置DNS地址：</p>
<p><img src="https://img-blog.csdnimg.cn/2020070714303840.png"></p>
<p>保存后重启network:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ systemctl restart network<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707143225723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="3-拉取tomcat8-5"><a href="#3-拉取tomcat8-5" class="headerlink" title="3.拉取tomcat8.5"></a>3.拉取tomcat8.5</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ docker pull tomcat:8.5<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707143552288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="4-查看本地镜像"><a href="#4-查看本地镜像" class="headerlink" title="4.查看本地镜像"></a>4.查看本地镜像</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ docker images|grep tomcat<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707143820378.png"></p>
<h2 id="5-启动一个tomcat实例"><a href="#5-启动一个tomcat实例" class="headerlink" title="5.启动一个tomcat实例"></a>5.启动一个tomcat实例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ docker run -d -v &#x2F;root&#x2F;tomcat1:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps -p 8080:8080 --name tomcat1 docker.io&#x2F;tomcat:8.5  <br></code></pre></td></tr></table></figure>
<ul>
<li>-d<br>  表示后台启动</li>
<li>-v<br>  表示挂载，将容器中的/usr/local/tomcat/webapps挂载到宿主机的/root/tomcat1文件夹</li>
<li>-p<br>  表示设置访问端口，第一个端口为外部访问的端口，第二个为容器内端口</li>
<li>–name<br>  设置容器名称</li>
<li>docker.io/tomcat:8.5<br>  docker.io/tomcat镜像名称，8.5为TAG，就是版本号，如果没有TAG，将会选取最新的镜像运行，如果本地仓库没有最新的镜像，将会pull最新的镜像到本地，并运行。<h2 id="6-部署自己的项目"><a href="#6-部署自己的项目" class="headerlink" title="6.部署自己的项目"></a>6.部署自己的项目</h2>将物理机上的Tomcat-&gt;webapps中的ROOT文件夹加放到宿主机的/root/tomcat1中，作为上传jar包的演示。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200707224906540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"><br>在外部网站访问8080端口：</p>
<p><img src="https://img-blog.csdnimg.cn/20200707224557491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>如果连接拒绝，可能是由于虚拟机的端口未开放，需要关闭防火墙或者开放端口，可以参考文章《<a href="https://blog.csdn.net/qq_37171817/article/details/106731470">CentOS7 中开放端口</a>》解决。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>基于CentOS7安装docker</title>
    <url>/2020/12/14/%E5%9F%BA%E4%BA%8ECentOS7%E5%AE%89%E8%A3%85docker/</url>
    <content><![CDATA[<p>本例中系统为CentOS7，内核版本为3.10。在CentOS7中安装docker，需要系统为64位，且内核版本在3.10以上。 </p>
<p>查看系统信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ lsb_release -a<br></code></pre></td></tr></table></figure>
<p>如果出现“lsb_release: command not found”情况，请先执行安装命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ yum install -y redhat-lsb<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707125857200.png"></p>
<p>查看内核版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ uname -r<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707130019375.png"></p>
<p>使用yum安装docker:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ yum -y install docker<br></code></pre></td></tr></table></figure>
<p>启动docker:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ systemctl start docker<br></code></pre></td></tr></table></figure>
<p>查看docker状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ systemctl status docker<br></code></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200707130428480.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Docker</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式数据库HBase实践指南</title>
    <url>/2020/12/11/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93HBase%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="一、HBase简介"><a href="#一、HBase简介" class="headerlink" title="一、HBase简介"></a>一、HBase简介</h1><p><img src="https://img-blog.csdnimg.cn/20200620133757300.png"></p>
<p> HBase官方网站：<a href="http://hbase.apache.org/">http://hbase.apache.org/</a></p>
<p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文《Bigtable：一个结构化数据的分布式存储系统》。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。</p>
<p>HBase以表的形式存储数据，表有行和列组成，列划分为多个列族/列簇（column family）。</p>
<p>HBase的运行有三种模式：单机模式、伪分布式模式、分布式模式。</p>
<ul>
<li>单机模式</li>
</ul>
<p>在一台计算机上安装和使用HBase，不涉及数据的分布式存储。</p>
<ul>
<li>伪分布式模式</li>
</ul>
<p>在一台计算机上模拟一个小的集群。</p>
<ul>
<li>分布式模式</li>
</ul>
<p>使用多台计算机实现物理意义上的分布式存储。</p>
<h1 id="二、安装教程"><a href="#二、安装教程" class="headerlink" title="二、安装教程"></a>二、安装教程</h1><p>本文示例的运行环境为CentOS7。HBase版本为1.1.2，Hadoop版本为2.7.7，JDK1.8。</p>
<p>在安装HBase之前，<strong>需要安装Hadoop</strong>。可根据《<a href="https://blog.csdn.net/qq_37171817/article/details/106728161">分布式处理框架Hadoop的安装与使用</a>》进行安装。由于HBase对Hadoop版本具有依赖性，所以安装其他版本前需要查看两者版本之间是否匹配。</p>
<p><img src="https://img-blog.csdnimg.cn/20200620152524329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="1、下载HBase"><a href="#1、下载HBase" class="headerlink" title="1、下载HBase"></a>1、下载HBase</h2><p>下载地址：<a href="http://archive.apache.org/dist/hbase/1.3.2/">http://archive.apache.org/dist/hbase/1.3.2/</a></p>
<p>下载*-bin.tar.gz文件</p>
<p><img src="https://img-blog.csdnimg.cn/2020062111145442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 下载后将压缩包放到/home/hadoop/download路径下。我这里download文件夹是为了存放下载的文件，下载文件夹不限制位置。“~”路径代表当前用户文件夹，此处为hadoop用户，所以对应的路径就是“/home/hadoop”。</p>
<h2 id="2、安装HBase"><a href="#2、安装HBase" class="headerlink" title="2、安装HBase"></a>2、安装HBase</h2><p><img src="https://img-blog.csdnimg.cn/20200621112913656.png"></p>
<p> 解压到/usr/local/路径下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -zxf /home/hadoop/download/hbase-1.3.2-bin.tar.gz -C /usr/<span class="hljs-built_in">local</span><br></code></pre></td></tr></table></figure>

<p>切换到root用户，重命名hbase-1.3.2文件夹，将解压后的文件赋权给hadoop用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span><br>$ mv ./hbase-1.3.2 ./hbase<br>$ chown -R hadoop:hadoop hbase/<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200621113134531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>配置环境变量</p>
<p>切回到hadoop用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ su hadoop<br></code></pre></td></tr></table></figure>

<p>编辑环境变量文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi ~/.bashrc<br></code></pre></td></tr></table></figure>

<p> 添加Hbase环境变量。其中“:”，冒号是起分隔符的作用。</p>
<p><img src="https://img-blog.csdnimg.cn/2020070113122381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 编辑完成后，使用source命令，让配置文件在当前终端立即生效。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>查看HBase版本，确定是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hbase version<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020062111361975.png"></p>
<h1 id="三、配置HBase"><a href="#三、配置HBase" class="headerlink" title="三、配置HBase"></a>三、配置HBase</h1><p>HBase有三种运行模式，单机模式、伪分布式模式、分布式模式，我们这里案例使用单机模式与伪分布模式。</p>
<p>在配置之前，必须要满足如下条件：</p>
<ul>
<li>jdk</li>
<li>Hadoop( 单机模式不需要，伪分布式模式和分布式模式需要)</li>
<li>SSH</li>
</ul>
<p>如果以上三者均为安装，请根据文章《<a href="https://blog.csdn.net/qq_37171817/article/details/106728161">分布式处理框架Hadoop的安装与使用</a>》进行安装。</p>
<h2 id="1-单机模式配置"><a href="#1-单机模式配置" class="headerlink" title="1.单机模式配置"></a>1.单机模式配置</h2><h3 id="修改-usr-local-hbase-conf-hbase-env-sh配置"><a href="#修改-usr-local-hbase-conf-hbase-env-sh配置" class="headerlink" title="修改/usr/local/hbase/conf/hbase-env.sh配置"></a>修改/usr/local/hbase/conf/hbase-env.sh配置</h3><p>增加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk1.8.0_51<br>export HBASE_MANAGES_ZK&#x3D;true <br></code></pre></td></tr></table></figure>

<ul>
<li>JAVA_HOME</li>
</ul>
<p>jdk安装目录。</p>
<ul>
<li>HBASE_MANAGES_ZK</li>
</ul>
<p>true:表示由hbase自己管理zookeeper，不需要单独的zookeeper。</p>
<h3 id="1-1配置-usr-local-hbase-conf-hbase-site-xml"><a href="#1-1配置-usr-local-hbase-conf-hbase-site-xml" class="headerlink" title="1.1配置/usr/local/hbase/conf/hbase-site.xml"></a>1.1配置/usr/local/hbase/conf/hbase-site.xml</h3><p>在启动HBase前需要设置属性hbase.rootdir，用于指定HBase数据的存储位置，因为如果不设置的话，hbase.rootdir默认为/tmp/hbase-${user.name}，这意味着每次重启系统都会丢失数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;configuration&gt;<br>        &lt;property&gt;<br>                &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;<br>                &lt;value&gt;file:&#x2F;&#x2F;&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;hbase-tmp&lt;&#x2F;value&gt;<br>        &lt;&#x2F;property&gt;<br>&lt;&#x2F;configuration&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200620171431536.png"></p>
<p><img src="https://img-blog.csdnimg.cn/20200620171401216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="1-2测试运行"><a href="#1-2测试运行" class="headerlink" title="1.2测试运行"></a>1.2测试运行</h3><p>启动HBase，并打开Shell命令模式，使用户可以通过shell命令操作数据库。由于前面配置了环境变量，所以可以直接运行，实际上这两条命令都应该在/usr/local/hbase/bin目录下运行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ start-hbase.sh<br>$ hbase shell<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200620172112679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="1-3停止HBase"><a href="#1-3停止HBase" class="headerlink" title="1.3停止HBase"></a>1.3停止HBase</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ stop-hbase.sh<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200620172245724.png"></p>
<h2 id="2-伪分布式配置，使用外部Zookeeper"><a href="#2-伪分布式配置，使用外部Zookeeper" class="headerlink" title="2.伪分布式配置，使用外部Zookeeper"></a>2.伪分布式配置，使用外部Zookeeper</h2><h2 id="2-1配置主机别名"><a href="#2-1配置主机别名" class="headerlink" title="2.1配置主机别名"></a>2.1配置主机别名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi /etc/hosts<br></code></pre></td></tr></table></figure>

<p> 为本节点的ip设置一个别名：</p>
<p><img src="https://img-blog.csdnimg.cn/2020070113040252.png"></p>
<h2 id="2-2下载安装zookeeper"><a href="#2-2下载安装zookeeper" class="headerlink" title="2.2下载安装zookeeper"></a>2.2下载安装zookeeper</h2><p>官方下载地址：<a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</a></p>
<p>将安装包放到/home/hadoop/download下</p>
<p><img src="https://img-blog.csdnimg.cn/20200701131718560.png"></p>
<p> 解压文件到/usr/local/，会在此路径下生成zookeeper-3.4.14文件夹。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -zxvf ./zookeeper-3.4.14.tar.gz -C /usr/<span class="hljs-built_in">local</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200701132718475.png"></p>
<p>将zookeeper文件夹所有权更改为hadoop:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ chown -R hadoop:hadoop zookeeper-3.4.14/<br></code></pre></td></tr></table></figure>

<p>切换回hadoop用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ su hadoop<br></code></pre></td></tr></table></figure>

<p> 编辑zookeeper环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi ~/.bashrc<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200701133449722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 使环境变量生效:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>进入zookeeper配置文件路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/zookeeper-3.4.14/conf/<br></code></pre></td></tr></table></figure>

<p>复制zoo-sample.cfg，并将新文件命名为zoo.cfg </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ cp zoo_sample.cfg zoo.cfg<br></code></pre></td></tr></table></figure>

<p> 配置zoo.cfg</p>
<p><img src="https://img-blog.csdnimg.cn/20200701140434566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>dataDir</li>
</ul>
<p>zookeeper文件存放位置，此文件夹需要hadoop用户有权限使用，否则会报错。</p>
<h3 id="2-3配置-usr-local-hbase-conf-hbase-env-sh"><a href="#2-3配置-usr-local-hbase-conf-hbase-env-sh" class="headerlink" title="2.3配置/usr/local/hbase/conf/hbase-env.sh"></a>2.3配置/usr/local/hbase/conf/hbase-env.sh</h3><p>配置下列项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;jdk1.8.0_51<br>export HBASE_CLASSPATH&#x3D;&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;conf <br>export HBASE_MANAGES_ZK&#x3D;false<br></code></pre></td></tr></table></figure>

<ul>
<li>JAVA_HOME </li>
</ul>
<p>jdk安装路径。</p>
<ul>
<li>HBASE_CLASSPATH</li>
</ul>
<p>设置为本机HBase安装目录下的conf目录。</p>
<ul>
<li>HBASE_MANAGES_ZK</li>
</ul>
<p>此处设置为false，表示不使用自带zookeeper，使用外部zk。</p>
<h3 id="2-4配置-usr-local-hbase-conf-hbase-site-xml"><a href="#2-4配置-usr-local-hbase-conf-hbase-site-xml" class="headerlink" title="2.4配置/usr/local/hbase/conf/hbase-site.xml"></a>2.4配置/usr/local/hbase/conf/hbase-site.xml</h3><p>配置内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;configuration&gt;<br>	&lt;property&gt;<br>                &lt;name&gt;hbase.rootdir&lt;&#x2F;name&gt;<br>                &lt;value&gt;hdfs:&#x2F;&#x2F;master:9000&#x2F;hbase&lt;&#x2F;value&gt;<br>        &lt;&#x2F;property&gt;<br>        &lt;property&gt;<br>                &lt;name&gt;hbase.cluster.distributed&lt;&#x2F;name&gt;<br>                &lt;value&gt;true&lt;&#x2F;value&gt;<br>        &lt;&#x2F;property&gt;<br>	&lt;property&gt;<br>        	&lt;name&gt;hbase.master.info.port&lt;&#x2F;name&gt;<br>    		&lt;value&gt;16010&lt;&#x2F;value&gt; <br>        &lt;&#x2F;property&gt;<br>	&lt;property&gt;<br>                &lt;name&gt;hbase.master&lt;&#x2F;name&gt;<br>                &lt;value&gt;master:16000&lt;&#x2F;value&gt;<br>        &lt;&#x2F;property&gt;<br>	&lt;property&gt;<br>     		&lt;name&gt;zookeeper.znode.parent&lt;&#x2F;name&gt;<br>     		&lt;value&gt;&#x2F;hbase&#x2F;master&lt;&#x2F;value&gt;<br>	 &lt;&#x2F;property&gt;<br>	&lt;property&gt;<br>		&lt;name&gt;hbase.zookeeper.quorum&lt;&#x2F;name&gt;<br>		&lt;value&gt;master:2181&lt;&#x2F;value&gt;<br>	&lt;&#x2F;property&gt; <br>&lt;&#x2F;configuration&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>hbase.rootdir</li>
</ul>
<p>指定HBase的存储目录。9000为HDFS端口（NameNode端口），hbase文件夹必须在hdfs中存在，如果不存在，请使用</p>
<ul>
<li>hbase.cluster.distributed</li>
</ul>
<p>设置集群处于分布式模式。</p>
<ul>
<li>hbase.master.info.port</li>
</ul>
<p>hmater管理界面端口，可通过ip+port在web界面查看hmaster状态。</p>
<ul>
<li>hbase.master</li>
</ul>
<p>hmater的ip和端口信息。</p>
<ul>
<li>hbase.zookeeper.quorum</li>
</ul>
<p>zookeeper的ip和端口信息。</p>
<h2 id="2-5修改regionservers"><a href="#2-5修改regionservers" class="headerlink" title="2.5修改regionservers"></a>2.5修改regionservers</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi /usr/<span class="hljs-built_in">local</span>/hbase/conf/regionservers<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200701135247129.png"></p>
<p>此处暂时只有一个节点，为本机，此处master已在/etc/hosts文件中做了映射。</p>
<h3 id="2-6测试运行"><a href="#2-6测试运行" class="headerlink" title="2.6测试运行"></a>2.6测试运行</h3><p>关闭防火墙</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ systemctl <span class="hljs-built_in">disable</span> firewalld<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200623132244303.png"></p>
<p>关闭SElinux </p>
<p>编辑/etc/selinux/config，将SELINUX=enforcing 修改为”SELINUX=disabled”</p>
<p><img src="https://img-blog.csdnimg.cn/20200623132542806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>启动hadoop:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ start-dfs.sh<br></code></pre></td></tr></table></figure>

<p>出现如下说明启动Hadoop成功</p>
<p><img src="https://img-blog.csdnimg.cn/20200620220710605.png"></p>
<p>启动zookeeper</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ zkServer.sh start<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200701140552875.png"></p>
<p>启动HBase:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ start-hbase.sh<br></code></pre></td></tr></table></figure>

<p>出现如下说明启动HBase成功</p>
<p><img src="https://img-blog.csdnimg.cn/20200701140636729.png"></p>
<p>关闭HBase:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ stop-hbase.sh<br></code></pre></td></tr></table></figure>

<p> 如果一直关闭不了，可以先使用如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hbase-daemon.sh stop master<br>$ stop-hbase.sh<br></code></pre></td></tr></table></figure>

<p> 关闭zookeeper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$ zkServer.sh stop<br></code></pre></td></tr></table></figure>

<p>关闭Hadoop: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ stop-dfs.sh<br></code></pre></td></tr></table></figure>

<p>启动顺序：Hadoop-&gt;Zookeeper-&gt;HBase</p>
<p>关闭顺序：HBase-&gt;Zookeeper-&gt;Hadoop</p>
<p>错误日志位置：HBase安装目录下的logs文件夹，本例日志位于/usr/local/hbase/logs。</p>
<h2 id="2-7解决错误"><a href="#2-7解决错误" class="headerlink" title="2.7解决错误"></a>2.7解决错误</h2><p>日志目录： /usr/local/hbase/logs/</p>
<p>mater节点日志：hbase-hadoop-master-localhost.localdomain.log </p>
<p>zookeeper日志：hbase-hadoop-zookeeper-localhost.localdomain.log</p>
<p>当启动HBase报错org.apache.hadoop.hbase.PleaseHoldException: Master is initializing：</p>
<p>进入zk客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ zkCli.sh -server localhost:2181<br></code></pre></td></tr></table></figure>

<p>查看所有文件夹：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620213903956.png"></p>
<p>删除文件夹：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620214027848.png"></p>
<p>退出客户端：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620214218846.png"></p>
<p> 删除hdfs中hbase文件夹下内容：</p>
<p>由于本文在写时换了两种不同环境的网络，所以ip有所不同，172.20.10.6与192.168.0.121均为我虚拟机的ip，在实践时只需要统一即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hadoop fs -rm -r hdfs://172.20.10.6:9000/hbase/*<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200620220540461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>重启HBase。 </p>
<p>使用shell操作数据时：The node /hbase is not in ZooKeeper. It should have been written by the master. Check the value configured in ‘zookeeper.znode.parent’. There could be a mismatch with the one configured in the master.</p>
<p>缺少配置，在/usr/local/hbase/conf/hbase-site.xml中添加下列配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;property&gt;  <br>    &lt;name&gt;zookeeper.znode.parent&lt;&#x2F;name&gt;  <br>    &lt;value&gt;&#x2F;hbase&lt;&#x2F;value&gt;  <br>&lt;&#x2F;property&gt; <br></code></pre></td></tr></table></figure>

<p>本人遇到的一个很坑的问题：</p>
<p><img src="https://img-blog.csdnimg.cn/20200623130852377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>根据教学配置，完全按照步骤来，但是就是zookeeper连接不上，各种问题搜索了一大堆所谓的解决答案，同时也换了很多个HBase版本进行安装，但是问题根本就没有得以解决，反而浪费了两天时间。</p>
<p>以下是我安装过的HBase版本：</p>
<p><img src="https://img-blog.csdnimg.cn/20200623130711426.png"></p>
<p> 就在我心灰意冷的时候，突然想到会不会是hdfs的问题，然后改了hdfs的配置文件/usr/local/hadoop/etc/hadoop/core-site.xml：</p>
<p>将172.20.10.6(本机ip)改成了localhost</p>
<p><img src="https://img-blog.csdnimg.cn/2020062313144819.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>接着启动Hadoop，启动HBase，错误完美解决。问题就是这样，有时候你越刚它越解决不出来，但是在之后的某一个时间，突然就意外解决了。</p>
<h1 id="四、编程实践"><a href="#四、编程实践" class="headerlink" title="四、编程实践"></a>四、编程实践</h1><h2 id="1、Shell命令"><a href="#1、Shell命令" class="headerlink" title="1、Shell命令"></a>1、Shell命令</h2><h3 id="1-1HBase创建表"><a href="#1-1HBase创建表" class="headerlink" title="1.1HBase创建表"></a>1.1HBase创建表</h3><p>创建用户user表，有name、password、age、address属性。且还有HBase默认创建的行键。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">create <span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-string">&#x27;name&#x27;</span>,<span class="hljs-string">&#x27;password&#x27;</span>,<span class="hljs-string">&#x27;age&#x27;</span>,<span class="hljs-string">&#x27;address&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200623132804786.png"></p>
<p> describe命令查看表信息:</p>
<p><img src="https://img-blog.csdnimg.cn/20200623132950182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="1-2HBase增删改查"><a href="#1-2HBase增删改查" class="headerlink" title="1.2HBase增删改查"></a>1.2HBase增删改查</h2><p>在添加数据时，HBase会自动给数据添加一个时间戳，在需要改数据时，只需要新增一条数据就行，因为有时间戳作为版本区别，HBase会定时回收旧数据，只留下最新的几个版本，单条的记录留存的版本数量在创建的时候指定。</p>
<ul>
<li>写入数据</li>
</ul>
<p>写入行键为1，名称为‘han’的记录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">put <span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;han&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200623133949406.png"></p>
<ul>
<li> 删除数据</li>
</ul>
<p>delete：删除数据，是put的反向操作。</p>
<p>deleteall：删除一行数据。</p>
<p>删除行键为1的数据的name列：</p>
<p><img src="https://img-blog.csdnimg.cn/20200623134700773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 我这里是因为之前给行键为1的数据写入了4个name值，分别为‘han’,’han1’,’han2’,’han3’，所以删除时会逐级删除。</p>
<p>删除行键为1的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20200623134940928.png"></p>
<ul>
<li>查看数据 </li>
</ul>
<p>get：查看表中某一行数据。</p>
<p>scan：查表中所有数据。</p>
<p>查看user表的行键为2的数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20200623135322135.png"></p>
<p>查看user表所有数据： </p>
<p><img src="https://img-blog.csdnimg.cn/20200623135346801.png"></p>
<ul>
<li>删除表 </li>
</ul>
<p>先让表不可用，再删除。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">disable</span> <span class="hljs-string">&#x27;user&#x27;</span>  <br>drop <span class="hljs-string">&#x27;user&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200623135602265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>查询表历史数据 </li>
</ul>
<p>指定历史版本(5)来创建表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">create <span class="hljs-string">&#x27;user&#x27;</span>,&#123;NAME=&gt;<span class="hljs-string">&#x27;name&#x27;</span>,VERSIONS=&gt;5&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020062313585092.png"></p>
<p>插入数据： </p>
<p><img src="https://img-blog.csdnimg.cn/20200623140019407.png"></p>
<p>指定历史版本数查询的数据： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">get <span class="hljs-string">&#x27;user&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>,&#123;COLUMN=&gt;<span class="hljs-string">&#x27;name&#x27;</span>,VERSIONS=&gt;2&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200623140206780.png"></p>
<p>退出hbase shell命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exit</span><br></code></pre></td></tr></table></figure>

<h2 id="2、Java-API"><a href="#2、Java-API" class="headerlink" title="2、Java API"></a>2、Java API</h2><p>由于本文是在虚拟机上搭建hadoop、hbase环境，在本地物理机上写代码运行，所以需要在物理机上配变量：</p>
<p>编辑C:\Windows\System32\drivers\etc\hosts文件：</p>
<p><img src="https://img-blog.csdnimg.cn/20200701141259414.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>说明：192.168.0.121为虚拟机ip，mater为虚拟机别名。</p>
<p>完整项目请查看本片文章上传资源。</p>
<p>maven依赖：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;<br>		&lt;artifactId&gt;hbase-client&lt;/artifactId&gt;<br>		&lt;version&gt;1.3.1&lt;/version&gt;<br>	&lt;/dependency&gt;<br><br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;<br>		&lt;artifactId&gt;hbase-server&lt;/artifactId&gt;<br>		&lt;version&gt;1.3.1&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hbase&lt;/groupId&gt;<br>		&lt;artifactId&gt;hbase-common&lt;/artifactId&gt;<br>		&lt;version&gt;1.3.1&lt;/version&gt;<br>	&lt;/dependency&gt;<br><br>	&lt;dependency&gt;<br>		&lt;groupId&gt;commons-logging&lt;/groupId&gt;<br>		&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;<br>		&lt;version&gt;1.2&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>		&lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;<br>		&lt;version&gt;2.5.1&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>		&lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;<br>		&lt;version&gt;2.5.1&lt;/version&gt;<br>	&lt;/dependency&gt;<br><br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>		&lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;<br>		&lt;version&gt;2.5.1&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;log4j&lt;/groupId&gt;<br>		&lt;artifactId&gt;log4j&lt;/artifactId&gt;<br>		&lt;version&gt;1.2.17&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>		&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br>		&lt;version&gt;1.7.12&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;dependency&gt;<br>		&lt;groupId&gt;junit&lt;/groupId&gt;<br>		&lt;artifactId&gt;junit&lt;/artifactId&gt;<br>		&lt;version&gt;3.8.1&lt;/version&gt;<br>		&lt;scope&gt;test&lt;/scope&gt;<br>	&lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure>

<p>本段代码包含对hbase数据库的增删改查，建表删除表的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.hbase;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.Cell;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.CellUtil;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.HBaseConfiguration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.HColumnDescriptor;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.HTableDescriptor;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.TableName;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Admin;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Connection;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.ConnectionFactory;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Delete;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Get;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Put;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Result;<br><span class="hljs-keyword">import</span> org.apache.hadoop.hbase.client.Table;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HBASE的JAVA API</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hanguilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> </span>&#123;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Configuration conf;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Admin admin;<br><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection conn;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><span class="hljs-comment">//		// 创建一个列族为name、age、address的名为test_user的表</span><br><span class="hljs-comment">//		createTable(&quot;test_user&quot;, Lists.newArrayList(&quot;name&quot;, &quot;age&quot;, &quot;address&quot;));</span><br><span class="hljs-comment">//		// 显示所有表</span><br><span class="hljs-comment">//		listTable();</span><br><span class="hljs-comment">//		// 向test_user表中行键为1，列族为name的列添加值（此处name列族没有子列，所以col列为空）</span><br><span class="hljs-comment">//		insertRow(&quot;test_user&quot;, &quot;1&quot;, &quot;name&quot;, &quot;&quot;, &quot;hanguilin&quot;);</span><br><span class="hljs-comment">//		// 获取test_user表中行键为1，列族为name的值</span><br><span class="hljs-comment">//		getRow(&quot;test_user&quot;, &quot;1&quot;, &quot;name&quot;, &quot;&quot;);</span><br><span class="hljs-comment">//		// 删除test_user表中行键为1，列族为name中的值</span><br><span class="hljs-comment">//		deleteRow(&quot;test_user&quot;, &quot;1&quot;, &quot;name&quot;, &quot;&quot;);</span><br><span class="hljs-comment">//		// 删除test_user表</span><br><span class="hljs-comment">//		deleteTable(&quot;test_user&quot;);</span><br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 初始化</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>		<br>		conf = HBaseConfiguration.create();<br>		conf.set(<span class="hljs-string">&quot;hbase.rootdir&quot;</span>, <span class="hljs-string">&quot;hdfs://192.168.0.121:9000/hbase&quot;</span>);<br>		conf.set(<span class="hljs-string">&quot;hbase.cluster.distributed&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>);<br>		conf.set(<span class="hljs-string">&quot;hbase.master.info.port&quot;</span>, <span class="hljs-string">&quot;16010&quot;</span>);<br>		conf.set(<span class="hljs-string">&quot;hbase.zookeeper.property.dataDir&quot;</span>, <span class="hljs-string">&quot;/usr/local/hbase/data/zookeeper&quot;</span>);<br>		conf.set(<span class="hljs-string">&quot;hbase.master&quot;</span>, <span class="hljs-string">&quot;192.168.0.121:16000&quot;</span>);<br>		conf.set(<span class="hljs-string">&quot;zookeeper.znode.parent&quot;</span>, <span class="hljs-string">&quot;/hbase/master&quot;</span>);<br>		conf.set(<span class="hljs-string">&quot;hbase.zookeeper.quorum&quot;</span>, <span class="hljs-string">&quot;192.168.0.121:2181&quot;</span>);<br>		<span class="hljs-keyword">try</span> &#123;<br>			conn = ConnectionFactory.createConnection(conf);<br>			admin = conn.getAdmin();<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 关闭连接</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">if</span>(admin != <span class="hljs-keyword">null</span>) &#123;<br>				admin.close();<br>			&#125;<br>			<span class="hljs-keyword">if</span>(conn != <span class="hljs-keyword">null</span>) &#123;<br>				conn.close();<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 创建表</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> tableName 表明</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> columnFamily 列族</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTable</span><span class="hljs-params">(String tableName, List&lt;String&gt; columnFamily)</span> </span>&#123;<br>		init();<br>		TableName table = TableName.valueOf(tableName);<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">// 判断表是否已存在</span><br>			<span class="hljs-keyword">if</span>(admin.tableExists(table)) &#123;<br>				System.out.println(tableName + <span class="hljs-string">&quot;已存在&quot;</span>);<br>			&#125;<br>			HTableDescriptor hTableDescriptor = <span class="hljs-keyword">new</span> HTableDescriptor(table); <br>			<span class="hljs-keyword">if</span>(columnFamily != <span class="hljs-keyword">null</span> &amp;&amp; !columnFamily.isEmpty()) &#123;<br>				columnFamily.forEach(column -&gt; &#123;<br>					HColumnDescriptor hColumnDescriptor = <span class="hljs-keyword">new</span> HColumnDescriptor(column);<br>					hTableDescriptor.addFamily(hColumnDescriptor);<br>				&#125;);<br>			&#125;<br>			admin.createTable(hTableDescriptor);<br>			System.out.println(<span class="hljs-string">&quot;创建表成功&quot;</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			close();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 删除表</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> tableName 表名称</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteTable</span><span class="hljs-params">(String tableName)</span> </span>&#123;<br>		init();<br>		TableName table = TableName.valueOf(tableName);<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-keyword">if</span>(admin.tableExists(table)) &#123;<br>				<span class="hljs-comment">// 弃用表</span><br>				admin.disableTable(table);<br>				<span class="hljs-comment">// 删除表</span><br>				admin.deleteTable(table);<br>				System.out.println(<span class="hljs-string">&quot;删除表成功&quot;</span>);<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			close();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 获取所有表</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listTable</span><span class="hljs-params">()</span> </span>&#123;<br>		init();<br>		<span class="hljs-keyword">try</span> &#123;<br>			HTableDescriptor[] listTables = admin.listTables();<br>			<span class="hljs-keyword">for</span> (HTableDescriptor hTableDescriptor : listTables) &#123;<br>				System.out.println(hTableDescriptor.getTableName().getNameAsString());<br>			&#125;<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			close();<br>		&#125;<br><br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 插入行数据</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> tableName 表名称</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> rowKey 行键</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> colFamily 列族</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> col 列名称</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> value 值</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertRow</span><span class="hljs-params">(String tableName, String rowKey, String colFamily, String col, String value)</span> </span>&#123;<br>		init();<br>		<span class="hljs-keyword">try</span> &#123;<br>			Table table = conn.getTable(TableName.valueOf(tableName));<br>			Put put = <span class="hljs-keyword">new</span> Put(rowKey.getBytes());<br>			put.addColumn(colFamily.getBytes(), col.getBytes(), value.getBytes());<br>			table.put(put);<br>			table.close();<br>			System.out.println(<span class="hljs-string">&quot;插入数据成功&quot;</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			close();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 删除行数据</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> tableName 表名称</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> rowKey 行键</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> colFamily 列族</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> col 列名称</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteRow</span><span class="hljs-params">(String tableName, String rowKey, String colFamily, String col)</span> </span>&#123;<br>		init();<br>		<span class="hljs-keyword">try</span> &#123;<br>			Table table = conn.getTable(TableName.valueOf(tableName));<br>			Delete delete = <span class="hljs-keyword">new</span> Delete(rowKey.getBytes());<br>			delete.addColumn(colFamily.getBytes(), col.getBytes());<br>			table.delete(delete);<br>			System.out.println(<span class="hljs-string">&quot;删除数据成功&quot;</span>);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			close();<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 获取行数据</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> tableName 表名称</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> rowKey 行键</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> colFamily 列族</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> col 列名称</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getRow</span><span class="hljs-params">(String tableName, String rowKey, String colFamily, String col)</span> </span>&#123;<br>		init();<br>		<span class="hljs-keyword">try</span> &#123;<br>			Table table = conn.getTable(TableName.valueOf(tableName));<br>			Get get = <span class="hljs-keyword">new</span> Get(rowKey.getBytes());<br>			get.addColumn(colFamily.getBytes(), col.getBytes());<br>			Result result = table.get(get);<br>			Cell[] rawCells = result.rawCells();<br>			<span class="hljs-keyword">for</span> (Cell cell : rawCells) &#123;<br>				System.out.println(<span class="hljs-string">&quot;RowName:&quot;</span> + <span class="hljs-keyword">new</span> String(CellUtil.cloneRow(cell)) + <span class="hljs-string">&quot; &quot;</span>);<br>				System.out.println(<span class="hljs-string">&quot;Timetamp:&quot;</span> + cell.getTimestamp() + <span class="hljs-string">&quot; &quot;</span>);<br>				System.out.println(<span class="hljs-string">&quot;column Family:&quot;</span> + <span class="hljs-keyword">new</span> String(CellUtil.cloneFamily(cell)) + <span class="hljs-string">&quot; &quot;</span>);<br>				System.out.println(<span class="hljs-string">&quot;row Name:&quot;</span> + <span class="hljs-keyword">new</span> String(CellUtil.cloneQualifier(cell)) + <span class="hljs-string">&quot; &quot;</span>);<br>				System.out.println(<span class="hljs-string">&quot;value:&quot;</span> + <span class="hljs-keyword">new</span> String(CellUtil.cloneValue(cell)) + <span class="hljs-string">&quot; &quot;</span>);<br>			&#125;<br>			table.close();<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			e.printStackTrace();<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			close();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>大数据</tag>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统桥接模式下配置静态ip地址</title>
    <url>/2020/12/10/Linux%E7%B3%BB%E7%BB%9F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81ip%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="一、桥接模式"><a href="#一、桥接模式" class="headerlink" title="一、桥接模式"></a>一、桥接模式</h1><p>VMware桥接模式，也就是将虚拟机的虚拟网络适配器与主机的物理网络适配器进行交接，此时虚拟机就可以访问到外部网络。桥接模式就相当于在局域网中添加了一台新的物理机一样，虚拟机同样占用一个ip地址，此时可以与局域网内其他终端互相访问。桥接模式支持有线与无线主机网络适配器。</p>
<h1 id="二、VMware设置桥接模式"><a href="#二、VMware设置桥接模式" class="headerlink" title="二、VMware设置桥接模式"></a>二、VMware设置桥接模式</h1><p><img src="https://img-blog.csdnimg.cn/20200620121649176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="三、设置静态ip地址"><a href="#三、设置静态ip地址" class="headerlink" title="三、设置静态ip地址"></a>三、设置静态ip地址</h1><p>本例虚拟机为CentOS7。</p>
<p>1、使用ip addr查看网卡等信息</p>
<p><img src="https://img-blog.csdnimg.cn/20200620122058113.png"></p>
<p> 此时网卡名称为ens33，所以需要修改ifcfg-eth33文件。</p>
<p>2、编辑网卡文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vi /etc/sysconfig/network-scripts/ifcfg-eth33<br></code></pre></td></tr></table></figure>

<p>需要<strong>修改</strong>的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">BOOTPROTI&#x3D;static<br>ONBOOT&#x3D;yes <br></code></pre></td></tr></table></figure>

<ul>
<li>BOOTPROTI</li>
</ul>
<p>dhcp: DHCP动态地址协议 。</p>
<p>static：静态地址协议。</p>
<ul>
<li>ONBOOT</li>
</ul>
<p>系统启动时是否激活网卡接口，yes为激活，no为不激活。</p>
<p>需要<strong>添加</strong>的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">IPADDR&#x3D;172.20.10.6<br>NETMASK&#x3D;255.255.255.0  <br>GATEWAY&#x3D;172.20.10.1<br></code></pre></td></tr></table></figure>

<ul>
<li>IPADDR</li>
</ul>
<p>静态ip地址，需要确保在局域网中的唯一性，设置之前可以先ping一下，看能否ping通，能的话说明已经有主机在使用。和物理主机ip网段相同，前三位一样。</p>
<ul>
<li>NETMASK</li>
</ul>
<p>子网掩码。 </p>
<ul>
<li>GATEWAY</li>
</ul>
<p>网关地址。和物理主机网关相同。</p>
<p>物理机IP配置，通过ipconfig查询：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620131652727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>修改后虚拟机网卡的完整配置：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620132030526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>重启网络服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl restart network<br></code></pre></td></tr></table></figure>

<p>遇到的问题：Failed to start LSB: Bring up/down networking.</p>
<p><img src="https://img-blog.csdnimg.cn/20200620131358528.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>解决办法：</p>
<p>执行以下两段命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl stop NetworkManager<br>systemctl <span class="hljs-built_in">disable</span> NetworkManager<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/2020062013185023.png"></p>
<p> 测试网络是否连通：</p>
<p>在物理主机测试ping虚拟主机：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620132308306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 在虚拟机ping物理主机：</p>
<p><img src="https://img-blog.csdnimg.cn/20200620132414685.png"></p>
<p> 成功连通虚拟机网络。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>静态ip</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 Funciton、Consumer、Predicate的作用及用法</title>
    <url>/2020/12/10/Java%208%20Funciton%E3%80%81Consumer%E3%80%81Predicate%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p>Funciton、Consumer、Predicate是Java8中的新特性。他们都是函数式接口，位于java.util包中。</p>
<p>关于函数式接口，其外部特征是类上使用@FunctionalInterface注解。它有以下特点：</p>
<ul>
<li>只能注解到有且仅有一个抽象方法的类上。</li>
<li>接口显示声明或覆盖了java.lang.Object类中方法的方法也不算做抽象方法。</li>
<li>Java8接口中static方法与default方法不算抽象方法。</li>
</ul>
<p>他们各自的使用场景如下：</p>
<ul>
<li>Function</li>
</ul>
<p>需要执行目标方法后得到返回值。</p>
<p>接口修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>该类需要设置两个泛型，T为入参类型，R为返回值类型。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Applies this function to the given argument.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t the function argument</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the function result</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>Consumer</li>
</ul>
<p>仅需要执行目标方法，不需要得到返回值。</p>
<p>接口修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p>该类需要设置一个泛型，T为参数类型。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对给定的参数执行此操作。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t 入参</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>Predicate</li>
</ul>
<p>经过比较，得到比较逻辑执行过后的结果，其返回类型为true、false。</p>
<p>接口修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;&#125;<br></code></pre></td></tr></table></figure>

<p> 该类需要设置一个泛型，T为参数类型。</p>
<p>主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据给定参数比较</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t 入参</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; 满足条件返回true,</span><br><span class="hljs-comment"> * otherwise &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;<br></code></pre></td></tr></table></figure>

<h1 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h1><p>1、输入数字3，得到输入值加100的结果并转为字符创，并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"># 定义函数执行方法<br>Function&lt;Integer, String&gt; func = o -&gt; &#123;<span class="hljs-keyword">return</span> String.valueOf((o + <span class="hljs-number">100</span>));&#125;;<br># 传入3，执行方法，获取返回结果<br>String result = func.apply(<span class="hljs-number">3</span>);<br>System.out.println(<span class="hljs-string">&quot;result : &quot;</span> + result);<br></code></pre></td></tr></table></figure>

<p> 结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200618130909383.png"></p>
<p>2、输入字符“hello”，拼接字符串“ word”并输出。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Consumer&lt;String&gt; consumer = o -&gt; &#123;System.out.println(o + <span class="hljs-string">&quot; world&quot;</span>);&#125;;<br>consumer.accept(<span class="hljs-string">&quot;hello&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200618131310966.png"></p>
<p>3、输入字符串“hello”，判断长度是否等于5。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Predicate&lt;String&gt; predicate = o -&gt; &#123;<span class="hljs-keyword">return</span> o.length() == <span class="hljs-number">5</span>;&#125;;<br><span class="hljs-keyword">boolean</span> test = predicate.test(<span class="hljs-string">&quot;hello&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;result : &quot;</span> + test);<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20200618131601419.png"></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Function</tag>
        <tag>Consumer</tag>
        <tag>Predicate</tag>
      </tags>
  </entry>
  <entry>
    <title>你想了解的分布式文件系统HDFS,看这一篇就够了</title>
    <url>/2020/12/09/%E4%BD%A0%E6%83%B3%E4%BA%86%E8%A7%A3%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9FHDFS-%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    <content><![CDATA[<h1 id="1、分布式文件系统"><a href="#1、分布式文件系统" class="headerlink" title="1、分布式文件系统"></a>1、分布式文件系统</h1><h2 id="计算机集群结构"><a href="#计算机集群结构" class="headerlink" title="计算机集群结构"></a>计算机集群结构</h2><p>分布式文件系统把文件分布存储到多个节点（计算机）上，成千上万的计算机节点构成计算机集群。</p>
<p>分布式文件系统使用的计算机集群，其配置都是由普通硬件构成的，与用多个处理器和专用高级硬件的并行化处理装置相比，前者大大降低了硬件上的开销。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614135454473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="分布式文件系统的结构"><a href="#分布式文件系统的结构" class="headerlink" title="分布式文件系统的结构"></a>分布式文件系统的结构</h2><p>分布式文件系统在物理结构上是由众多阶段及节点构成的，而这些节点中分为两类。一类是主节点（Master Node），又被称为名称节点（NameNode），另一类是从节点（Slave Node），又被称为数据节点（DataNode）。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614141133269.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="2、HDFS简介"><a href="#2、HDFS简介" class="headerlink" title="2、HDFS简介"></a>2、HDFS简介</h1><p>官方用户指南：<a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html">http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsUserGuide.html</a></p>
<p>Hadoop是由HDFS和MapReduce两大组件组成的，HDFS全称为Hadoop Distributed File System（Hadoop 分布式文件系统）。</p>
<p>它和现有的分布式文件系统有很多共同点。但同时，它和其他的分布式文件系统的区别也是很明显的。HDFS是一个高度容错性的系统，适合部署在廉价的机器上。HDFS能提供高吞吐量的数据访问，非常适合大规模数据集上的应用。</p>
<p>HDFS要实现的目标：</p>
<ul>
<li><strong>兼容廉价的硬件设备</strong></li>
<li><strong>流数据读写</strong></li>
<li><strong>大数据集</strong></li>
<li><strong>简单的文件类型</strong></li>
<li><strong>强大的跨平台兼容性</strong></li>
</ul>
<p>HDFS局限性：</p>
<ul>
<li>不适合低延迟数据访问</li>
<li>无法高效存储大量小文件（与自身实现有关）</li>
<li>不支持多用户写入及任意修改文件</li>
</ul>
<h1 id="3、HDFS相关概念"><a href="#3、HDFS相关概念" class="headerlink" title="3、HDFS相关概念"></a>3、HDFS相关概念</h1><h2 id="块"><a href="#块" class="headerlink" title="块"></a>块</h2><p>“块”在HDFS中作为最小存储单位，默认一个块为64MB。在HDFS中，一个文件将会被分割成多个块，保存到各个数据节点。块的大小远远高于普通文件系统，可以最小化寻址开销。</p>
<p>HDFS中抽象的块模型可以带来如下好处：</p>
<ul>
<li><strong>支持大规模文件存储</strong></li>
</ul>
<p>单个文件被分成若干个块，分别存储到若干个数据节点中，其文件大小不会受到单个节点容量的限制。</p>
<ul>
<li><strong>简化系统设计</strong></li>
</ul>
<p>文件块大小是固定的，可以很容易计算出一个节点中可以存储多少个文件块。方便了元数据的管理，元数据不需要和文件块一起保存，可以由其它系统负责管理元数据。</p>
<ul>
<li><strong>适合数据备份</strong></li>
</ul>
<p>每个文件块都可以冗余的存储到多个数据节点上，当一个节点数据出错时，就可以根据其他副本节点恢复数据。大大提高了系统的容错性与高可用性。</p>
<h2 id="名称节点（NameNode）和数据节点-DataNode"><a href="#名称节点（NameNode）和数据节点-DataNode" class="headerlink" title="名称节点（NameNode）和数据节点(DataNode)"></a>名称节点（NameNode）和数据节点(DataNode)</h2><p><img src="https://img-blog.csdnimg.cn/20200614144546843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> NameNode与SecondaryNameNode同为“名称节点”。SecondaryNameNode作为二级名称节点，它与NameNode的关系是：SecondaryNameNode是NameNode的冷备份。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
<th>位置</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>NameNode</td>
<td>存储元数据</td>
<td>元数据保存在内存中</td>
<td>保存文件、block、DataNode之间的映射关系</td>
</tr>
<tr>
<td>DataNode</td>
<td>存储文件内容</td>
<td>文件内容保存到磁盘</td>
<td>维护了block id到DataNode本地文件的映射关系</td>
</tr>
</tbody></table>
<h2 id="名称节点的数据结构"><a href="#名称节点的数据结构" class="headerlink" title="名称节点的数据结构"></a>名称节点的数据结构</h2><p>在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间 （Namespace），保存了两个核心的数据结构，即FsImage和EditLog 。名称节点记录了每个文件中各个块所在的数据节点的位置信息。</p>
<ul>
<li>FsImage</li>
</ul>
<p>用于维护文件系统树以及文件树中所有的文件和文件夹的元数据 。</p>
<ul>
<li>EditLog</li>
</ul>
<p>操作日志文件，其中记录了所有针对文件的创建、删除、重命名等操作 。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614151116386.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="FsImage"><a href="#FsImage" class="headerlink" title="FsImage"></a>FsImage</h2><p>FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一 个文件或目录的元数据的内部表示，并包含此类信息：文件的复制等级、修改和访问 时间、访问权限、块大小以及组成文件的块。对于目录，则存储修改时间、权限和配 额元数据 。</p>
<p>FsImage文件没有记录块存储在哪个数据节点。而是由名称节点把这些映射保留在 内存中，当数据节点加入HDFS集群时，数据节点会把自己所包含的块列表告知给名 称节点，此后会定期执行这种告知操作，以确保名称节点的块映射是最新的。</p>
<h2 id="名称节点的启动"><a href="#名称节点的启动" class="headerlink" title="名称节点的启动"></a>名称节点的启动</h2><p>在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行 EditLog文件中的各项操作，使得内存中的元数据和实际的同步，存在内存中的元数 据支持客户端的读操作。</p>
<p>一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件。</p>
<p>名称节点起来之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage 文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添 加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样 ，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前， edits文件都需要同步更新。</p>
<h2 id="名称节点运行期间EditLog不断变大的问题"><a href="#名称节点运行期间EditLog不断变大的问题" class="headerlink" title="名称节点运行期间EditLog不断变大的问题"></a>名称节点运行期间EditLog不断变大的问题</h2><p>在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文 件将会变得很大 。</p>
<p>虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点 需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用。</p>
<p>名称节点运行期间EditLog不断变大的问题，如何解决？答案是：SecondaryNameNode<strong>第二名称节点</strong>。</p>
<p>第二名称节点是HDFS架构中的一个组成部分，它是用来保存名称节点中对HDFS元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上。</p>
<p>SecondaryNameNode的工作情况：</p>
<p>（1）SecondaryNameNode会定期和NameNode 通信，请求其停止使用EditLog文件，暂时将新的写操作写到一个新的文件edit.new上来，这个操作是瞬间完成，上层写日志的函数完全感觉不到差别。</p>
<p>（2）SecondaryNameNode通过HTTP GET方式从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下。</p>
<p>（3）SecondaryNameNode将下载下来的FsImage载入到内存，然后一条一条地执行EditLog文件中的各项更新操作，使得内存中的 FsImage保持最新；这个过程就是EditLog和 FsImage文件合并。</p>
<p>（4）SecondaryNameNode执行完（3）操作之后，会通过post方式将新的FsImage文件发送到NameNode节点上 。</p>
<p>（5）NameNode将从SecondaryNameNode接收到的新的FsImage替换旧的FsImage文件， 同时将edit.new替换EditLog文件，通过这个过程EditLog就变小了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614153302381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="数据节点（DataNode）"><a href="#数据节点（DataNode）" class="headerlink" title="数据节点（DataNode）"></a>数据节点（DataNode）</h2><p>数据节点是分布式文件系统HDFS的工作节点，负责数据的存储和读取，会根据客 户端或者是名称节点的调度来进行数据的存储和检索，并且向名称节点定期发送自己 所存储的块的列表 。</p>
<p>每个数据节点中的数据会被保存在各自节点的本地Linux文件系统中。</p>
<h1 id="4、HDFS体系结构"><a href="#4、HDFS体系结构" class="headerlink" title="4、HDFS体系结构"></a>4、HDFS体系结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HDFS采用了主从（Master/Slave）结构模型，一个HDFS集群包括一个名称节点（ NameNode）和若干个数据节点（DataNode）。名称节点作为中心服务器， 负责管理文件系统的命名空间及客户端对文件的访问。集群中的数据节点一般是一个节点运行 一个数据节点进程，负责处理文件系统客户端的读/写请求，在名称节点的统一调度下进行数据 块的创建、删除和复制等操作。每个数据节点的数据实际上是保存在本地Linux文件系统中的。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614155053316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="HDFS命名空间管理"><a href="#HDFS命名空间管理" class="headerlink" title="HDFS命名空间管理"></a>HDFS命名空间管理</h2><p>HDFS的命名空间包含目录、文件和块。</p>
<p>在HDFS1.0体系结构中，在整个HDFS集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理 。</p>
<p>HDFS使用的是传统的分级文件体系，因此，用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件，重命名文件等。</p>
<h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><p>HDFS是一个部署在集群上的分布式文件系统，因此，很多数据需要通过网络进行传输。</p>
<p>所有的HDFS通信协议都是构建在TCP/IP协议基础之上的。</p>
<p>客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与 名称节点进行交互。 </p>
<p>名称节点和数据节点之间则使用数据节点协议进行交互。</p>
<p>客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设 计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>客户端是用户操作HDFS最常用的方式，HDFS在部署时都提供了客户端。</p>
<p>HDFS客户端是一个库，暴露了HDFS文件系统接口，这些接口隐藏了HDFS实现中的大部分复杂性。 </p>
<p>严格来说，客户端并不算是HDFS的一部分。</p>
<p>客户端可以支持打开、读取、写入等常见的操作，并且提供了类似Shell的命令行方式来访问HDFS中的数据</p>
<p>此外，HDFS也提供了Java API，作为应用程序访问文件系统的客户端编程接口。</p>
<h2 id="HDFS体系结构的局限性"><a href="#HDFS体系结构的局限性" class="headerlink" title="HDFS体系结构的局限性"></a>HDFS体系结构的局限性</h2><p>HDFS只设置唯一一个名称节点，这样做虽然大大简化了系统设计，但也带来了一些 明显的局限性，具体如下：</p>
<p>（1）命名空间的限制：名称节点是保存在内存中的，因此，名称节点能够容纳的 对象（文件、块）的个数会受到内存空间大小的限制。</p>
<p>（2）性能的瓶颈：整个分布式文件系统的吞吐量，受限于单个名称节点的吞吐量。</p>
<p>（3）隔离问题：由于集群中只有一个名称节点，只有一个命名空间，因此，无法 对不同应用程序进行隔离。</p>
<p>（4）集群的可用性：一旦这个唯一的名称节点发生故障，会导致整个集群变得不 可用。</p>
<h1 id="5、HDFS存储原理"><a href="#5、HDFS存储原理" class="headerlink" title="5、HDFS存储原理"></a>5、HDFS存储原理</h1><h2 id="冗余数据保存"><a href="#冗余数据保存" class="headerlink" title="冗余数据保存"></a>冗余数据保存</h2><p>作为一个分布式文件系统，为了保证系统的容错性和可用性，HDFS采用了多副 本方式对数据进行冗余存储，通常一个数据块的多个副本会被分布到不同的数据节点 上，如图所示，数据块1被分别存放到数据节点A和C上，数据块2被存放在数据节 点A和B上。</p>
<p>这种多副本方式具有以下几个优点：</p>
<p>（1）加快数据传输速度。</p>
<p>（2）容易检查数据错误。</p>
<p>（3）保证数据可靠性。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614160824515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="数据存取策略"><a href="#数据存取策略" class="headerlink" title="数据存取策略"></a>数据存取策略</h2><h3 id="数据存放"><a href="#数据存放" class="headerlink" title="数据存放"></a>数据存放</h3><p>Block的副本放置策略：</p>
<p>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘 不太满、CPU不太忙的节点。</p>
<p>第二个副本：放置在与第一个副本不同的机架的节点上。</p>
<p>第三个副本：与第一个副本相同机架的其他节点上。</p>
<p>更多副本：随机节点。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614161001800.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API 获取自己所属的机架ID。</p>
<p>当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包 含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID， 当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。</p>
<h2 id="数据错误与恢复"><a href="#数据错误与恢复" class="headerlink" title="数据错误与恢复"></a>数据错误与恢复</h2><p>HDFS具有较高的容错性，可以兼容廉价的硬件，它把硬件出错看作一种常态， 而不是异常，并设计了相应的机制检测数据错误和进行自动恢复，主要包括以下几种 情形：名称节点出错、数据节点出错和数据出错。</p>
<h3 id="名称节点出错"><a href="#名称节点出错" class="headerlink" title="名称节点出错"></a>名称节点出错</h3><p>名称节点保存了所有的元数据信息，其中，最核心的两大数据结构是FsImage和Editlog，如果这两个文件发生损坏，那么整个HDFS实例将失效。因此，HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。</p>
<h3 id="数据节点出错"><a href="#数据节点出错" class="headerlink" title="数据节点出错"></a>数据节点出错</h3><p>每个数据节点会定期向名称节点发送“心跳”信息，向名称节点报告自己的状态。</p>
<p>当数据节点发生故障，或者网络发生断网时，名称节点就无法收到来自一些数据节点的心跳信息，这时，这些数据节点就会被标记为“宕机”，节点上面的所有数据都会被标记为“不可读”，名称节点不会再给它们发送任何I/O请求。</p>
<p>这时，有可能出现一种情形，即由于一些数据节点的不可用，会导致一些数据块的副本数量小于冗余因子。 </p>
<p>名称节点会定期检查这种情况，一旦发现某个数据块的副本数量小于冗余因子，就会启动数据冗余复制，为它生成新的副本。 </p>
<p>HDFS和其它分布式文件系统的最大区别就是可以调整冗余数据的位置。</p>
<h3 id="数据出错"><a href="#数据出错" class="headerlink" title="数据出错"></a>数据出错</h3><p>网络传输和磁盘错误等因素，都会造成数据错误。 </p>
<p>客户端在读取到数据后，会采用md5和sha1对数据块进行校验，以确定读取到正确的数据。 </p>
<p>在文件被创建时，客户端就会对每一个文件块进行信息摘录，并把这些信息写入到同一个路径的隐藏文件里面。 </p>
<p>当客户端读取文件的时候，会先读取该信息文件，然后，利用该信息文件对每个读 取的数据块进行校验，如果校验出错，客户端就会请求到另外一个数据节点读取该文件块，并且向名称节点报告这个文件块有错误，名称节点会定期检查并且重新复制这个块。</p>
<h1 id="6、HDFS读写过程"><a href="#6、HDFS读写过程" class="headerlink" title="6、HDFS读写过程"></a>6、HDFS读写过程</h1><p>FileSystem是一个通用文件系统的抽象基类，可以被分布式文件系统继承，所有可能使用 Hadoop文件系统的代码，都要使用这个类。</p>
<p>Hadoop为FileSystem这个抽象类提供了多种具体实现。</p>
<p>DistributedFileSystem就是FileSystem在HDFS文件系统中的具体实现。</p>
<p>FileSystem的open()方法返回的是一个输入流FSDataInputStream对象，在HDFS文件系统中 ，具体的输入流就是DFSInputStream；FileSystem中的create()方法返回的是一个输出流 FSDataOutputStream对象，在HDFS文件系统中，具体的输出流就是DFSOutputStream。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Configuration conf = <span class="hljs-keyword">new</span> Configuration();<br>FileSystem fs = FileSystem.get(conf);<br>FSDataInputStream in = fs.open(<span class="hljs-keyword">new</span> Path(uri));<br>FSDataOutputStream out = fs.create(<span class="hljs-keyword">new</span> Path(uri));<br></code></pre></td></tr></table></figure>

<p>备注：创建一个Configuration对象时，其构造方法会默认加载工程项目下两个配置文件，分别是 hdfs-site.xml以及core-site.xml，这两个文件中会有访问HDFS所需的参数值，主要是 fs.defaultFS，指定了HDFS的地址（比如hdfs://localhost:9000），有了这个地址客户端就可以 通过这个地址访问HDFS了。</p>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader ;<br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration ;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem ;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path ;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FSDataInputStream ;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chapter3</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Configuration conf = <span class="hljs-keyword">new</span> Configuration();<br>			FileSystem fs = FileSystem.get(conf);<br>			Path filename = <span class="hljs-keyword">new</span> Path(“hdfs:<span class="hljs-comment">//localhost:9000/user/hadoop/test.txt&quot;);</span><br>			FSDataInputStream is = fs.open(filename);<br>			BufferedReader d = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(is));<br>			String content = d.readLine(); <span class="hljs-comment">//读取文件一行</span><br>			System.out.println(content);<br>			d.close(); <span class="hljs-comment">//关闭文件</span><br>			fs.close(); <span class="hljs-comment">//关闭hdfs</span><br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200614162412445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chapter3</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Configuration conf = <span class="hljs-keyword">new</span> Configuration();<br>			FileSystem fs = FileSystem.get(conf);<br>			<span class="hljs-keyword">byte</span>[] buff = <span class="hljs-string">&quot;Hello world&quot;</span>.getBytes(); <span class="hljs-comment">// 要写入的内容</span><br>			String filename = <span class="hljs-string">&quot; hdfs://localhost:9000/user/hadoop/test.txt &quot;</span>; <span class="hljs-comment">//要写入的文件名</span><br>			FSDataOutputStream os = fs.create(<span class="hljs-keyword">new</span> Path(filename));<br>			os.write(buff,<span class="hljs-number">0</span>,buff.length);<br>			System.out.println(<span class="hljs-string">&quot;Create:&quot;</span>+ filename);<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200614162551879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="7、HDFS编程实践"><a href="#7、HDFS编程实践" class="headerlink" title="7、HDFS编程实践"></a>7、HDFS编程实践</h1><h2 id="首先启动hadoop"><a href="#首先启动hadoop" class="headerlink" title="首先启动hadoop"></a>首先启动hadoop</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">$ cd /usr/local/hadoop<br>$ ./bin/hdfs namenode -format  # 格式化hdfs文件系统，初始化时使用，之前执行后就不需再执行<br>$ ./bin/start-dfs.sh<br></code></pre></td></tr></table></figure>

<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>HDFS有很多shell命令，其中，fs命令可以说是HDFS最常用的命令。利用该命令可以 查看HDFS文件系统的目录结构、上传和下载数据、创建文件等。</p>
<p>该命令的用法为： hadoop fs [genericOptions] [commandOptions]</p>
<p>备注：Hadoop中有三种Shell命令方式：</p>
<ol>
<li>hadoop fs适用于任何不同的文件系统，比如本地文件系统和HDFS文件系统。</li>
<li>hadoop dfs只能适用于HDFS文件系统。</li>
<li>hdfs dfs跟hadoop dfs的命令作用一样，也只能适用于HDFS文件系统。</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>hadoop fs -ls <path>:显示<path>指定的文件的详细信息</p>
<p>hadoop fs -mkdir <path>:创建<path>指定的文件夹</p>
<p><strong>例中“./”表示“/usr/local/hadoop/bin”路径。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/2020061417253919.png"></p>
<p>hadoop fs -cat <path>:将<path>指定的文件的内容输出到标准输出（stdout）</p>
<p>hadoop fs -copyFromLocal <localsrc> <dst>:将本地源文件<localsrc>复制到路径<dst>指定的文件或文件夹中</p>
<p> <img src="https://img-blog.csdnimg.cn/20200614173511725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="WEB管理界面"><a href="#WEB管理界面" class="headerlink" title="WEB管理界面"></a>WEB管理界面</h2><p><a href="http://ip:50070,默认端口50070">http://ip:50070,默认端口50070</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200614174032631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="利用Java-API与HDFS进行交互"><a href="#利用Java-API与HDFS进行交互" class="headerlink" title="利用Java API与HDFS进行交互"></a>利用Java API与HDFS进行交互</h2><p>maven项目中引入</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependencies&gt;<br>	&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.apache.hadoop/hadoop-common --&gt;</span><br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>		&lt;artifactId&gt;hadoop-common&lt;/artifactId&gt;<br>		&lt;version&gt;2.6.0&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.apache.hadoop/hadoop-hdfs --&gt;</span><br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>		&lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt;<br>		&lt;version&gt;2.6.0&lt;/version&gt;<br>	&lt;/dependency&gt;<br>	&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.apache.hadoop/hadoop-client --&gt;</span><br>	&lt;dependency&gt;<br>		&lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt;<br>		&lt;artifactId&gt;hadoop-client&lt;/artifactId&gt;<br>		&lt;version&gt;2.6.0&lt;/version&gt;<br>	&lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure>

<p> 写一个FileSystem获取工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.hdfs;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.conf.Configuration;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 单例模式生成FileSystem</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystemFactory</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSystemFactoryHolder</span></span>&#123;<br>		<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileSystem instance;<br>        <br>        <span class="hljs-keyword">static</span> &#123;<br>        	Configuration conf = <span class="hljs-keyword">new</span> Configuration();<br>                conf.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>,<span class="hljs-string">&quot;hdfs://172.20.10.6:9000&quot;</span>);<br>                conf.set(<span class="hljs-string">&quot;fs.hdfs.impl&quot;</span>, <span class="hljs-string">&quot;org.apache.hadoop.hdfs.DistributedFileSystem&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>			instance = FileSystem.get(conf);<br>	        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>		        e.printStackTrace();<br>	        &#125;<br>            &#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> FileSystem <span class="hljs-title">getInsatnce</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> FileSystemFactoryHolder.instance;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>实例：利用hadoop 的java api检测伪分布式文件系统HDFS上是否存在某个文件？</strong></p>
<p>其中172.20.10.6是我hadoop机器上的ip地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.hdfs;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HdfsExists</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			String filename = <span class="hljs-string">&quot;/user/hadoop/input&quot;</span>;<br>			FileSystem fs = FileSystemFactory.getInsatnce();<br>			<span class="hljs-keyword">if</span>(fs.exists(<span class="hljs-keyword">new</span> Path(filename)))&#123;<br>				System.out.println(<span class="hljs-string">&quot;文件存在&quot;</span>);<br>			&#125;<span class="hljs-keyword">else</span>&#123;<br>				System.out.println(<span class="hljs-string">&quot;文件不存在&quot;</span>);<br>			&#125;<br>			fs.close();<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200614190816697.png"></p>
<p> 验证一下是否存在：</p>
<p><img src="https://img-blog.csdnimg.cn/20200614190952296.png"></p>
<p><strong>实例：写HDFS上的文件？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.hdfs;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FSDataOutputStream;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HdfsWrite</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			FileSystem fs = FileSystemFactory.getInsatnce();<br>			<span class="hljs-keyword">byte</span>[] buff = <span class="hljs-string">&quot;Hello world!&quot;</span>.getBytes(); <span class="hljs-comment">// 要写入的内容</span><br>			String filename = <span class="hljs-string">&quot;/user/22113/test&quot;</span>; <span class="hljs-comment">//要写入的文件名</span><br>			FSDataOutputStream os = fs.create(<span class="hljs-keyword">new</span> Path(filename));<br>			os.write(buff,<span class="hljs-number">0</span>,buff.length);<br>			System.out.println(<span class="hljs-string">&quot;Create:&quot;</span>+ filename);<br>			os.close();<br>			fs.close();<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200614201419346.png"></p>
<p><strong>实例：读HDFS上的文件？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.hdfs;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FSDataInputStream;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.FileSystem;<br><span class="hljs-keyword">import</span> org.apache.hadoop.fs.Path;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HdfsRead</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			FileSystem fs = FileSystemFactory.getInsatnce();<br>                        String filename = <span class="hljs-string">&quot;/user/22113/test.txt&quot;</span>; <span class="hljs-comment">//要读的文件名</span><br>                        FSDataInputStream in = fs.open(<span class="hljs-keyword">new</span> Path(filename));<br>                        BufferedReader bis = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(in));<br>                        System.out.println(bis.readLine());<br>                        bis.close();<br>                        fs.close();<br>		&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200614203059291.png"></p>
<p>常见错误：</p>
<ul>
<li>java.net.ConnectException</li>
</ul>
<p>Connection refused: no further information</p>
<p>此例环境：windows中安装虚拟机运行Hadoop。由于hadoop中core-site.xml中设置的fs.defaultFS是hdfs://localhost:9000，所以报错，应该将lcoalhost替换成自己虚拟机分配的ip地址，之后重启hadoop。</p>
<ul>
<li>记得开启对应的虚拟机端口，端口未开启会报错。《<a href="https://blog.csdn.net/qq_37171817/article/details/106731470">CentOS7 中开放端口</a>》</li>
<li>org.apache.hadoop.security.AccessControlException</li>
</ul>
<p>Permission denied: user=22113, access=WRITE, inode=”/user/hadoop”:hadoop:supergroup:drwxr-xr-x</p>
<p>没有写入权限，应该设置该文件夹权限。</p>
<p><img src="https://img-blog.csdnimg.cn/20200614193902416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>文件权限由读、可执行变成读、写、可执行。现在/user/22113文件夹皆可以写入内容了。</p>
<ul>
<li>org.apache.hadoop.ipc.RemoteException(java.io.IOException)</li>
</ul>
<p>File /user/22113/test.txt could only be replicated to 0 nodes instead of minReplication (=1).  There are 1 datanode(s) running and 1 node(s) are excluded in this operation.</p>
<p>这个错误从网上找了很久，都没解决。有人说是DataNode没启动，但是我用jps命令查看，发现DataNode是在运行。还有人说是format多次NameNode与DataNode导致的，可是这都不是原因。后来突然想起关闭虚拟机防火墙，发现就可以了，功能正常运作，具体原因待分析。</p>
<h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>本文是根据中国大学MOOC网站上，课程《<a href="https://www.icourse163.org/course/XMU-1002335004">大数据技术原理与应用</a>》的课件ppt撰写的一篇博文。由于自己也是正在跟着这门课进行学习，所以很多专业性知识点都是截取课件ppt上的内容。顺便推荐一下这门课程，老师讲解的知识点非常细致，还有对操作步骤详细记录的博客资源。</p>
<p>感谢厦门大学数据库实验室，感谢林子雨老师提供的这么优秀的资源。</p>
]]></content>
      <categories>
        <category>文件系统</category>
      </categories>
      <tags>
        <tag>分布式文件系统</tag>
        <tag>HDFS</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式处理框架Hadoop的安装与使用</title>
    <url>/2020/12/09/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6Hadoop%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Hadoop简介"><a href="#Hadoop简介" class="headerlink" title="Hadoop简介"></a>Hadoop简介</h1><p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。</p>
<p>充分利用集群的威力进行高速运算和存储。Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称</p>
<p>HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）</p>
<p>来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以</p>
<p>流的形式访问（streaming access）文件系统中的数据。Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海</p>
<p>量的数据提供了存储，而MapReduce则为海量的数据提供了计算 。</p>
<p><img src="https://img-blog.csdnimg.cn/2020061315022075.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h1><p>CentOS7。</p>
<p>安装指南：《<a href="https://blog.csdn.net/qq_37171817/article/details/106713868">VMware安装Centos7并联网使用</a>》</p>
<h1 id="一、新建hadoop用户"><a href="#一、新建hadoop用户" class="headerlink" title="一、新建hadoop用户"></a>一、新建hadoop用户</h1><p>1、以root用户登录虚拟机，创建用户hadoop</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ useradd -m hadoop -s /bin/bash   <span class="hljs-comment"># 创建新用户hadoop</span><br>$ passwd hadoop   <span class="hljs-comment">#设置密码</span><br></code></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200613094448127.png"></p>
<p>2、为hadoop用户添加管理员权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ visudo<br></code></pre></td></tr></table></figure>

<p>出现以下内容</p>
<p><img src="https://img-blog.csdnimg.cn/20200613095723444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>按下键盘上的esc键，输入“:98”(先输入冒号，再输入98)，便于快速定位到98行。按下键盘上的i，进入插入模式。</p>
<p>添加如下内容，空格就是一个tab键。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613095950346.png"></p>
<p> 最后按下esc键，输入“:wq”（先输入冒号，再输入wq），意为保存并退出。</p>
<p>执行exit，退出root状态，重新以hadoop用户登录。</p>
<h1 id="二、安装SSH、配置SSH无密码登录"><a href="#二、安装SSH、配置SSH无密码登录" class="headerlink" title="二、安装SSH、配置SSH无密码登录"></a>二、安装SSH、配置SSH无密码登录</h1><p>SSH 是较可靠，专为远程登录会话和其他网络服务提供安全性的协议。使用SSH，还有一个额外的好处就是传输的数据是经过压</p>
<p>缩的，所以可以加快传输的速度。</p>
<p>一般情况下，CentOS已经默认帮你安装好了ssh-clients、ssh-server，不需要再额外进行安装。</p>
<p>可以使用shell命令，查看你本机的ssh安装情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ rpm -qa | grep ssh<br></code></pre></td></tr></table></figure>

<p> 如果结果如下，包含了ssh-clients、ssh-server，说明已经安装好了，不需要额外安装。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613101405606.png"></p>
<p> 如果未安装，可以通过yum进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo yum install openssh-clients<br>$ sudo yum install openssh-server<br></code></pre></td></tr></table></figure>

<p>执行命令，查看ssh是否可用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ ssh localhost<br></code></pre></td></tr></table></figure>

<p>首次登录会有提示：</p>
<p><img src="https://img-blog.csdnimg.cn/20200613101904961.png"></p>
<p>输入yes，按照提示输入密码，就可以登录到本机。但是这样连接每次都需要输入密码。配置成无密码登录比较方便。</p>
<p>利用ssh-keygen生成密钥，并将密钥添加到授权信息中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh/                     <span class="hljs-comment"># 若没有该目录，请先执行一次ssh localhost</span><br>ssh-keygen -t rsa              <span class="hljs-comment"># 会有提示，都按回车就可以</span><br>cat id_rsa.pub &gt;&gt; authorized_keys  <span class="hljs-comment"># 加入授权</span><br>chmod 600 ./authorized_keys    <span class="hljs-comment"># 修改文件权限</span><br></code></pre></td></tr></table></figure>

<p> 需要键入内容地方直接回车。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613102738497.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>我们再次使用ssh localhost，就可以直接登录了。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613102852842.png"></p>
<h1 id="三、安装java环境"><a href="#三、安装java环境" class="headerlink" title="三、安装java环境"></a>三、安装java环境</h1><p>下载jdk-8u51-linux-x64.tar.gz压缩包到/home/hadoop/download文件夹，并解压缩到/usr/lib/jvm文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ tar -zxf ~/download/jdk-8u51-linux-x64.tar.gz -C /usr/lib/jvm<br></code></pre></td></tr></table></figure>

<p>编辑环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>添加JAVA_HOME：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.8.0_51<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin<br></code></pre></td></tr></table></figure>

<p>让环境变量生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>查看java版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ java -version<br></code></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200620160543973.png"></p>
<p>检验环境变量是否正确：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$JAVA_HOME</span>     <span class="hljs-comment"># 检验变量值</span><br>$ java -version<br>$ <span class="hljs-variable">$JAVA_HOME</span>/bin/java -version  <span class="hljs-comment"># 与直接执行 java -version 一样</span><br></code></pre></td></tr></table></figure>

<p> <img src="https://img-blog.csdnimg.cn/20200620161420479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="四、安装Hadoop2"><a href="#四、安装Hadoop2" class="headerlink" title="四、安装Hadoop2"></a>四、安装Hadoop2</h1><p>镜像仓库：</p>
<p><a href="https://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.7.7/">https://mirrors.cnnic.cn/apache/hadoop/common/hadoop-2.7.7/</a></p>
<p><a href="http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.7.7/">http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.7.7/</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200613123223856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>下载“*.tar.gz”，-src文件是Hadoop的源码。</p>
<p>将下载的tar.gz文件放到/usr/hadoop/download下。</p>
<p>执行命令解压修改hadoop文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ sudo tar -zxf ~/download/hadoop-2.7.7.tar.gz -C /usr/<span class="hljs-built_in">local</span>    <span class="hljs-comment"># 解压到/usr/local中</span><br>$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/<br>$ sudo mv ./hadoop-2.7.7/ ./hadoop            <span class="hljs-comment"># 将文件夹名改为hadoop</span><br>$ sudo chown -R hadoop:hadoop ./hadoop        <span class="hljs-comment"># 修改文件权限</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613125224999.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>查看hadoop版本信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoop<br>$ ./bin/hadoop version<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613125346566.png"></p>
<h1 id="五、Hadoop单机配置-非分布式"><a href="#五、Hadoop单机配置-非分布式" class="headerlink" title="五、Hadoop单机配置(非分布式)"></a>五、Hadoop单机配置(非分布式)</h1><p>Hadoop 默认模式为非分布式模式，无需进行其他配置即可运行。非分布式即单 Java 进程，方便进行调试。</p>
<p>现在我们可以执行例子来感受下 Hadoop 的运行。Hadoop 附带了丰富的例子（运行 /usr/local/hadoop/bin/hadoop jar</p>
<p>/usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar可以看到所有例子），包括</p>
<p>wordcount、terasort、join、grep 等。</p>
<p>在此我们选择运行 grep 例子，我们将 input 文件夹中的所有文件作为输入，筛选当中符合正则表达式dfs[a-z.]+的单词并统计出</p>
<p>现的次数，最后输出结果到 output 文件夹中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoop<br>$ mkdir ./input<br>$ cp ./etc/hadoop/*.xml ./input   <span class="hljs-comment"># 将配置文件作为输入文件</span><br>$ ./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar grep ./input ./output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span><br>$ cat ./output/*          <span class="hljs-comment"># 查看运行结果</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613130407617.png"></p>
<p> <img src="https://img-blog.csdnimg.cn/20200613130506485.png"></p>
<p><strong>注意:</strong> Hadoop 默认不会覆盖结果文件，因此再次运行上面实例会提示出错，需要先将./output删除。</p>
<p>删除输出文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ rm -r ./output<br></code></pre></td></tr></table></figure>

<h1 id="六、Hadoop伪分布式配置"><a href="#六、Hadoop伪分布式配置" class="headerlink" title="六、Hadoop伪分布式配置"></a>六、Hadoop伪分布式配置</h1><p>Hadoop 可以在单节点上以伪分布式的方式运行，Hadoop 进程以分离的 Java 进程来运行，节点既作为 NameNode 也作为</p>
<p>DataNode，同时，读取的是 HDFS 中的文件。</p>
<p>在设置 Hadoop 伪分布式配置前，我们还需要设置 HADOOP 环境变量，执行如下命令在 ~/.bashrc 中设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>在文件最后面增加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Hadoop Environment Variables</span><br><span class="hljs-built_in">export</span> HADOOP_HOME=/usr/<span class="hljs-built_in">local</span>/hadoop<br><span class="hljs-built_in">export</span> HADOOP_INSTALL=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_MAPRED_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_COMMON_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_HDFS_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> YARN_HOME=<span class="hljs-variable">$HADOOP_HOME</span><br><span class="hljs-built_in">export</span> HADOOP_COMMON_LIB_NATIVE_DIR=<span class="hljs-variable">$HADOOP_HOME</span>/lib/native<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$HADOOP_HOME</span>/sbin:<span class="hljs-variable">$HADOOP_HOME</span>/bin<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200620161947380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>使文件生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>

<p>Hadoop 的配置文件位于 /usr/local/hadoop/etc/hadoop/中，伪分布式需要修改2个配置文件 <strong>core-site.xml</strong> 和 <strong>hdfs-</strong></p>
<p><strong>site.xml</strong> 。</p>
<p>Hadoop的配置文件是 xml 格式，每个配置以声明 property 的 name 和 value 的方式来实现。</p>
<p>修改<strong>core-site.xml</strong>文件：</p>
<p>将<configuration></configuration>替换成如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;configuration&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;<br>        &lt;value&gt;file:/usr/<span class="hljs-built_in">local</span>/hadoop/tmp&lt;/value&gt;<br>        &lt;description&gt;Abase <span class="hljs-keyword">for</span> other temporary directories.&lt;/description&gt;<br>    &lt;/property&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;fs.defaultFS&lt;/name&gt;<br>        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;<br>    &lt;/property&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure>

<p>修改<strong>hdfs-site.xml</strong>文件：</p>
<p>将<configuration></configuration>替换成如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;configuration&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;dfs.replication&lt;/name&gt;<br>        &lt;value&gt;1&lt;/value&gt;<br>    &lt;/property&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;<br>        &lt;value&gt;file:/usr/<span class="hljs-built_in">local</span>/hadoop/tmp/dfs/name&lt;/value&gt;<br>    &lt;/property&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;<br>        &lt;value&gt;file:/usr/<span class="hljs-built_in">local</span>/hadoop/tmp/dfs/data&lt;/value&gt;<br>    &lt;/property&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure>

<p>配置完成后，执行 NameNode 的格式化:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs namenode -format<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613133727931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>成功则会显示successfully formatted与Exiting with status 0。失败则会Exiting with status 1。</p>
<p>开启NameNode与DataNode守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/sbin/start-dfs.sh<br></code></pre></td></tr></table></figure>

<p> 出现“Are you sure you want to continue connecting”提示时，输入yes继续执行。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613134242244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>启动完成后，可以通过命令JPS来判断是否成功启动，若成功启动则会列出如下进程: “NameNode”、”DataNode”和</p>
<p>SecondaryNameNode（如果 SecondaryNameNode 没有启动，请运行 sbin/stop-dfs.sh 关闭进程，然后再次尝试启动尝试）。</p>
<p>如果没有 NameNode 或 DataNode ，那就是配置不成功，请仔细检查之前步骤，或通过查看启动日志排查原因。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613134604345.png"></p>
<p><strong>通过查看启动日志分析启动失败原因</strong></p>
<p>有时 Hadoop 无法正确启动，如 NameNode 进程没有顺利启动，这时可以查看启动日志来排查原因，注意几点：</p>
<ul>
<li>启动时会提示形如 “localhost: starting namenode, logging to /usr/local/hadoop/logs/hadoop-hadoop-namenode-localhost.out”，其中 localhost对应你的主机名，但启动的日志信息是记录在 /usr/local/hadoop/logs/hadoop-hadoop-namenode-localhost.log 中，所以应该查看这个后缀为.log的文件；</li>
<li>每一次的启动日志都是追加在日志文件之后，所以得拉到最后面看，看下记录的时间就知道了。</li>
<li>一般出错的提示在最后面，也就是写着 Fatal、Error 或者 Java Exception 的地方。</li>
<li>可以在网上搜索一下出错信息，看能否找到一些相关的解决方法。</li>
</ul>
<p>成功启动后，可以访问 Web 界面<a href="http://localhost:50070查看">http://localhost:50070查看</a> NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。</p>
<p>由于本例中未使用CentOS图形化界面，所以需要在windows浏览器上访问虚拟机中hadoop的web界面。</p>
<p>CentOS7中端口开放请移步《<a href="https://blog.csdn.net/qq_37171817/article/details/106731470">CentOS7 中开放端口</a>》。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613141253260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="七、运行Hadoop伪分布式实例"><a href="#七、运行Hadoop伪分布式实例" class="headerlink" title="七、运行Hadoop伪分布式实例"></a>七、运行Hadoop伪分布式实例</h1><p>上面例子是单机模式，读取的数据是本地文件。伪分布式实例数据来源于HDFS文件系统。要使用HDFS，首先需要在HDFS中创</p>
<p>建用户目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -mkdir -p /user/hadoop<br></code></pre></td></tr></table></figure>

<p>将/usr/local/hadoop/etc/hadoop/下所有xml作为文件复制到hdfs的/user/hadoop/input中。</p>
<p>我们使用的是 hadoop 用户，并且已创建相应的用户目录 /user/hadoop ，因此在命令中就可以使用相对路径如 input，其对应</p>
<p>的绝对路径就是 /user/hadoop/input。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -mkdir input<br>/usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -put /usr/<span class="hljs-built_in">local</span>/hadoop/etc/hadoop/*.xml input<br></code></pre></td></tr></table></figure>

<p>复制完成之后，可以通过命令查看HDFS中文件列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -ls input<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613143336717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 运行MapReduce作业：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/bin/hadoop jar /usr/<span class="hljs-built_in">local</span>/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep input output <span class="hljs-string">&#x27;dfs[a-z.]+&#x27;</span><br></code></pre></td></tr></table></figure>

<p>查看运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -cat output/*<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613144140168.png"></p>
<p>将HDFS中的文件取回到本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ rm -r /usr/<span class="hljs-built_in">local</span>/hadoop/output    <span class="hljs-comment"># 先删除本地的 output 文件夹（如果存在）</span><br>$ /usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -get output /usr/<span class="hljs-built_in">local</span>/hadoop/output     <span class="hljs-comment"># 将 HDFS 上的 output 文件夹拷贝到本机</span><br>cat /usr/<span class="hljs-built_in">local</span>/hadoop/output/*<br></code></pre></td></tr></table></figure>

<p>Hadoop在运行时，输出目录不能存在，如果存在，就会抛出org.apache.hadoop.mapred.FileAlreadyExistsException异常。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613144714831.png"></p>
<p> 所以在运行前，需要删除输出目录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/hadoop/bin/hdfs dfs -rm -r output    <span class="hljs-comment"># 删除 output 文件夹</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613144853931.png"></p>
<p>关闭Hadoop：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/hadoop/sbin/stop-dfs.sh<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong>下次启动 hadoop 时，无需进行 NameNode 的初始化，只需要运行/usr/local/hadoop/sbin/start-dfs.sh就可以！</p>
<h1 id="八、-启动YARN"><a href="#八、-启动YARN" class="headerlink" title="八、 启动YARN"></a>八、 启动YARN</h1><p>新版的 Hadoop 使用了新的 MapReduce 框架（MapReduce V2，也称为 YARN，Yet Another Resource Negotiator）。</p>
<p>YARN 是从 MapReduce 中分离出来的，负责资源管理与任务调度。YARN 运行于 MapReduce 之上，提供了高可用性、高扩展</p>
<p>性。</p>
<p>伪分布式不启动 YARN 也可以，一般不会影响程序执行。</p>
<p>上述通过/usr/local/hadoop/sbin/start-dfs.sh启动 Hadoop，仅仅是启动了 MapReduce 环境，我们可以启动 YARN ，让</p>
<p>YARN 来负责资源管理与任务调度。</p>
<p>修改配置文件<strong>mapred-site.xml：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/hadoop/etc/hadoop  <span class="hljs-comment">#进入配置文件的文件夹</span><br>$ mv ./mapred-site.xml.template ./mapred-site.xml  <span class="hljs-comment">#重命名</span><br>$ vi ./mapred-site.xml  <span class="hljs-comment">#编辑文件</span><br></code></pre></td></tr></table></figure>

<p>将configuration修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;configuration&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;mapreduce.framework.name&lt;/name&gt;<br>        &lt;value&gt;yarn&lt;/value&gt;<br>    &lt;/property&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure>

<p>修改配置文件<strong>yarn-site.xml：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ vi ./yarn-site.xml<br></code></pre></td></tr></table></figure>

<p>将configuration修改如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;configuration&gt;<br>    &lt;property&gt;<br>        &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;<br>        &lt;value&gt;mapreduce_shuffle&lt;/value&gt;<br>        &lt;/property&gt;<br>&lt;/configuration&gt;<br></code></pre></td></tr></table></figure>

<p>启动YARN</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/sbin/start-yarn.sh      $ 启动YARN<br>$ /usr/<span class="hljs-built_in">local</span>/hadoop/sbin/mr-jobhistory-daemon.sh start historyserver  <span class="hljs-comment"># 开启历史服务器，才能在Web中查看任务运行情况</span><br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200613151540386.png"></p>
<p> 通过jps查看，可以看到多了ResourceManager与NodeManager两个进程。</p>
<p><img src="https://img-blog.csdnimg.cn/20200613151645392.png"></p>
<p>启动后，可通过web界面<a href="http://localhost:8088/cluster%E6%9F%A5%E7%9C%8B%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5">http://localhost:8088/cluster查看任务运行情况</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200613152116925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>YARN 主要是为集群提供更好的资源管理与任务调度，然而这在单机上体现不出价值，反而会使程序跑得稍慢些。因此在单机上</p>
<p>是否开启 YARN 就看实际情况了。</p>
<p><strong>注意: 不启动 YARN 需重命名 mapred-site.xml</strong></p>
<p>如果不想启动 YARN，务必把配置文件 <strong>mapred-site.xml</strong> 重命名，改成 mapred-site.xml.template，需要用时改回来就行。否</p>
<p>则在该配置文件存在，而未开启 YARN 的情况下，运行程序会提示 “Retrying connect to server: 0.0.0.0/0.0.0.0:8032” 的错误，</p>
<p>这也是为何该配置文件初始文件名为 mapred-site.xml.template。</p>
<p>关闭YARN</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ /usr/<span class="hljs-built_in">local</span>/hadoop/sbin/stop-yarn.sh<br>$ /usr/<span class="hljs-built_in">local</span>/hadoop/sbin/mr-jobhistory-daemon.sh stop historyserver<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>Hadoop</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7中常用端口命令</title>
    <url>/2020/12/09/CentOS7%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="1、开放端口"><a href="#1、开放端口" class="headerlink" title="1、开放端口"></a>1、开放端口</h2><ul>
<li>开放50070端口</li>
</ul>
<p><strong>firewall-cmd –zone=public –add-port=50070/tcp –permanent</strong> </p>
<ul>
<li>关闭50070端口</li>
</ul>
<p><strong>firewall-cmd –zone=public –remove-port=50070/tcp –permanent</strong> </p>
<ul>
<li>刷新防火墙配置，使修改后的配置立即生效</li>
</ul>
<p><strong>firewall-cmd –reload</strong> </p>
<h2 id="2、查看防火墙所有开放的端口"><a href="#2、查看防火墙所有开放的端口" class="headerlink" title="2、查看防火墙所有开放的端口"></a>2、查看防火墙所有开放的端口</h2><p><strong>firewall-cmd –zone=public –list-ports</strong></p>
<h2 id="3、关闭防火墙"><a href="#3、关闭防火墙" class="headerlink" title="3、关闭防火墙"></a>3、关闭防火墙</h2><p><strong>systemctl stop firewalld.service</strong></p>
<h2 id="4、查看防火墙状态"><a href="#4、查看防火墙状态" class="headerlink" title="4、查看防火墙状态"></a>4、查看防火墙状态</h2><p> <strong>firewall-cmd –state</strong></p>
<h2 id="5、禁止防火墙开机自启动"><a href="#5、禁止防火墙开机自启动" class="headerlink" title="5、禁止防火墙开机自启动"></a><strong>5、禁止防火墙开机自启动</strong></h2><p><strong>systemctl disable firewalld</strong></p>
<h2 id="6、防火墙开机自启动"><a href="#6、防火墙开机自启动" class="headerlink" title="6、防火墙开机自启动"></a><strong>6、防火墙开机自启动</strong></h2><p><strong>systemctl</strong> enable <strong>firewalld</strong></p>
<h2 id="7、查看监听的端口"><a href="#7、查看监听的端口" class="headerlink" title="7、查看监听的端口"></a>7、查看监听的端口</h2><p>centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools</p>
<p><strong>netstat -lnpt</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200613140330570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="8、检查端口被哪个进程占用"><a href="#8、检查端口被哪个进程占用" class="headerlink" title="8、检查端口被哪个进程占用"></a>8、检查端口被哪个进程占用</h2><p><strong>netstat -lnpt | grep 50070</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200613140358162.png"></p>
<h2 id="9、查看进程的详细信息"><a href="#9、查看进程的详细信息" class="headerlink" title="9、查看进程的详细信息"></a>9、查看进程的详细信息</h2><p>ps [pid]</p>
<p><strong>ps 2012</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200613140514622.png"></p>
<h2 id="10、中止进程"><a href="#10、中止进程" class="headerlink" title="10、中止进程"></a>10、中止进程</h2><p>kill -9 [pid]，强制杀死进程。</p>
<p><strong>kill -9 2012</strong></p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>Linux端口</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware安装Centos7并联网使用</title>
    <url>/2020/12/09/VMware%E5%AE%89%E8%A3%85Centos7%E5%B9%B6%E8%81%94%E7%BD%91%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、安装VMware"><a href="#一、安装VMware" class="headerlink" title="一、安装VMware"></a>一、安装VMware</h1><p>VMwareworkstation官方下载地址: <a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html</a></p>
<p>附上VMware Workstation 各版本永久激活密钥：                          </p>
<ul>
<li>v15.5.6：FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6       </li>
<li>v12.5.9：ZC3TK-63GE6-481JY-WWW5T-Z7ATA</li>
<li>v10.0.7：1Z0G9-67285-FZG78-ZL3Q2-234JG</li>
</ul>
<h1 id="二、下载CentOS7"><a href="#二、下载CentOS7" class="headerlink" title="二、下载CentOS7"></a>二、下载CentOS7</h1><p>CentOS官方镜像地址入口：<a href="http://isoredirect.centos.org/centos/7/isos/x86_64/">http://isoredirect.centos.org/centos/7/isos/x86_64/</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200612132958406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 这里有很多镜像仓库的链接地址，我们以阿里云（aliyun）的镜像仓库为例。</p>
<p><img src="https://img-blog.csdnimg.cn/20200612133625430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 我们下载 <a href="http://mirrors.aliyun.com/centos/7.8.2003/isos/x86_64/CentOS-7-x86_64-DVD-2003.iso">CentOS-7-x86_64-DVD-2003.iso</a> 镜像。文件大小大概4个G。</p>
<h1 id="三、创建虚拟机，并安装CentOS7"><a href="#三、创建虚拟机，并安装CentOS7" class="headerlink" title="三、创建虚拟机，并安装CentOS7"></a>三、创建虚拟机，并安装CentOS7</h1><img src="https://img-blog.csdnimg.cn/20200612134400963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom: 50%;" />

 <img src="https://img-blog.csdnimg.cn/20200612134537178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>选择典型，点击下一步。 </p>
 <img src="https://img-blog.csdnimg.cn/20200612134622545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<p>选中安装程序光盘映像文件，选择第二步下载到本地文件夹的iso镜像。点击下一步。 </p>
<img src="https://img-blog.csdnimg.cn/20200612134833644.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>给虚拟机命名，选择创建虚拟机的存放位置，默认是在C盘，但是不建议存放到C盘，因为虚拟机文件一般是比较大的，放在C盘占存储，且容易使电脑变卡顿。 </p>
 <img src="https://img-blog.csdnimg.cn/2020061213502126.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p> 根据电脑性能，可自定义此虚拟机使用的磁盘容量。</p>
 <img src="https://img-blog.csdnimg.cn/20200612135107106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>此处需要配置硬件信息。点击自定义硬件。</p>
 <img src="https://img-blog.csdnimg.cn/20200612135422901.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom: 50%;" />

<p>将内存设置为2048MB，即为2GB。</p>
<img src="https://img-blog.csdnimg.cn/20200612135502623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p>选择CD/DVD使用ISO镜像文件，即为第二步下载的iso。</p>
<img src="https://img-blog.csdnimg.cn/20200612135600379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p>将网络适配器修改为桥接模式。 </p>
<img src="https://img-blog.csdnimg.cn/20200612135645243.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<p>修改后的硬件配置如上。点击完成。</p>
<img src="https://img-blog.csdnimg.cn/20200612135741573.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 此时正在执行安装，鼠标点击进虚拟机界面，按上键选中Install CentOS 7，按下回车。</p>
<img src="https://img-blog.csdnimg.cn/20200612135942106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 选择语言，点击continue。</p>
<img src="https://img-blog.csdnimg.cn/20200612140047953.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 此处需要配置，点击进入界面。</p>
<img src="https://img-blog.csdnimg.cn/20200612140125612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p>无需改动，点击左上角Done。</p>
<img src="https://img-blog.csdnimg.cn/20200612140209585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 此时Begin Installation（开始安装）按钮为可点击态，点击它，开始安装。</p>
<img src="https://img-blog.csdnimg.cn/2020061214030830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 有两项需要设置，一是root账户密码，而是创建用户。</p>
<p>首先设置root用户的密码：</p>
<img src="https://img-blog.csdnimg.cn/20200612140410717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 第一个输入框是输入密码，第二个是确认密码，注意密码不能太短，否则不能通过检验，导致不能点击Done(完成)。点击Done。</p>
<p>第二步创建用户：</p>
<img src="https://img-blog.csdnimg.cn/20200612140621544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p>用户名称不能使用root，按照提示将信息填完，就可以点击Done。</p>
<img src="https://img-blog.csdnimg.cn/20200612140805477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p> 等待安装。</p>
<img src="https://img-blog.csdnimg.cn/20200612141344928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:50%;" />

<p>安装完成之后点击Reboot，用来重启虚拟机。 </p>
<h1 id="四、修改网络状态"><a href="#四、修改网络状态" class="headerlink" title="四、修改网络状态"></a>四、修改网络状态</h1><img src="https://img-blog.csdnimg.cn/20200612141531727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:50%;" />

<p>输入用户名和密码，进入虚拟机。</p>
<p><img src="https://img-blog.csdnimg.cn/20200612141925716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 输入ip addr，发现ens33没有inet属性，那么就无法通过ip地址链接虚拟机。需要查看并编辑ens33配置。</p>
<p>输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">vi /etc/sysconfig/network-scripts/ifcfg-ens33<br></code></pre></td></tr></table></figure>

<p>进入以下界面</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209223657822.png"></p>
<p>键入i，进入插入模式。</p>
<p> <img  src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201209223805561.png"  ><span class="image-caption">image-20201209223805561</span></p>
<p>CentOS 7 默认是不启动网卡的，这里将ONBOOT之前的no改为yes。 </p>
<p>按esc键，输入**:wq**</p>
<p><img src="https://img-blog.csdnimg.cn/20200612142625611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>wq即为write and quit，编辑并保存。按下回车键。</p>
<p>输入service network restart命令，重启network服务。</p>
<p><img src="https://img-blog.csdnimg.cn/20200612142822463.png"></p>
<p> 使用ping命令，查看网络是否连通。</p>
<p><img src="https://img-blog.csdnimg.cn/20200612142936244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 使用 ip addr</p>
<p><img src="https://img-blog.csdnimg.cn/20200612143040856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> ens33中，inet后的ip地址即为当前虚拟机ip地址。</p>
]]></content>
      <categories>
        <category>CentOS</category>
      </categories>
      <tags>
        <tag>CentOS7</tag>
        <tag>VMware</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>理解SpringAOP的实现方式与思想</title>
    <url>/2020/12/09/%E7%90%86%E8%A7%A3SpringAOP%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%8E%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/20200606133512133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></h1><h1 id="Spring-AOP简介"><a href="#Spring-AOP简介" class="headerlink" title="Spring AOP简介"></a>Spring AOP简介</h1><p>如果说IOC是Spring的核心，那么面向切面编程就是Spring最核心的功能之一了，在数据库事务中，面向切面编程被广泛应用。</p>
<p>AOP能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p>
<h1 id="面向切面编程"><a href="#面向切面编程" class="headerlink" title="面向切面编程"></a>面向切面编程</h1><p>在OOP中，是面向对象开发，开发流程大致如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20200606134338833.png"></p>
<p> 面向切面编程，关注的是切面，相当于在自上而下的流程中横插进去，这种方式的好处就是对代码的侵入性小，不会影响原有的实现业务。</p>
<p><img src="https://img-blog.csdnimg.cn/20200606134932645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="Spring-AOP名词介绍"><a href="#Spring-AOP名词介绍" class="headerlink" title="Spring AOP名词介绍"></a>Spring AOP名词介绍</h1><p>在理解时，一定要先搞清楚AOP部分名词的含义，这样可以让你更好理解。</p>
<p>官方英文文档：<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#aop</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200606135507204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 其中：</p>
<ul>
<li>Aspect</li>
</ul>
<p>切面，一种开发思想，很好地例子就是事务管理。</p>
<ul>
<li>Join Point</li>
</ul>
<p>程序执行过程中的一点，例如方法的执行或异常的处理。</p>
<ul>
<li>Advice</li>
</ul>
<p>通知，可以表示在执行点前、后或者前后执行的一种状态。</p>
<ul>
<li>Pointcut</li>
</ul>
<p>切入点，表示在执行到某一个状态或标志时（具体可表示某一方法、注解或类等），执行切面增强的方法。</p>
<ul>
<li>Introduction</li>
</ul>
<p>代表类型声明其他方法或字段。</p>
<ul>
<li>Target object</li>
</ul>
<p>目标对象，即为原始切入的对象。</p>
<ul>
<li>AOP proxy</li>
</ul>
<p>增强对象方法后的代理对象，在AOP中，使用的是JDK或CGLIB动态代理，此proxy即为动态代理生成的对象。</p>
<ul>
<li>Weaving</li>
</ul>
<p>织入，运行时为增强方法后的对象生成代理对象。</p>
<h1 id="使用注解开发Sping-AOP"><a href="#使用注解开发Sping-AOP" class="headerlink" title="使用注解开发Sping AOP"></a>使用注解开发Sping AOP</h1><p>需求说明：用AOP实现日志记录功能，需要记录方法实现时间。</p>
<p>分析图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200606141650450.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> Maven项目引入所需包：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.springframework/spring-context --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>    &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt;</span><br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br>    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;<br>    &lt;version&gt;1.9.2&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>项目目录：</p>
<p><img src="https://img-blog.csdnimg.cn/20200606145201297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>首先写一个业务方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.service;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoService</span> </span>&#123;<br>		<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doMethod</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;调用Service方法&quot;</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义切面：</p>
<ul>
<li>execution表达式</li>
</ul>
<p>基本语法</p>
<p>execution(&lt;修饰符模式&gt;?&lt;返回类型模式&gt;&lt;方法名模式&gt;(&lt;参数模式&gt;)&lt;异常模式&gt;?) 除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。</p>
<p>execution(* com.yl.service..<em>.</em>(..))</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>execution（）</td>
<td>表达式主体</td>
</tr>
<tr>
<td>第一个“*”符号</td>
<td>表示任何类型的返回值</td>
</tr>
<tr>
<td>com.yl.service</td>
<td>表示业务类的包路径</td>
</tr>
<tr>
<td>“..”符号</td>
<td>表示当前包及子包</td>
</tr>
<tr>
<td>第二个“*“符号</td>
<td>表示所有类</td>
</tr>
<tr>
<td>“.*(..)”</td>
<td>表示任何方法名,(..)表示任意参数</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Around;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Pointcut;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-comment">// 将类声明成IOC中的bean</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-comment">// 声明这是一个切面</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoAspect</span> </span>&#123;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 定义切入点</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Pointcut(&quot;execution(* com.yl.service..*.*(..))&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">servicePointcut</span><span class="hljs-params">()</span> </span>&#123;<br>		<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 后置通知</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@After(&quot;servicePointcut()&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfter</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;执行后置方法&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 前置通知</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Before(&quot;servicePointcut()&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;执行前置方法&quot;</span>);<br>	&#125;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 环绕通知</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@throws</span> Throwable </span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Around(&quot;servicePointcut()&quot;)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAdvice</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span></span>&#123;<br>		<span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>		<span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">// 执行被切入方法</span><br>			joinPoint.proceed();<br>		&#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>		<span class="hljs-keyword">long</span> stop = System.currentTimeMillis();<br>		<span class="hljs-keyword">long</span> time = stop - start;<br>		System.out.println(<span class="hljs-string">&quot;执行时长：&quot;</span> + time);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>配置开启AOP自动代理，包扫描路径：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.ComponentScan;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(&quot;com.yl&quot;)</span> <span class="hljs-comment">// 包扫描路径，表示需要扫描到IOC中的bean的路径</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span> <span class="hljs-comment">// 默认使用JDK代理，将proxyTargetClass传为true则为使用CGLIB代理</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProjectConfig</span> </span>&#123;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.yl;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;<br><br><span class="hljs-keyword">import</span> com.yl.config.ProjectConfig;<br><span class="hljs-keyword">import</span> com.yl.service.DemoService;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;resource&quot;)</span><br>		AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(ProjectConfig.class);<br>		DemoService demoService = context.getBean(DemoService.class);<br>		demoService.doMethod();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">执行前置方法<br>调用Service方法<br>执行时长：<span class="hljs-number">15</span><br>执行后置方法<br></code></pre></td></tr></table></figure>

<p>此程序利用AOP面向切面编程的思想，实现了基本的日志记录功能，更多功能可以通过Spring官网或其他途径继续了解。</p>
<p>如果您对AOP的JDK、CGLIB动态代理感兴趣，请移步<a href="https://blog.csdn.net/qq_37171817/article/details/106518484">《关于Java代理那些事儿》</a>。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>切面编程</tag>
      </tags>
  </entry>
  <entry>
    <title>一文带你了解Sql优化</title>
    <url>/2020/12/09/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E4%BA%86%E8%A7%A3Sql%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>我们后台开发人员每天都难免与数据库打交道，那么你在写sql语句的时候有注重到自己sql的效率吗？当你sql查询速度很慢的时候你有想过是你的sql语句造成的吗？看完这篇文章，我相信你会对sql优化有了一定的了解！</p>
<h2 id="explain"><a href="#explain" class="headerlink" title="explain"></a>explain</h2><p>通过查看sql执行计划来确定各部位的问题。使用方法：在sql语句前面加上explain关键字。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">explain</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> sys_address <span class="hljs-keyword">where</span> remarks=<span class="hljs-string">&#x27;中国&#x27;</span> <span class="hljs-keyword">or</span> remarks=<span class="hljs-string">&#x27;中国重庆&#x27;</span>  <span class="hljs-keyword">or</span> remarks=<span class="hljs-string">&#x27;中国重庆重庆市&#x27;</span> <span class="hljs-keyword">or</span> remarks <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%渝北区%&#x27;</span>) a<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>select_type</th>
<th>table</th>
<th>partitions</th>
<th>type</th>
<th>possible_keys</th>
<th>key</th>
<th>key_len</th>
<th>ref</th>
<th>rows</th>
<th>filtered</th>
<th>Extr</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIMPLE</td>
<td>sys_address</td>
<td></td>
<td>ALL</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>667651</td>
<td>35.2</td>
<td>Using where</td>
</tr>
</tbody></table>
<p>参数说明：</p>
<ul>
<li><strong>id</strong></li>
</ul>
<p>id值越大，优先级越高，就越先执行。如果id值一样，那可以看成一组。</p>
<ul>
<li><strong>select_type</strong></li>
</ul>
<p>常见的值以及含义：</p>
<p>SIMPLE 简单的select查询，查询中不包含子查询或者UNION。</p>
<p>PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY。</p>
<p>SUBQUERY 在SELECT或WHERE列表中包含了子查询。</p>
<p>DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中。</p>
<p>UNION 若第二个SELECT出现在UNION之后，则被标记为UNION：若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED。</p>
<p>UNION RESULT 从UNION表获取结果的SELECT。</p>
<ul>
<li><strong>table</strong></li>
</ul>
<p>值就是当前执行的表名。</p>
<ul>
<li><strong>partitions</strong></li>
</ul>
<ul>
<li><strong>type</strong></li>
</ul>
<p><strong>执行效率</strong> system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</p>
<p>system：表仅有一行(=系统表)。这是const联接类型的一个特例。</p>
<p>const：表最多有一个匹配行，它将在查询开始时被读取。因为仅有一行，在这行的列值可被优化器剩余部分认为是常数。</p>
<p>const用于用常数值比较PRIMARY KEY或UNIQUE索引的所有部分时。</p>
<p>eq_ref：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了const类型。它用在一个索引</p>
<p>的所有部分被联接使用并且索引是UNIQUE或PRIMARY KEY。eq_ref可以用于使用= 操作符比较的带索引的列。比较值可以为常量或</p>
<p>一个使用在该表前面所读取的表的列的表达式。</p>
<p>ref：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如</p>
<p>果键不是UNIQUE或PRIMARY KEY(换句话说，如果联接不能基于关键字选择单个行的话)，则使用ref。如果使用的键仅仅匹配少量</p>
<p>行，该联接类型是不错的。ref可以用于使用=或&lt;=&gt;操作符的带索引的列。</p>
<p>ref_or_null：该联接类型如同ref，但是添加了MySQL可以专门搜索包含NULL值的行。在解决子查询中经常使用该联接类型的</p>
<p>优化。</p>
<p>index_merge：该联接类型表示使用了索引合并优化方法。在这种情况下，key列包含了使用的索引的清单，key_len包含了使</p>
<p>用的索引的最长的关键元素。</p>
<p>unique_subquery：该类型替换了下面形式的IN子查询的ref：value IN (SELECT primary_key FROMsingle_table WHERE</p>
<p>some_expr);unique_subquery是一个索引查找函数，可以完全替换子查询，效率更高。</p>
<p>index_subquery：该联接类型类似于unique_subquery。可以替换IN子查询，但只适合下列形式的子查询中的非唯一索引：</p>
<p>value IN (SELECT key_column FROM single_table WHERE some_expr)</p>
<p>range：只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引。key_len包含所使用索引的最长关键元素。</p>
<p>在该类型中ref列为NULL。当使用=、&lt;&gt;、&gt;、&gt;=、&lt;、&lt;=、IS NULL、&lt;=&gt;、BETWEEN或者IN操作符，用常量比较关键字列时，</p>
<p>可以使用range。</p>
<ul>
<li><strong>possible_keys</strong></li>
</ul>
<p>possible_keys列指出MySQL能使用哪个索引在该表中找到行。注意，该列完全独立于EXPLAIN输出所示的表的次序。这意味着</p>
<p>在possible_keys中的某些键实际上不能按生成的表次序使用。</p>
<ul>
<li><strong>key</strong></li>
</ul>
<p>key列显示MySQL实际决定使用的键(索引)。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的</p>
<p>索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX。</p>
<ul>
<li><strong>key_len</strong></li>
</ul>
<p>key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。注意通过key_len值我们可以确定MySQL将实际使</p>
<p>用一个多部关键字的几个部分。</p>
<ul>
<li><strong>ref</strong></li>
</ul>
<p>ref列显示使用哪个列或常数与key一起从表中选择行。</p>
<ul>
<li><strong>rows</strong></li>
</ul>
<p>rows列显示MySQL认为它执行查询时必须检查的行数。</p>
<ul>
<li><strong>filtered</strong></li>
</ul>
<ul>
<li><strong>Extr</strong></li>
</ul>
<p>该列包含MySQL解决查询的详细信息。</p>
<p>Distinct：MySQL发现第1个匹配行后，停止为当前的行组合搜索更多的行。</p>
<p>Not exists：MySQL能够对查询进行LEFT JOIN优化，发现1个匹配LEFT JOIN标准的行后，不再为前面的的行组合在该表内检</p>
<p>查更多的行。</p>
<p>range checked for each record (index map: #)：MySQL没有发现好的可以使用的索引，但发现如果来自前面的表的列值已</p>
<p>知，可能部分索引可以使用。对前面的表的每个行组合，MySQL检查是否可以使用range或index_merge访问方法来索取行。</p>
<p>Using filesort：MySQL需要额外的一次传递，以找出如何按排序顺序检索行。通过根据联接类型浏览所有行并为所有匹配</p>
<p>WHERE子句的行保存排序关键字和行的指针来完成排序。然后关键字被排序，并按排序顺序检索行。</p>
<p>Using index：从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。当查询只使用作为单一索引一</p>
<p>部分的列时，可以使用该策略。</p>
<p>Using temporary：为了解决查询，MySQL需要创建一个临时表来容纳结果。典型情况如查询包含可以按不同情况列出列的</p>
<p>GROUP BY和ORDER BY子句时。</p>
<p>Using where：WHERE子句用于限制哪一个行匹配下一个表或发送到客户。除非你专门从表中索取或检查所有行，如果Extra值</p>
<p>不为Using where并且表联接类型为ALL或index，查询可能会有一些错误。</p>
<p>Using sort_union(…), Using union(…), Using intersect(…)：这些函数说明如何为index_merge联接类型合并索引扫描。</p>
<p>Using index for group-by：类似于访问表的Using index方式，Using index for group-by表示MySQL发现了一个索引，可</p>
<p>以用来查询GROUP BY或DISTINCT查询的所有列，而不要额外搜索硬盘访问实际的表。并且，按最有效的方式使用索引，以便对于</p>
<p>每个组，只读取少量索引条目。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引的作用就是加快查询速度，它就像书的目录，当你想获取到里面内容位置时，就需要可以通过目录快速的定位到具体位置。</p>
<p>首先我们需要明确一点，索引并不是越多越好。因为写入数据时，会对索引字段进行一些处理，就会影响插入速度。</p>
<p>在MySql中的常用索引：</p>
<ul>
<li><strong>主键索引</strong></li>
</ul>
<p>一个表中只有一个主键索引，一般在建表的时候就自动存在了。由系统自动创建，不需要额外手动创建。</p>
<ul>
<li><strong>普通索引</strong></li>
</ul>
<p>一般索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> 索引名(column1,column2);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>唯一索引</strong></li>
</ul>
<p>表示列中不能有重复值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-string">`table_name`</span> <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (<span class="hljs-string">`column`</span>)；<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>全文索引</strong></li>
</ul>
<p>通常用于文本值中，比如商品详细信息等。</p>
<h3 id="合理添加索引"><a href="#合理添加索引" class="headerlink" title="合理添加索引"></a>合理添加索引</h3><ol>
<li>查询频繁的字段，应该添加索引。</li>
<li>更新频繁的字段，不应该添加索引。</li>
<li>唯一性太差的字段不应该添加索引，比如sex性别字段。</li>
</ol>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><p>以下几种情况，即使字段创建了索引，也不会使用到。</p>
<ol>
<li>like语句以“%”开头。</li>
<li>or语句的字段没有全部使用索引，其中任意一个没有索引的话，此条件就不会使用索引。</li>
<li>在组合查询中，第一个查询字段的名称不是复合索引中的第一列。</li>
<li>在索引列上使用IS NULL 或者IS NOT NULL，索引是不能索引空值的，这样的操作会导致全表扫描。</li>
<li>在索引字段上使用not 、&lt;&gt;、!=。</li>
<li>在索引字段上执行函数，如DATE_FORMAT(data, format)。</li>
</ol>
]]></content>
      <categories>
        <category>Sql</category>
      </categories>
      <tags>
        <tag>Sql优化</tag>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title>关于Java代理那些事儿</title>
    <url>/2020/12/09/%E5%85%B3%E4%BA%8EJava%E4%BB%A3%E7%90%86%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<p>代理是啥？就是代替你执行你持有的主要功能，并且能在你的基础之上完成一些其他的功能。代理的目的就是生成一个和原对象具有同样功能的对象。在Java中，代理是一种设计模式。在Spring的面向切面编程（AOP）中，主要就是利用动态代理来实现代码的织入。</p>
<p>代理分为动态代理和静态代理。顾名思义，动态代理比静态代理扩展性更高，动态代理不用为每一个实现类维护一个代理类。</p>
<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>为不同的被代理类都维护一个代理类，维护工作量大，不利于扩展。</p>
<p>建立接口类，即被代理类。</p>
<p>Worker.java 工人接口类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Worker</span> </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">working</span><span class="hljs-params">()</span></span>;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resting</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>SimpleWorker.java 工人实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleWorker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Worker</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">working</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;I&#x27;m working!&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resting</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;I&#x27;m resting!&quot;</span>);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p> 需求，通过代理调用SimpleWorker的具体的方法，且处理其他逻辑（输出一句话）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerProxy</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> Worker worker;<br>	<br>        <span class="hljs-comment">// 构造函数传入需要执行的类</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WorkerProxy</span><span class="hljs-params">(Worker worker)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.worker = worker;<br>	&#125;<br>	<br>        <span class="hljs-comment">// 代理方法，调用具体实现方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">working</span><span class="hljs-params">()</span> </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;excute static proxy.&quot;</span>);<br>		worker.working();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">excute <span class="hljs-keyword">static</span> proxy.<br>I<span class="hljs-string">&#x27;m working!</span><br></code></pre></td></tr></table></figure>

<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理分为JDK动态代理与CGLIB动态代理。</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是jre库提供的一种方法，无需额外引入。它是通过类的接口生成代理类。</p>
<p>生成一个jdk代理，需要实现InvocationHandler接口，重写invoke方法。再用Proxy.newProxyInstance去生成代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jdk 动态代理</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> Object target;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JdkProxy</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.target = target;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;excute jdk proxy.&quot;</span>);<br>		Object result = method.invoke(target, args);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="hljs-keyword">this</span>);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// JDK 动态代理</span><br>		SimpleWorker simpleWorker = <span class="hljs-keyword">new</span> SimpleWorker();<br>		JdkProxy dynamicProxy = <span class="hljs-keyword">new</span> JdkProxy(simpleWorker);<br>		Object proxyObj = dynamicProxy.getInstance();<br>		Worker obj = (Worker) proxyObj;<br>		obj.working();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">excute jdk proxy.<br>I<span class="hljs-string">&#x27;m working!</span><br></code></pre></td></tr></table></figure>

<h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB是通过继承父类的公有方法，然后进行重写来实现的。在代码中代理类需要实现MethodInterceptor接口，重写intercept方法。配合Enhancer生成动态代理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.Enhancer;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.cglib.proxy.MethodProxy;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CglibProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object obj, Method method, Object[] aobj, MethodProxy methodproxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>		System.out.println(<span class="hljs-string">&quot;excute cglib proxy.&quot;</span>);<br>        <span class="hljs-comment">// 执行父类方法</span><br>		Object result = methodproxy.invokeSuper(obj, aobj);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getInstance</span><span class="hljs-params">(Class&lt;?&gt; superClass)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取代理实例</span><br>		Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>		enhancer.setSuperclass(superClass);<br>		enhancer.setCallback(<span class="hljs-keyword">this</span>);<br>		<span class="hljs-keyword">return</span> enhancer.create();<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// CGLIB 动态代理</span><br>		CglibProxy cglibProxy = <span class="hljs-keyword">new</span> CglibProxy();<br>		Object instance = cglibProxy.getInstance(SimpleWorker.class);<br>		Worker obj2 = (Worker) instance;<br>		obj2.working();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">excute cglib proxy.<br>I<span class="hljs-string">&#x27;m working!</span><br></code></pre></td></tr></table></figure>

<p>Spring 默认使用jdk动态代理，而当类没有接口类时，使用CGLIB进行代理。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>动态代理</tag>
        <tag>Jdk动态代理</tag>
        <tag>CGLib动态代理</tag>
      </tags>
  </entry>
  <entry>
    <title>Java单例模式的实现与破坏</title>
    <url>/2020/12/09/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E7%A0%B4%E5%9D%8F/</url>
    <content><![CDATA[<p>单例模式是一种设计模式，是在整个运行过程中只需要产生一个实例。那么怎样去创建呢，以下提供了几种方案。</p>
<h1 id="一、创建单例对象"><a href="#一、创建单例对象" class="headerlink" title="一、创建单例对象"></a>一、创建单例对象</h1><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingleton</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 构造方法私有化</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TestSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	<br>	<span class="hljs-comment">// 声明实例</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TestSingleton singleton;<br>	<br>	<span class="hljs-comment">// 提供外部调用方法，生成并获取实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(singleton == <span class="hljs-keyword">null</span>) &#123;<br>			singleton = <span class="hljs-keyword">new</span> TestSingleton();<br>		&#125;<br>		<span class="hljs-keyword">return</span> singleton;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>此方案是以时间换空间，启动时并不会执行任何操作，只有被调用时，采取实例化对象。不过这种方法在多线程下不安全，因为两个线程如果同时调用时，会同时通过非空验证的验证，造成创建两个对象的后果，有悖设计初衷。</p>
<p>针对多线程问题，应该加入双重非空判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingleton</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 构造方法私有化</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TestSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	<br>	<span class="hljs-comment">// 声明实例</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> TestSingleton singleton;<br>	<br>	<span class="hljs-comment">// 提供外部调用方法，生成并获取实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(singleton == <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">synchronized</span> (TestSingleton.class) &#123;<br>				<span class="hljs-keyword">if</span>(singleton == <span class="hljs-keyword">null</span>) &#123;<br>					singleton = <span class="hljs-keyword">new</span> TestSingleton();<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> singleton;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingleton</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 构造方法私有化</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TestSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	<br>	<span class="hljs-comment">// 声明并生成实例</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TestSingleton singleton = <span class="hljs-keyword">new</span> TestSingleton();<br>	<br>	<span class="hljs-comment">// 提供外部调用方法，获取实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> singleton;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以空间换时间，类一加载时，就对其进行实例化，后面调用时直接提供对象实例。</p>
<h3 id="静态内部类实现懒加载"><a href="#静态内部类实现懒加载" class="headerlink" title="静态内部类实现懒加载"></a>静态内部类实现懒加载</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingleton</span> </span>&#123;<br>	<br>	<span class="hljs-comment">// 构造方法私有化</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TestSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingletonFactory</span></span>&#123;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TestSingleton singleton = <span class="hljs-keyword">new</span> TestSingleton();<br>	&#125;<br>	<br>	<span class="hljs-comment">// 提供外部调用方法，获取实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> TestSingletonFactory.singleton;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>当getInstance方法被调用时，才会初始化静态内部类TestSingletonFactory的静态变量singleton。此处由JVM来保障线程安全。</p>
<h1 id="二、破坏单例"><a href="#二、破坏单例" class="headerlink" title="二、破坏单例"></a>二、破坏单例</h1><p>实现单例后，按照预期结果应该所有对象都是同一个对象。但是以下有几种情况可以破坏单例的性质。</p>
<p>首先让单例类实现Serializable, Cloneable接口，以便实验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Cloneable</span></span>&#123;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br><br>	<span class="hljs-comment">// 构造方法私有化</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TestSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingletonFactory</span></span>&#123;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TestSingleton singleton = <span class="hljs-keyword">new</span> TestSingleton();<br>	&#125;<br><br>	<span class="hljs-comment">// 提供外部调用方法，获取实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> TestSingletonFactory.singleton;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>序列化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取实例</span><br>TestSingleton originSingleton = TestSingleton.getInstance();<br><span class="hljs-comment">// 写出对象</span><br>ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>oos.writeObject(originSingleton);<br><span class="hljs-comment">// 写入对象</span><br>ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());<br>ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>TestSingleton serializeSingleton = (TestSingleton) ois.readObject();<br><span class="hljs-comment">// 判断两个对象是否相等</span><br>System.out.println(originSingleton == serializeSingleton); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<ul>
<li>反射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反射</span><br>Class&lt;TestSingleton&gt; clazz = TestSingleton.class;<br><span class="hljs-comment">// 获取无参构造函数</span><br>Constructor&lt;TestSingleton&gt; constructor = clazz.getDeclaredConstructor();<br><span class="hljs-comment">// 将私有设置为可见</span><br>constructor.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-comment">// 用构造器生成实例</span><br>TestSingleton instance = constructor.newInstance();<br><span class="hljs-comment">// 判断两个对象是否相等</span><br>System.out.println(originSingleton == instance); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<ul>
<li>克隆</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 克隆</span><br>TestSingleton clone = (TestSingleton) originSingleton.clone();<br>System.out.println(originSingleton == clone); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h1 id="三、修复破坏"><a href="#三、修复破坏" class="headerlink" title="三、修复破坏"></a>三、修复破坏</h1><p>对于这种预料之外的结果，我们应该怎样去控制呢？</p>
<ul>
<li>序列化</li>
</ul>
<p>添加readResolve方法，返回Object。</p>
<ul>
<li>反射</li>
</ul>
<p>添加全局可见变量，如果再次调用构造方法生成实例时，抛出运行时错误。</p>
<ul>
<li>克隆</li>
</ul>
<p>重写clone方法，直接返回单例对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>, <span class="hljs-title">Cloneable</span></span>&#123;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> isCreated = <span class="hljs-keyword">false</span>;<span class="hljs-comment">//默认是第一次创建</span><br><br>	<span class="hljs-comment">// 构造方法私有化</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">TestSingleton</span><span class="hljs-params">()</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(isCreated) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;实例已经被创建&quot;</span>);<br>		&#125;<br>		isCreated = <span class="hljs-keyword">true</span>;<br>	&#125;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestSingletonFactory</span></span>&#123;<br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TestSingleton singleton = <span class="hljs-keyword">new</span> TestSingleton();<br>	&#125;<br><br>	<span class="hljs-comment">// 提供外部调用方法，获取实例</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> TestSingletonFactory.singleton;<br>	&#125;<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>		<span class="hljs-keyword">return</span> getInstance();<br>	&#125;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 防止序列化破环</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getInstance();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>单例模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java数据类型之Cache模式</title>
    <url>/2020/12/09/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8BCache%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="1、关于Java数据类型"><a href="#1、关于Java数据类型" class="headerlink" title="1、关于Java数据类型"></a>1、关于Java数据类型</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>基本数据类型有8种，每种基本数据类型都有对应的引用类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>长度</th>
<th>可表示数据</th>
<th>包装类型</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>布尔型</td>
<td>1</td>
<td>true、false</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte</td>
<td>字节型</td>
<td>1</td>
<td>2<sup>-7</sup>~2<sup>7</sup>-1</td>
<td>Byte</td>
</tr>
<tr>
<td>char</td>
<td>字符型</td>
<td>2</td>
<td>2<sup>-15</sup>~2<sup>15</sup>-1</td>
<td>Character</td>
</tr>
<tr>
<td>short</td>
<td>短整型</td>
<td>2</td>
<td>2<sup>-15</sup>~2<sup>15</sup>-1</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>整型</td>
<td>4</td>
<td>2<sup>-31</sup>~2<sup>31</sup>-1</td>
<td>Integer</td>
</tr>
<tr>
<td>float</td>
<td>浮点型</td>
<td>4</td>
<td>2<sup>-31</sup>~2<sup>31</sup>-1</td>
<td>Float</td>
</tr>
<tr>
<td>long</td>
<td>长整型</td>
<td>8</td>
<td>2<sup>-63</sup>~2<sup>63</sup>-1</td>
<td>Long</td>
</tr>
<tr>
<td>double</td>
<td>双精度浮点型</td>
<td>8</td>
<td>2<sup>-63</sup>~2<sup>63</sup>-1</td>
<td>Double</td>
</tr>
</tbody></table>
<h2 id="为什么要有包装类型？"><a href="#为什么要有包装类型？" class="headerlink" title="为什么要有包装类型？"></a>为什么要有包装类型？</h2><p>因为Java是面向对象语言，很多地方用到的是对象，而不是基本数据类型。比如集合类中，我们是无法定义集合的泛型是基本数据类型的。而包装类，顾名思义，就是将基本数据类型包装起来，使其具备了对象的性质，也为其添加了很多操作方法。</p>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</p>
<p>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p>
<p>为什么要有自动装拆箱呢？因为很多地方都是需要其进行转换的，而重复操作又会显得很多余，所以为其提供了自动适配功能。</p>
<p>那么哪些地方能用到呢？举两个最常用的例子。</p>
<ol>
<li>类型转换</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer i = <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动装箱</span><br><span class="hljs-keyword">int</span> a = i; <span class="hljs-comment">// 自动拆箱</span><br></code></pre></td></tr></table></figure>

<p>2）存入集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br>list.add(a); <span class="hljs-comment">// 自动装箱</span><br></code></pre></td></tr></table></figure>

<h1 id="2、Cache"><a href="#2、Cache" class="headerlink" title="2、Cache"></a>2、Cache</h1><p>顾名思义，Cache就是缓存的意思。那数据类型里面哪些地方用到Cache呢？它具备什么作用？</p>
<p>首先抛出一道题，请大家参考。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer a = Integer.valueOf(<span class="hljs-number">20</span>);<br>Integer b = Integer.valueOf(<span class="hljs-number">20</span>);<br>System.out.println(a == b);<br></code></pre></td></tr></table></figure>

<p>结果相等吗？是相等的。输出true。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer a = Integer.valueOf(<span class="hljs-number">128</span>);<br>Integer b = Integer.valueOf(<span class="hljs-number">128</span>);<br>System.out.println(a == b);<br></code></pre></td></tr></table></figure>

<p>这里结果不相等的，为啥？128！=128？</p>
<p>首先来看valueOf这个方法：</p>
<ul>
<li>Integer valueOf(String s, int radix)</li>
</ul>
<p>将字符串以规定进制转换成Integer,radix表示进制数。</p>
<ul>
<li>Integer valueOf(String s)</li>
</ul>
<p>将字符串转换为10进制的Integer。</p>
<ul>
<li>Integer valueOf(int i)</li>
</ul>
<p>将基本数据类型转换为包装类。</p>
<p>为什么会造成两个相同数字比较出来不相同呢？来，我们上源码。</p>
<p>前两个方法最终调用的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果值在IntegerCache的低位和高位之间就从IntegerCache里取</span><br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-comment">// 否则new一个对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>IntegerCache是Integer中的一个静态内部类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-comment">// 低位固定为-128</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-comment">// 高位</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-comment">// 存放缓存区数据</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// 高位默认为127</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            <span class="hljs-comment">// 可以通过配置</span><br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 将配置值转换为基本数据类型</span><br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    <span class="hljs-comment">// 将配置值与127比较取最大值</span><br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// 确定高位值，防止数组长度超过整型最大值</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br>            <br>            <span class="hljs-comment">// 初始化数组大小</span><br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                <span class="hljs-comment">// 初始化数组数据</span><br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br><br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-comment">// 如果高位值大于等于127，则抛出异常</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>因为128超过了整型缓存区域，所以每次都会new一个对象，所以导致比较出来不相等。</p>
<p>Short、Long、Character等内部都有Cache区域，建议大家多去挖掘挖掘。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>理解并手写简易的SpringMVC框架</title>
    <url>/2020/12/09/%E7%90%86%E8%A7%A3%E5%B9%B6%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93%E7%9A%84SpringMVC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>Spring框架是大多Java程序员的必修课程，而SpringMVC是里面的重头戏，它大大的简化了Servlet的繁琐操作，让开发人员得以用更多的时间去处理业务。</p>
<p>SpringMVC是一款经典的三层架构模式，M为Model（模型）,V为View（视图）,C为Controlle（控制器）。MVC是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。</p>
<h1 id="二、SpringMVC流程"><a href="#二、SpringMVC流程" class="headerlink" title="二、SpringMVC流程"></a>二、SpringMVC流程</h1><p><img src="https://img-blog.csdnimg.cn/20200518171620174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="流程简述："><a href="#流程简述：" class="headerlink" title="流程简述："></a>流程简述：</h2><p>（1）用户通过浏览器或其他途径发起请求。</p>
<p>（2）请求经过前端控制器DispatcherServlet,并根据请求的URI匹配到对应的处理映射器。</p>
<p>（3）处理映射器返回HandlerExecutionChain实体给DispatcherServlet，内部封装了拦截器HandlerInterceptor、Object类型的具体处理器handler。</p>
<p>（4）系统启动时，初始化了HandlerAdapter的List的集合，此步骤循环List集合，调用HandlerAdapter的support方法，找到handler支持的HandlerAdapter处理适配器。</p>
<p>（5）由HandlerAdapter处理参数并调用处理器的方法。</p>
<p>（6）返回结果是ModelAndView,即视图。其内部封装了view、model、status。</p>
<p>（7）将处理得到的ModelAndView返回给DispatcherServlet。</p>
<p>（8）将ModelAndView交由专业的视图解析器进行解析，得到页面位置。</p>
<p>（9）返回结果给DispatcherServlet。</p>
<p>（10）将数据渲染到页面。</p>
<p>（11）响应请求。</p>
<h2 id="源码核心部分概览"><a href="#源码核心部分概览" class="headerlink" title="源码核心部分概览"></a>源码核心部分概览</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br>    initMultipartResolver(context);<br>    initLocaleResolver(context);<br>    initThemeResolver(context);<br>    initHandlerMappings(context);<br>    initHandlerAdapters(context);<br>    initHandlerExceptionResolvers(context);<br>    initRequestToViewNameTranslator(context);<br>    initViewResolvers(context);<br>    initFlashMapManager(context);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>  initMultipartResolver(context)</li>
</ul>
<p>初始化文件上传解析功能，将普通HttpServletRequest包装成MutipartHttpServletRequest，此类可通过getFile获取到文件集合。</p>
<ul>
<li>  initLocaleResolver(context)</li>
</ul>
<p>初始化与当地区域有关的设置，如视图解析器与国际化资源的配置。</p>
<ul>
<li>  initThemeResolver(context)</li>
</ul>
<p>初始化主题解析，如消息国际话得配置，每个主题对应 一个properties文件。</p>
<ul>
<li>  initHandlerMappings(context)</li>
</ul>
<p>初始化HandlerMappings，用来获取对应的handler与interceptor。</p>
<ul>
<li>  initHandlerAdapters(context)</li>
</ul>
<p>初始化处理适配器，用来执行具体方法。</p>
<ul>
<li>  initHandlerExceptionResolvers(context)</li>
</ul>
<p>对异常情况进行处理。</p>
<ul>
<li>  initRequestToViewNameTranslator(context)</li>
</ul>
<p>从请求中获取视图名称。</p>
<ul>
<li>  initViewResolvers(context)</li>
</ul>
<p>初始化视图解析器，将ModelAndView渲染成页面。</p>
<ul>
<li>  initFlashMapManager(context)</li>
</ul>
<p>主要用处在于传递重定向参数。</p>
<h1 id="三、手写Spring-MVC"><a href="#三、手写Spring-MVC" class="headerlink" title="三、手写Spring MVC"></a>三、手写Spring MVC</h1><h2 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h2><img src="https://img-blog.csdnimg.cn/20200518175129241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<h2 id="源码地址："><a href="#源码地址：" class="headerlink" title="源码地址："></a>源码地址：</h2><p><a href="https://github.com/hanguilin/custom-springmvc">https://github.com/hanguilin/custom-springmvc</a></p>
<h2 id="环境配置："><a href="#环境配置：" class="headerlink" title="环境配置："></a>环境配置：</h2><p>maven项目中引入Servlet需要的jar包</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br>    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br>    &lt;version&gt;3.0.1&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<p>其他jar包（本人写代码用到的一些包）</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">      &lt;dependency&gt;<br>	&lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>	&lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;<br>	&lt;version&gt;1.7.25&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;<br>	&lt;artifactId&gt;logback-classic&lt;/artifactId&gt;<br>	&lt;version&gt;1.2.3&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>	&lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;<br>	&lt;version&gt;1.7.25&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;log4j&lt;/groupId&gt;<br>	&lt;artifactId&gt;log4j&lt;/artifactId&gt;<br>	&lt;version&gt;1.2.17&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.slf4j&lt;/groupId&gt;<br>	&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;<br>	&lt;version&gt;1.7.21&lt;/version&gt;<br>&lt;/dependency&gt;<br>&lt;!-- https:<span class="hljs-comment">//mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt;</span><br>&lt;dependency&gt;<br>	&lt;groupId&gt;org.apache.commons&lt;/groupId&gt;<br>	&lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;<br>	&lt;version&gt;3.4&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<h2 id="注解类："><a href="#注解类：" class="headerlink" title="注解类："></a>注解类：</h2><p>建立SpringMVC中常用注解@Controller、@RequstMapping、@Autowired、@Qualifier、@Service、@RequestParam的替代注解。区别为在自己的注解中给名字添加了Custom前缀。各个注解的区别在于注解地方，如类、方法、字段上不同。</p>
<p><strong>CustomController.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 控制层注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomController &#123;<br>	<br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>CustomRequestMapping.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 请求路径注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomRequestMapping &#123;<br><br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>CustomAutowired.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自动注入</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomAutowired &#123;<br><br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>CustomQualifer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 按名称自动注入</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomQualifer &#123;<br><br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>CustomService.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 业务层注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomService &#123;<br>	<br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>CustomRequestParam.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.annotation;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Documented;<br><span class="hljs-keyword">import</span> java.lang.annotation.ElementType;<br><span class="hljs-keyword">import</span> java.lang.annotation.Retention;<br><span class="hljs-keyword">import</span> java.lang.annotation.RetentionPolicy;<br><span class="hljs-keyword">import</span> java.lang.annotation.Target;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Target(ElementType.PARAMETER)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> CustomRequestParam &#123;<br><br>	<span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>在classpath下建立spring-mvc.properties,指定扫描包路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">spring.scanner.base.<span class="hljs-keyword">package</span>=com.hgl<br></code></pre></td></tr></table></figure>

<h2 id="核心配置类"><a href="#核心配置类" class="headerlink" title="核心配置类"></a>核心配置类</h2><p>SpringMVC核心配置类DispatcherServlet.java，替代类为CustomDispatcherServlet.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.servlet;<br><br><span class="hljs-keyword">import</span> java.io.File;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><span class="hljs-keyword">import</span> java.util.regex.Matcher;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletConfig;<br><span class="hljs-keyword">import</span> javax.servlet.ServletException;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomController;<br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomQualifer;<br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomRequestMapping;<br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomService;<br><span class="hljs-keyword">import</span> com.hgl.mvc.resolver.ArgumentResolver;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomDispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span></span>&#123;<br><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CustomDispatcherServlet.class);<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1L</span>;<br>	<br>	<span class="hljs-keyword">private</span> Properties contextConfig = <span class="hljs-keyword">new</span> Properties();<br><br>	<span class="hljs-comment">// 所有扫描类</span><br>	<span class="hljs-keyword">private</span> List&lt;String&gt; classes = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><br>	<span class="hljs-comment">// 存放bean的容器ioc</span><br>	<span class="hljs-keyword">private</span> Map&lt;String, Object&gt; context = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>	<br>	<span class="hljs-comment">// 存放参数解析器</span><br>	<span class="hljs-keyword">private</span> Map&lt;String, ArgumentResolver&gt; argumentResolverMap = <span class="hljs-keyword">new</span> HashMap&lt;String, ArgumentResolver&gt;();<br>	<br>	<span class="hljs-comment">// 根据请求url找到具体的处理器</span><br>	<span class="hljs-keyword">private</span> List&lt;CustomHandlerMapping&gt; handlerMapping = <span class="hljs-keyword">new</span> ArrayList&lt;CustomHandlerMapping&gt;();<br>	<br>	<span class="hljs-keyword">private</span> List&lt;CustomHandlerAdapter&gt; handlerAdapter = <span class="hljs-keyword">new</span> ArrayList&lt;CustomHandlerAdapter&gt;();<br><br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomDispatcherServlet</span><span class="hljs-params">()</span> </span>&#123;<br>		LOGGER.info(<span class="hljs-string">&quot;CustomDispatcherServlet()...&quot;</span>);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>		<span class="hljs-comment">// 加载配置文件</span><br>		initConfig(config.getInitParameter(<span class="hljs-string">&quot;spring-mvc&quot;</span>));<br>		<span class="hljs-comment">// 扫描类</span><br>		initBaseScanPackage(contextConfig.getProperty(<span class="hljs-string">&quot;spring.scanner.base.package&quot;</span>));<br>		<span class="hljs-comment">// 生成bean实例，注入ioc</span><br>		initContext();<br>		<span class="hljs-comment">// 初始化参数解析器</span><br>		initArgumentResolver();<br>		<span class="hljs-comment">// 为controller层中service对象注入实例</span><br>		initInstance();<br>		<span class="hljs-comment">// 建立URI与处理器的映射</span><br>		initHandlerMapping();<br>		<span class="hljs-comment">// 处理器适配器</span><br>		initHandlerAdapter();<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initConfig</span><span class="hljs-params">(String initParameter)</span> </span>&#123;<br>		InputStream in = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(initParameter);<br>		<span class="hljs-keyword">try</span> &#123;<br>			contextConfig.load(in);<br>		&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>			LOGGER.error(e.getMessage(), e);<br>		&#125; <span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span>(in != <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">try</span> &#123;<br>					in.close();<br>				&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>					LOGGER.error(e.getMessage(), e);<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBaseScanPackage</span><span class="hljs-params">(String basePackage)</span> </span>&#123;<br>		URL resource = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">&quot;/&quot;</span> + basePackage.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>));<br>		String packagePath = resource.getFile();<br>		File packageFile = <span class="hljs-keyword">new</span> File(packagePath);<br>		String[] listFiles = packageFile.list();<br>		<span class="hljs-keyword">for</span> (String filepPath : listFiles) &#123;<br>			File file = <span class="hljs-keyword">new</span> File(packagePath + filepPath);<br>			<span class="hljs-keyword">if</span>(file.isDirectory()) &#123;<br>				initBaseScanPackage(basePackage + <span class="hljs-string">&quot;.&quot;</span> + filepPath);<br>			&#125;<span class="hljs-keyword">else</span> &#123;<br>				classes.add(basePackage + <span class="hljs-string">&quot;.&quot;</span> + file.getName());<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initContext</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(classes.isEmpty()) &#123;<br>			LOGGER.error(<span class="hljs-string">&quot;do scan failed.&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (String className : classes) &#123;<br>			String classPath = className.substring(<span class="hljs-number">0</span>, className.lastIndexOf(<span class="hljs-string">&quot;.class&quot;</span>));<br>			<span class="hljs-keyword">try</span> &#123;<br>				Class&lt;?&gt; clazz = Class.forName(classPath);<br>				String simpleName = clazz.getSimpleName();<br>				<span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(CustomController.class)) &#123;<br>					CustomController controller = clazz.getAnnotation(CustomController.class);<br>					String key = controller.value();<br>					<span class="hljs-keyword">if</span>(StringUtils.isBlank(key)) &#123;<br>						key = toLowerCaseFirstOne(simpleName);<br>					&#125;<br>					Object instance = clazz.newInstance();<br>					context.put(key, instance);<br>				&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(CustomService.class)) &#123;<br>					CustomService service = clazz.getAnnotation(CustomService.class);<br>					String key = service.value();<br>					<span class="hljs-keyword">if</span>(StringUtils.isBlank(key)) &#123;<br>						key = toLowerCaseFirstOne(simpleName);<br>					&#125;<br>					Object instance = clazz.newInstance();<br>					context.put(key, instance);<br>				&#125; <span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-keyword">continue</span>;<br>				&#125;<br>			&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;<br>				LOGGER.error(e.getMessage(), e);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initArgumentResolver</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(context.isEmpty()) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : context.entrySet()) &#123;<br>			Object bean = entry.getValue();<br>			<span class="hljs-comment">// 判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口</span><br>			<span class="hljs-keyword">if</span>(ArgumentResolver.class.isAssignableFrom(bean.getClass())) &#123;<br>				argumentResolverMap.put(entry.getKey(), (ArgumentResolver) bean);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(context.isEmpty()) &#123;<br>			LOGGER.error(<span class="hljs-string">&quot;no bean is instanced.&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : context.entrySet()) &#123;<br>			Object bean = entry.getValue();<br>			Class&lt;? extends Object&gt; clazz = bean.getClass();<br>			<span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(CustomController.class)) &#123;<br>				Field[] declaredFields = clazz.getDeclaredFields();<br>				<span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>					<span class="hljs-keyword">if</span>(field.isAnnotationPresent(CustomQualifer.class)) &#123;<br>						CustomQualifer qualifer = field.getAnnotation(CustomQualifer.class);<br>						String beanName = qualifer.value();<br>						Object value = context.get(beanName);<br>						<span class="hljs-keyword">try</span> &#123;<br>							<span class="hljs-keyword">if</span>(!field.isAccessible()) &#123;<br>								field.setAccessible(<span class="hljs-keyword">true</span>);<br>							&#125;<br>							field.set(bean, value);<br>						&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException | IllegalAccessException e) &#123;<br>							LOGGER.error(e.getMessage(), e);<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerMapping</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(context.isEmpty()) &#123;<br>			LOGGER.error(<span class="hljs-string">&quot;no bean is instanced.&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : context.entrySet()) &#123;<br>			Object bean = entry.getValue();<br>			Class&lt;? extends Object&gt; clazz = bean.getClass();<br>			<span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(CustomController.class)) &#123;<br>				String classRequestMappingVal = <span class="hljs-string">&quot;&quot;</span>;<br>				<span class="hljs-keyword">if</span>(clazz.isAnnotationPresent(CustomRequestMapping.class)) &#123;<br>					CustomRequestMapping classRequestMapping = clazz.getAnnotation(CustomRequestMapping.class);<br>					classRequestMappingVal = classRequestMapping.value();<br>				&#125;<br>				Method[] declaredMethods = clazz.getDeclaredMethods();<br>				List&lt;String&gt; uris = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>				<span class="hljs-keyword">for</span> (Method method : declaredMethods) &#123;<br>					String methodRequestMappingVal = <span class="hljs-string">&quot;&quot;</span>;<br>					<span class="hljs-keyword">if</span>(method.isAnnotationPresent(CustomRequestMapping.class)) &#123;<br>						CustomRequestMapping methodRequestMapping = method.getAnnotation(CustomRequestMapping.class);<br>						methodRequestMappingVal = classRequestMappingVal + methodRequestMapping.value();<br>					&#125;<br>					<span class="hljs-keyword">if</span>(StringUtils.isNotBlank(methodRequestMappingVal)) &#123;<br>						<span class="hljs-keyword">if</span>(uris.contains(methodRequestMappingVal)) &#123;<br>							<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;Duplicate mapping for &quot;</span> + methodRequestMappingVal);<br>						&#125;<br>						handlerMapping.add(<span class="hljs-keyword">new</span> CustomHandlerMapping(bean, method, Pattern.compile(methodRequestMappingVal)));<br>						uris.add(methodRequestMappingVal);<br>					&#125;<br>				&#125;<br>				uris = <span class="hljs-keyword">null</span>;<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initHandlerAdapter</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">if</span>(context.isEmpty()) &#123;<br>			LOGGER.error(<span class="hljs-string">&quot;no bean is instanced.&quot;</span>);<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br>		<span class="hljs-keyword">for</span>(Map.Entry&lt;String, Object&gt; entry : context.entrySet()) &#123;<br>			Object bean = entry.getValue();<br>			<span class="hljs-comment">// 判定此 Class 对象所表示的类或接口与指定的 Class 参数所表示的类或接口是否相同，或是否是其超类或超接口</span><br>			<span class="hljs-keyword">if</span>(CustomHandlerAdapter.class.isAssignableFrom(bean.getClass())) &#123;<br>				handlerAdapter.add((CustomHandlerAdapter) bean);<br>			&#125;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">toLowerCaseFirstOne</span><span class="hljs-params">(String s)</span></span>&#123;<br>		<span class="hljs-keyword">if</span>(Character.isLowerCase(s.charAt(<span class="hljs-number">0</span>)))<br>			<span class="hljs-keyword">return</span> s;<br>		<span class="hljs-keyword">else</span><br>			<span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> StringBuilder()).append(Character.toLowerCase(s.charAt(<span class="hljs-number">0</span>))).append(s.substring(<span class="hljs-number">1</span>)).toString();<br>	&#125;<br>	<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>		doPost(request, response);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>		CustomHandlerMapping handler = getHandler(request);<br>		CustomHandlerAdapter handlerAdapter = getHandlerAdapter(handler);<br>		CustomModelAndView modelAndView = handlerAdapter.handle(request, response, handler, argumentResolverMap);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> CustomHandlerAdapter <span class="hljs-title">getHandlerAdapter</span><span class="hljs-params">(CustomHandlerMapping handler)</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (CustomHandlerAdapter customHandlerAdapter : handlerAdapter) &#123;<br>			<span class="hljs-keyword">if</span>(customHandlerAdapter.support(handler)) &#123;<br>				<span class="hljs-keyword">return</span> customHandlerAdapter;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;There is no handlerAdapter for &quot;</span> + handler);<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> CustomHandlerMapping <span class="hljs-title">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>		String requestURI = request.getRequestURI();<br>		String path = requestURI.replaceAll(request.getContextPath(), <span class="hljs-string">&quot;&quot;</span>);<br>		<span class="hljs-keyword">for</span> (CustomHandlerMapping handler : handlerMapping) &#123;<br>			Pattern pattern = handler.getPattern();<br>			Matcher matcher = pattern.matcher(path);<br>			<span class="hljs-keyword">if</span>(matcher.matches()) &#123;<br>				<span class="hljs-keyword">return</span> handler;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;There is no mapping for &quot;</span> + path);<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="处理映射器"><a href="#处理映射器" class="headerlink" title="处理映射器"></a>处理映射器</h2><p>CustomHandlerMapping.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.servlet;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.regex.Pattern;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义handlerMapping</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomHandlerMapping</span></span>&#123;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * controller对应的bean</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> Object controller;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 具体处理方法</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> Method method;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 用来验证是否是当前url对应的处理方法</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">private</span> Pattern pattern;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomHandlerMapping</span><span class="hljs-params">(Object controller, Method method, Pattern pattern)</span> </span>&#123;<br>		<span class="hljs-keyword">super</span>();<br>		<span class="hljs-keyword">this</span>.controller = controller;<br>		<span class="hljs-keyword">this</span>.method = method;<br>		<span class="hljs-keyword">this</span>.pattern = pattern;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getController</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> controller;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setController</span><span class="hljs-params">(Object controller)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.controller = controller;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getMethod</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> method;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMethod</span><span class="hljs-params">(Method method)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.method = method;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Pattern <span class="hljs-title">getPattern</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> pattern;<br>	&#125;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPattern</span><span class="hljs-params">(Pattern pattern)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.pattern = pattern;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="处理适配器"><a href="#处理适配器" class="headerlink" title="处理适配器"></a>处理适配器</h2><p>CustomHandlerAdapter.java,作为接口，由实现类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.servlet;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> com.hgl.mvc.resolver.ArgumentResolver;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> * 自定义适配器</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomHandlerAdapter</span> </span>&#123;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 是否支持处理</span><br><span class="hljs-comment">	 * 是则调用本类handle方法</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> handler 处理器</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> boolean</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(Object handler)</span></span>;<br>	<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 具体处理方法</span><br><span class="hljs-comment">	 * </span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> request</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> handler</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@param</span> argumentResolverMap</span><br><span class="hljs-comment">	 * <span class="hljs-doctag">@return</span> CustomModelAndView</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> CustomModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, CustomHandlerMapping handler,</span></span><br><span class="hljs-function"><span class="hljs-params">			Map&lt;String, ArgumentResolver&gt; argumentResolverMap)</span></span>;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现类CustomSimpleHandlerAdapter.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.servlet;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomService;<br><span class="hljs-keyword">import</span> com.hgl.mvc.resolver.ArgumentResolver;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对处理适配器的实现</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@CustomService(&quot;customSimpleHandlerAdapter&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomSimpleHandlerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CustomHandlerAdapter</span></span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CustomDispatcherServlet.class);<br>	<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> CustomModelAndView <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, CustomHandlerMapping handler,</span></span><br><span class="hljs-function"><span class="hljs-params">			Map&lt;String, ArgumentResolver&gt; argumentResolverMap)</span> </span>&#123;<br>		Method method = handler.getMethod();<br>		Object controller = handler.getController();<br>		Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();<br>		Object[] args = <span class="hljs-keyword">new</span> Object[parameterTypes.length];<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterTypes.length; i++) &#123;<br>			Class&lt;?&gt; parameterClass = parameterTypes[i];<br>			<span class="hljs-keyword">for</span> (Map.Entry&lt;String, ArgumentResolver&gt; entry : argumentResolverMap.entrySet()) &#123;<br>				ArgumentResolver argumentResolver = entry.getValue();<br>				<span class="hljs-keyword">if</span>(argumentResolver.support(parameterClass, i, method)) &#123;<br>					Object resolver = argumentResolver.argumentResolver(request, response, parameterClass, i, method);<br>					args[i] = resolver;<br>					<span class="hljs-keyword">break</span>;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">try</span> &#123;<br>			method.invoke(controller, args);<br>		&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) &#123;<br>			LOGGER.error(e.getMessage(), e);<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomModelAndView();<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(Object handler)</span> </span>&#123;<br>		<span class="hljs-comment">// 暂定实现为true</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>	&#125;<br>	<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h2><p>ArgumentResolver.java,作为上层接口，具体由实现类实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.resolver;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 参数解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ArgumentResolver</span> </span>&#123;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(Class&lt;?&gt; type, <span class="hljs-keyword">int</span> paramIndex, Method method)</span></span>;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">argumentResolver</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">			Class&lt;?&gt; type, <span class="hljs-keyword">int</span> paramIndex, Method method)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>HttpServletRequestArgumentResolver.java，用于解析HttpServletRequest参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.resolver;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomService;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HttpServletRequest参数解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@CustomService(&quot;httpServletRequestArgumentResolver&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServletRequestArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ArgumentResolver</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(Class&lt;?&gt; type, <span class="hljs-keyword">int</span> paramIndex, Method method)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> ServletRequest.class.isAssignableFrom(type);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">argumentResolver</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Class&lt;?&gt; type,</span></span><br><span class="hljs-function"><span class="hljs-params">			<span class="hljs-keyword">int</span> paramIndex, Method method)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> request;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>HttpServletResponseArgumentResolver.java，用于解析HttpServletResponse参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.resolver;<br><br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> javax.servlet.ServletResponse;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomService;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HttpServletResponse参数解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@CustomService(&quot;httpServletResponseArgumentResolver&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServletResponseArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ArgumentResolver</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(Class&lt;?&gt; type, <span class="hljs-keyword">int</span> paramIndex, Method method)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> ServletResponse.class.isAssignableFrom(type);<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">argumentResolver</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Class&lt;?&gt; type,</span></span><br><span class="hljs-function"><span class="hljs-params">			<span class="hljs-keyword">int</span> paramIndex, Method method)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> response;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>RequestParamArgumentResolver.java，用于解析CustomRequestParam定义的参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.mvc.resolver;<br><br><span class="hljs-keyword">import</span> java.lang.annotation.Annotation;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomRequestParam;<br><span class="hljs-keyword">import</span> com.hgl.mvc.annotation.CustomService;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RequestParam参数解析器</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@CustomService(&quot;requestParamArgumentResolver&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestParamArgumentResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ArgumentResolver</span> </span>&#123;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">support</span><span class="hljs-params">(Class&lt;?&gt; type, <span class="hljs-keyword">int</span> paramIndex, Method method)</span> </span>&#123;<br>		Annotation[][] annotations = method.getParameterAnnotations();<br>		Annotation[] currentField = annotations[paramIndex];<br>		<span class="hljs-keyword">for</span> (Annotation annotation : currentField) &#123;<br>			<span class="hljs-keyword">if</span>(CustomRequestParam.class.isAssignableFrom(annotation.getClass())) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">argumentResolver</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Class&lt;?&gt; type,</span></span><br><span class="hljs-function"><span class="hljs-params">			<span class="hljs-keyword">int</span> paramIndex, Method method)</span> </span>&#123;<br>		Annotation[][] annotations = method.getParameterAnnotations();<br>		Annotation[] currentField = annotations[paramIndex];<br>		<span class="hljs-keyword">for</span> (Annotation annotation : currentField) &#123;<br>			<span class="hljs-keyword">if</span>(CustomRequestParam.class.isAssignableFrom(annotation.getClass())) &#123;<br>				CustomRequestParam requestParam = (CustomRequestParam) annotation;<br>				String parameterName = requestParam.value();<br>				String parameterVal = request.getParameter(parameterName);<br>				<span class="hljs-keyword">return</span> parameterVal;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中AQS基本实现原理</title>
    <url>/2020/12/07/Java%E4%B8%ADAQS%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、AQS概述"><a href="#一、AQS概述" class="headerlink" title="一、AQS概述"></a>一、AQS概述</h1><p>AQS全名AbstractQueuedSynchronizer,意为抽象队列同步器，JUC(java.util.concurrent包)下面的Lock和其他一些并发工具类都是基于它来实现的。AQS维护了一个volatile的state和一个CLH（FIFO）双向队列。</p>
<p><img src="https://img-blog.csdnimg.cn/20200515111103669.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h1><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>state是一个由volatile修饰的int变量，它的访问方式有三种：</p>
<ul>
<li>getState()</li>
<li>setState(int newState)</li>
<li>compareAndSetState(int expect, int update)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 由volatile修饰的state</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于内存可见性的读</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> state;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于内存可见性的写</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newState)</span> </span>&#123;<br>    state = newState;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用CAS+volatile，基于原子性与可见性的对state进行设值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSetState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> expect, <span class="hljs-keyword">int</span> update)</span> </span>&#123;<br>    <span class="hljs-comment">// 使用Unsafe类，调用JNI方法</span><br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>资源获取主要有两种形式：</p>
<ul>
<li>独占式（EXCLUSIVE）</li>
</ul>
<p>仅有一个线程能在同一时刻获取到资源并处理，如ReentrantLock的实现。</p>
<ul>
<li>共享式（SHARED）</li>
</ul>
<p>多个线程可以同时获取到资源并处理，如Semaphore/CountDownLatch等。</p>
<p>AQS中大部分逻辑已经被实现，集成类只需要重写state的获取（acquire）与释放(release)方法，因为在AQS中，这些方法默认定义的实现方式都是抛出不支持操作异常，所以按需实现即可。</p>
<p>其中需要继承类重写的方法有：</p>
<ul>
<li>tryAcquire(int arg)</li>
</ul>
<p>此方法是独占式的获取资源方法，成功则返回true,失败返回false。</p>
<ul>
<li>tryRelease(int arg)</li>
</ul>
<p>此方法是独占式的释放资源方法，成功则返回true,失败返回false。</p>
<ul>
<li>tryAcquireShared(int arg)</li>
</ul>
<p>此方法是共享式的获取资源方法，返回负数表示失败，0表示获取成功，但是没有可用资源，正数表示获取成功，且有可用资源。</p>
<ul>
<li>tryReleaseShared(int arg)</li>
</ul>
<p>此方法是共享式的释放资源方法，如果允许唤醒后续等待线程则返回true,不允许则返回false。</p>
<ul>
<li>isHeldExclusively()</li>
</ul>
<p>判断当前线程是否正在独享资源，是则返回true,否则返回false。</p>
<h2 id="CLH-FIFO-队列"><a href="#CLH-FIFO-队列" class="headerlink" title="CLH(FIFO)队列"></a>CLH(FIFO)队列</h2><p>AQS中是通过内部类Node来维护一个CLH队列的。源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>       <span class="hljs-comment">/** 标记共享式访问 */</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>       <span class="hljs-comment">/** 标记独占式访问 */</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>       <span class="hljs-comment">/** 字段waitStatus的值，表示当前节点已取消等待 */</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>       <span class="hljs-comment">/**字段waitStatus的值，表示当前节点取消或释放资源后，通知下一个节点 */</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>       <span class="hljs-comment">/** 表示正在等待触发条件 */</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 表示下一个共享获取应无条件传播</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * Status field, taking on only the values:</span><br><span class="hljs-comment">        *   SIGNAL:     表示当前节点取消或释放资源后，通知下一个节点</span><br><span class="hljs-comment">        *   CANCELLED:  表示当前节点已取消等待</span><br><span class="hljs-comment">        *   CONDITION:  表示正在等待触发条件</span><br><span class="hljs-comment">        *   PROPAGATE:  表示下一个共享获取应无条件传播</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 前节点</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">volatile</span> Node prev;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 下一个节点</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">volatile</span> Node next;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 节点对应线程</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-keyword">volatile</span> Thread thread;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 下一个等待的节点</span><br><span class="hljs-comment">        */</span><br>       Node nextWaiter;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 是否是共享式访问</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>           <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>       &#125;<br><br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 返回前节点</span><br><span class="hljs-comment">        */</span><br>       <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>           Node p = prev;<br>           <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>           <span class="hljs-keyword">else</span><br>               <span class="hljs-keyword">return</span> p;<br>       &#125;<br><br>       Node() &#123;    <span class="hljs-comment">// 共享式访问的构造函数</span><br>       &#125;<br><br>       Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// 用于被添加等待者使用</span><br>           <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>           <span class="hljs-keyword">this</span>.thread = thread;<br>       &#125;<br><br>       Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// 用于Condition使用</span><br>           <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>           <span class="hljs-keyword">this</span>.thread = thread;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="独占模式-获取资源"><a href="#独占模式-获取资源" class="headerlink" title="独占模式-获取资源"></a>独占模式-获取资源</h2><p>使用AQS中的acquire(int arg)方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法分为4个部分：</p>
<ul>
<li>tryAcquire()</li>
</ul>
<p>需要自己实现的方法，如果获取到资源使用权，则返回true,反之fasle。如果获取到资源，返回true,!true为false,根据&amp;&amp;的短路性，则不会执行后续方法，直接跳过程序。如果未获取到资源，返回false,!false为true,则进入后续方法。</p>
<ul>
<li>addWaiter()</li>
</ul>
<p>如果未获取到资源使用权，则首先会调用此方法。上源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>    <span class="hljs-comment">// 封装当前线程和独占模式</span><br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 获取尾部节点</span><br>    Node pred = tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-comment">// CAS设置尾部节点</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 将为节点的下一节点指向当前node</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 如果尾结点为空或者设置尾结点失败</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> </span>&#123;<br>       <span class="hljs-comment">// 如果CAS设置未成功则死循环</span><br>       <span class="hljs-keyword">for</span> (;;) &#123;<br>           <span class="hljs-comment">// 获得尾结点</span><br>           Node t = tail;<br>           <span class="hljs-comment">// 如果尾节点为空，说明CLH队列为空，需要初始化</span><br>           <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123; <br>               <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> Node()))<br>                   tail = head;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-comment">// 设置当前节点的前驱节点</span><br>               node.prev = t;<br>               <span class="hljs-comment">// CAS设置当前节点为尾结点</span><br>               <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                   <span class="hljs-comment">// 设置后驱节点</span><br>                   t.next = node;<br>                   <span class="hljs-keyword">return</span> t;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>acquiredQueued()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-comment">// 标识资源获取是否失败</span><br>    <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 标识线程是否中断</span><br>        <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 获得当前节点的前驱节点</span><br>            <span class="hljs-keyword">final</span> Node p = node.predecessor();<br>            <span class="hljs-comment">// 如果前驱节点为头结点，说明快到当前节点了，尝试获取资源</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 获取资源成功</span><br>                <span class="hljs-comment">// 设置当前节点为头结点</span><br>                setHead(node);<br>                <span class="hljs-comment">// 取消前驱节点（以前的头部）的后节点，方便GC回收</span><br>                p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-comment">// 标识未失败</span><br>                failed = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-comment">// 返回中断标志</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 如果当前节点的前驱节点不是头结点或获取资源失败</span><br>            <span class="hljs-comment">// 需要用shouldParkAfterFailedAcquire函数判断是否需要阻塞该节点持有的线程</span><br>            <span class="hljs-comment">// 如果需要阻塞，则执行parkAndCheckInterrupt方法，并设置被中断</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果最终获取资源失败</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            <span class="hljs-comment">// 当前节点取消获取资源</span><br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>selfInterrupt()</li>
</ul>
<p>中断当前线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selfInterrupt</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="独占模式-释放资源"><a href="#独占模式-释放资源" class="headerlink" title="独占模式-释放资源"></a>独占模式-释放资源</h2><p>release() 释放资源并唤醒后继线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">release</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-comment">// 获取头结点</span><br>        Node h = head;<br>        <span class="hljs-comment">// 头结点不为空且等待状态值不为0</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-keyword">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 唤醒后续等待线程</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unparkSuccessor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> ws = node.waitStatus;<br>    <span class="hljs-comment">// 如果等待状态值小于0</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 使用CAS将waitStatus设置为0</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    Node s = node.next;<br>    <span class="hljs-comment">// 如果当前节点没有后继节点或者后继节点放弃竞争资源</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 从队列尾部循环直到当前节点，找到最近的且等待状态值小于0的节点</span><br>        <span class="hljs-keyword">for</span> (Node t = tail; t != <span class="hljs-keyword">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">// 如果找到的后继节点不为空,则唤醒其持有的线程</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-keyword">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AQS</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中CAS基本实现原理</title>
    <url>/2020/12/07/Java%E4%B8%ADCAS%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>了解CAS,首先要清楚JUC,那么什么是JUC呢？JUC就是java.util.concurrent包的简称。它有核心就是CAS与AQS。CAS是java.util.concurrent.atomic包的基础，如AtomicInteger、AtomicBoolean、AtomicLong等等类都是基于CAS。</p>
<p>什么是CAS呢？全称Compare And Swap，比较并交换。CAS有三个操作数，内存值V，旧的预期值E，要修改的新值N。当且仅当预期值E和内存值V相同时，将内存值V修改为N，否则什么都不做。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514163511601.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h1><p>如果我们需要对一个数进行加法操作，应该怎样去实现呢？我们模拟多个线程情况下进行操作。</p>
<p>ThreadDemo.java 实现一个Runnable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			addCount();<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCount</span><span class="hljs-params">()</span> </span>&#123;<br>		count++;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> count;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ThreadTest.java 创建线程池，提交10个线程执行，预期结果应该是1000</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		ExecutorService threadPool = Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>		ThreadDemo threadDemo = <span class="hljs-keyword">new</span> ThreadDemo();<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>			threadPool.submit(threadDemo);<br>		&#125;<br>        threadPool.shutdown();<br>		System.out.println(threadDemo.getCount());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 运行结果：874 或其他，与预期结果不符合。</p>
<p> 执行出来的结果并不是想象中的结果。这是为什么呢？这跟线程的执行过程有关。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514170915323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>所以我们需要在改变count，将值从高速缓冲区刷新到主内存后，让其他线程重新读取主内存中的值到自己的工作内存。</p>
<p>此时可以用<strong>volatile</strong>关键字。它的作用是保证对象在内存中的可见性。</p>
<p>修改ThreadDemo中的count字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p>此时执行结果：900 或其他，与预期结果不符合。</p>
<p>此时还是并未得出正确执行结果。为什么？听我细细道来。</p>
<p>线程安全主要体现在三个方面：</p>
<ul>
<li><strong>原子性</strong>：提供了互斥访问，同一时刻只能有一个线程对它进行操作</li>
<li><strong>可见性</strong>：一个线程对主内存的修改可以及时的被其他线程观察到</li>
<li><strong>有序性</strong>：一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序</li>
</ul>
<p>目前可见性已经实现了，缺少原子性的操作，因为同一时刻，多个线程对其操作，会将改动后的最新值读取到自己的工作内存进行操作，最终只能得到后一个执行线程操作的结果，所以相当于少了一步操作，就会造成数据的不一致。</p>
<p>此时可以使用JUC的Atomic包下面的类来进行操作。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514171804936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>Atomic类是使用<strong>CAS</strong>+<strong>volatile</strong>来实现原子性与可见性的<strong>。</strong></p>
<p>我们来改造一下TheadDemo.java中的实现方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			<span class="hljs-comment">// 递增</span><br>			count.getAndIncrement();<br>		&#125;<br>	&#125;<br>	<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> count.get();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 执行结果： 1000，符合预期值。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514172053590.png"></p>
<p> 接下来我们来分析一下AtomicInteger类的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        valueOffset = unsafe.objectFieldOffset<br>            (AtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(ex); &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br></code></pre></td></tr></table></figure>

<p>Unsafe类是不安全的类，它提供了一些底层的方法，我们是不能使用这个类的。AtomicInteger的值保存在value中，而valueOffset是value在内存中的偏移量，利用静态代码块使其类一加载的时候就赋值。value值使用volatile，保证其可见性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Atomically increments by one the current value.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the previous value</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndIncrement</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4)</span> </span>&#123;<br>	<span class="hljs-keyword">int</span> var5;<br>	<span class="hljs-keyword">do</span> &#123;<br>		var5 = <span class="hljs-keyword">this</span>.getIntVolatile(var1, var2);<br>	&#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));<br><br>	<span class="hljs-keyword">return</span> var5;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>var1表示当前对象，var2表示value在内存中的偏移量，var4为增加的值。var5为调用底层方法获取value的值</p>
<p>compareAndSwapInt方法通过var1和var2获取当前内存中的value值，并与var5进行比对，如果一致，就将var5+var4的值赋给value,并返回true,否则返回false</p>
<p>由do while语句可知，如果这次没有设置进去值，就重复执行此过程。这一过程称为自旋。</p>
<p>compareAndSwapInt是JNI(Java Native Interface)提供的方法，可以是其他语言写的。</p>
<h1 id="三、与synchronized比较"><a href="#三、与synchronized比较" class="headerlink" title="三、与synchronized比较"></a>三、与<strong>synchronized比较</strong></h1><p>使用synchronized进行加法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.test;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadDemo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>			<span class="hljs-comment">// 递增</span><br>			<span class="hljs-keyword">synchronized</span> (ThreadDemo.class) &#123;<br>				count++;<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> count;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果： 1000，符合预期值。</p>
<p><img src="https://img-blog.csdnimg.cn/20200514174035911.png"></p>
<p>使用synchronized和AtomicInteger都能得到预期结果，但是他们之间各有什么劣势呢？</p>
<p>synchronized是重量级锁，是悲观锁，就是无论你线程之间发不发生竞争关系，它都认为会发生竞争，从而每次执行都会加锁。</p>
<p>在并发量大的情况下，如果锁的时间较长，那将会严重影响系统性能。</p>
<p>CAS操作中我们可以看到getAndAddInt方法的自旋操作，如果长时间自旋，那么肯定会对系统造成压力。而且如果value值从A-&gt;B-&gt;A,那么CAS就会认为这个值没有被操作过，这个称为CAS操作的”ABA”问题。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>CAS</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot消息国际化配置</title>
    <url>/2020/12/07/SpringBoot%E6%B6%88%E6%81%AF%E5%9B%BD%E9%99%85%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、目的"><a href="#一、目的" class="headerlink" title="一、目的"></a>一、目的</h1><p>针对不同地区，设置不同的语言信息。</p>
<p>SpringBoot国际化配置文件默认放在classpath:message.properties，如果自定义消息配置文件，需要application.properties或application.yml中设置spring.messages.basename的值。</p>
<h1 id="二、步骤"><a href="#二、步骤" class="headerlink" title="二、步骤"></a>二、步骤</h1><p>在src/main/resources 下建i18n文件夹</p>
<p>在i18n文件夹中建立messages.properties  找不到语言配置时，使用此文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hello&#x3D;你好_默认<br></code></pre></td></tr></table></figure>

<p>在i18n文件夹中建立messages_en_US.properties 英文语言配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hello&#x3D;hello_English<br></code></pre></td></tr></table></figure>

<p>在i18n文件夹中建立messages_zh_CN.properties 中文语言配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">hello&#x3D;你好_中文<br></code></pre></td></tr></table></figure>

<p><strong>MessageConfig.java</strong> </p>
<p>对消息的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package com.spring.security.config.spring;<br><br>import java.util.Locale;<br><br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br><br>import org.springframework.beans.factory.annotation.Value;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.context.i18n.LocaleContext;<br>import org.springframework.context.support.ResourceBundleMessageSource;<br>import org.springframework.util.Assert;<br>import org.springframework.web.servlet.LocaleResolver;<br>import org.springframework.web.servlet.i18n.AbstractLocaleContextResolver;<br>import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;<br>import org.springframework.web.servlet.i18n.SessionLocaleResolver;<br><br>@Configuration<br>public class MessageConfig extends AbstractLocaleContextResolver&#123;<br>	<br>	@Value(&quot;$&#123;spring.messages.basename&#125;&quot;)<br>	public String[] basenames;<br>	<br>	@Bean(name &#x3D; &quot;messageSource&quot;)<br>	public ResourceBundleMessageSource resourceBundleMessageSource() &#123;<br>		ResourceBundleMessageSource source &#x3D; new ResourceBundleMessageSource();<br>		if (basenames !&#x3D; null) &#123;<br>			for (int i &#x3D; 0; i &lt; basenames.length; i++) &#123;<br>				String basename &#x3D; basenames[i];<br>				Assert.hasText(basename, &quot;Basename must not be empty&quot;);<br>				this.basenames[i] &#x3D; basename.trim();<br>			&#125;<br>			source.setBasenames(basenames);<br>		&#125; else &#123;<br>			this.basenames &#x3D; new String[0];<br>			source.setBasename(basenames[0]);<br>		&#125;<br>		source.setDefaultEncoding(&quot;UTF-8&quot;);<br>		source.setUseCodeAsDefaultMessage(true);<br>		return source;<br>	&#125;<br><br>    @Bean<br>    public LocaleResolver localeResolver() &#123;<br>        SessionLocaleResolver slr &#x3D; new SessionLocaleResolver();<br>        slr.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);<br>        return slr;<br>    &#125;<br><br>    &#x2F;**<br>     * 国际化，设置url识别参数<br>     *<br>     * @return<br>     *&#x2F;<br>    @Bean<br>    public LocaleChangeInterceptor localeChangeInterceptor() &#123;<br>        LocaleChangeInterceptor lci &#x3D; new LocaleChangeInterceptor();<br>        lci.setParamName(&quot;lang&quot;);<br>        return lci;<br>    &#125;<br><br>	@Override<br>	public LocaleContext resolveLocaleContext(HttpServletRequest request) &#123;<br>		return null;<br>	&#125;<br><br>	@Override<br>	public void setLocaleContext(HttpServletRequest request, HttpServletResponse response,<br>			LocaleContext localeContext) &#123;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>SpringUtils.java</strong></p>
<p>Spring工具类，用于获取ApplicationContext</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package com.spring.security.common.utils;<br><br>import org.springframework.beans.BeansException;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.ApplicationContextAware;<br>import org.springframework.stereotype.Service;<br><br>&#x2F;**<br> * Spring容器<br> *&#x2F;<br>@Service<br>public class SpringUtils implements ApplicationContextAware &#123;<br><br>    private static ApplicationContext context &#x3D; null;<br><br>    @Override<br>    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;<br>        if (context &#x3D;&#x3D; null) &#123;<br>            context &#x3D; applicationContext;<br>        &#125;<br>    &#125;<br><br>    &#x2F;**<br>     * 获取容器<br>     *<br>     * @return 容器<br>     *&#x2F;<br>    public static ApplicationContext getContext() &#123;<br>        return context;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>MessageUtils.java</strong></p>
<p>封装获取message的工具类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package com.spring.security.common.utils;<br><br>import java.util.Locale;<br><br>import org.springframework.context.i18n.LocaleContextHolder;<br>import org.springframework.context.support.ReloadableResourceBundleMessageSource;<br><br>public class MessageUtils &#123;<br>	<br>	public static String getMessage(String code) &#123;<br>		 Locale locale &#x3D; LocaleContextHolder.getLocale();<br>		 ReloadableResourceBundleMessageSource reloadableResourceBundleMessageSource &#x3D; new ReloadableResourceBundleMessageSource();<br>	     String message &#x3D; reloadableResourceBundleMessageSource.getMessage(code, null, locale);<br>	     return message;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> <strong>WebMvcConfig.java</strong></p>
<p>mvc配置，解决跨域，接口中文乱码，添加语言拦截器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package com.spring.security.config.spring;<br><br>import java.nio.charset.Charset;<br>import java.util.List;<br><br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.http.converter.HttpMessageConverter;<br>import org.springframework.http.converter.StringHttpMessageConverter;<br>import org.springframework.web.servlet.config.annotation.CorsRegistry;<br>import org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;<br>import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;<br><br>@Configuration<br>public class WebMvcConfig extends WebMvcConfigurationSupport &#123;<br>	<br>	@Autowired<br>	private LocaleChangeInterceptor localeChangeInterceptor;<br><br>	&#x2F;**<br>	 * 解决跨域<br>	 *&#x2F;<br>	@Override<br>	protected void addCorsMappings(CorsRegistry registry) &#123;<br>		registry<br>		.addMapping(&quot;&#x2F;**&quot;)<br>		.allowedHeaders(&quot;*&quot;)<br>		.allowedMethods(&quot;*&quot;)<br>		.allowedOrigins(&quot;*&quot;)<br>		.allowCredentials(true);<br>	&#125;<br><br>	&#x2F;**<br>	 * 配置消息转换器<br>	 * 解决返回String乱码<br>	 *&#x2F;<br>	@Override<br>	protected void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) &#123;<br>		super.configureMessageConverters(converters);<br>		converters.add(responseBodyConverter());<br>	&#125;<br>	<br>	@Bean<br>    public HttpMessageConverter&lt;String&gt; responseBodyConverter() &#123;<br>        return new StringHttpMessageConverter(Charset.forName(&quot;UTF-8&quot;));<br>    &#125;<br><br>	@Override<br>	protected void addInterceptors(InterceptorRegistry registry) &#123;<br>		super.addInterceptors(registry);<br>		registry.addInterceptor(localeChangeInterceptor);<br>	&#125;<br>	<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h1><p>测试接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">package com.spring.security.controller;<br><br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.RestController;<br><br>import com.spring.security.common.utils.I18nUtils;<br><br>@RestController<br>public class TestController &#123;<br>	<br>	@GetMapping(&quot;&#x2F;test&quot;)<br>	public String doTest() &#123;<br>		return I18nUtils.getMessage(&quot;hello&quot;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://img-blog.csdnimg.cn/20200513174715983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

 <img src="https://img-blog.csdnimg.cn/20200513174759460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>源码地址： <a href="https://github.com/hanguilin/boot-security">https://github.com/hanguilin/boot-security</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>消息国际化</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot2.0配置多数据源</title>
    <url>/2020/12/07/SpringBoot2-0%E9%85%8D%E7%BD%AE%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/</url>
    <content><![CDATA[<h1 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h1><p>配置多数据源意思就是在一个项目中使用多个数据库，在项目使用中可以不用手动切换数据库来实现不同数据库的数据获取和更新。</p>
<p>源码地址： <a href="https://github.com/hanguilin/boot-security">https://github.com/hanguilin/boot-security</a></p>
<p>项目环境： SpringBoot 2.1.9、Spring Data Jpa</p>
<p>项目文件夹：</p>
<p><img src="https://img-blog.csdnimg.cn/20200513115609311.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p><strong>application.properties</strong></p>
<ul>
<li>spring.datasource.primary.driver-class-name 数据库驱动包</li>
<li>spring.datasource.primary.jdbc-url 数据库连接</li>
<li>spring.datasource.primary.username 用户名</li>
<li>spring.datasource.primary.password 密码</li>
</ul>
<p>数据库配置别名可自定义，此处一级库为primmary。二级数据库配置同上，别名为secondary。</p>
<p>hikara为数据库连接池的配置，同类产品还有druid。</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">server.port=<span class="hljs-number">8080</span><br><br>##########一级数据库配置##########<br>spring.datasource.primary.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span></span>=com.mysql.jdbc.Driver<br>spring.datasource.primary.jdbc-url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/primary_db?autoReconnect=true&amp;useUnicode=true&amp;useSSL=false</span><br>spring.datasource.primary.username=root<br>spring.datasource.primary.password=****<br>#最大连接数<br>spring.datasource.primary.hikari.maximum-pool-size=<span class="hljs-number">20</span><br>#连接超时毫秒<br>spring.datasource.primary.hikari.connection-timeout=<span class="hljs-number">60000</span><br>#空闲的连接的生命时长毫秒<br>spring.datasource.primary.hikari.idle-timeout=<span class="hljs-number">60000</span><br>#连接的生命时长毫秒<br>spring.datasource.primary.hikari.max-lifetime=<span class="hljs-number">60000</span><br>#验证连接有效性毫秒<br>spring.datasource.primary.hikari.validation-timeout=<span class="hljs-number">3000</span><br>#登录超时毫秒<br>spring.datasource.primary.hikari.login-timeout=<span class="hljs-number">5</span><br>##########一级数据库配置##########<br><br>##########二级数据库配置##########<br>spring.datasource.secondary.driver-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">name</span></span>=com.mysql.jdbc.Driver<br>spring.datasource.secondary.jdbc-url=jdbc:mysql:<span class="hljs-comment">//localhost:3306/secondary_db?autoReconnect=true&amp;useUnicode=true</span><br>spring.datasource.secondary.username=root<br>spring.datasource.secondary.password=****<br>#最大连接数<br>spring.datasource.secondary.hikari.maximum-pool-size=<span class="hljs-number">20</span><br>#连接超时毫秒<br>spring.datasource.secondary.hikari.connection-timeout=<span class="hljs-number">60000</span><br>#空闲的连接的生命时长毫秒<br>spring.datasource.secondary.hikari.idle-timeout=<span class="hljs-number">60000</span><br>#连接的生命时长毫秒<br>spring.datasource.secondary.hikari.max-lifetime=<span class="hljs-number">60000</span><br>#验证连接有效性毫秒<br>spring.datasource.secondary.hikari.validation-timeout=<span class="hljs-number">3000</span><br>#登录超时毫秒<br>spring.datasource.secondary.hikari.login-timeout=<span class="hljs-number">5</span><br>##########二级数据库配置##########<br><br>##########hibernate配置##########<br>spring.jpa.hibernate.ddl-auto=create-drop<br>spring.jpa.show-sql=<span class="hljs-keyword">true</span><br>spring.jpa.properties.hibernate.hbm2ddl.auto=update<br>spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect<br>##########hibernate配置##########<br></code></pre></td></tr></table></figure>

<p><strong>DataSourcesConfig.java</strong></p>
<ul>
<li>@Bean(name = “primaryDataSource”)</li>
</ul>
<p>将该返回对象交由Spring管理，bean名称为primaryDataSource。</p>
<ul>
<li>@Qualifier(“primaryDataSource”)</li>
</ul>
<p>根据名称将bean注入到对象。</p>
<ul>
<li>@Primary</li>
</ul>
<p>自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常。</p>
<ul>
<li> @ConfigurationProperties(prefix=”spring.datasource.primary”)</li>
</ul>
<p>将前缀为spring.datasource.primary的配置注入到对应名称的属性字段中。</p>
<p>此类作用为生成两级DataSource，交由Spring管理，方便后续从Spring中调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.config.datasource;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;<br><span class="hljs-keyword">import</span> org.springframework.boot.jdbc.DataSourceBuilder;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Primary;<br><br><span class="hljs-keyword">import</span> com.zaxxer.hikari.HikariDataSource;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataSourcesConfig</span> </span>&#123;<br>	<br>    <span class="hljs-meta">@Bean(name = &quot;primaryDataSource&quot;)</span><br>    <span class="hljs-meta">@Qualifier(&quot;primaryDataSource&quot;)</span><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@ConfigurationProperties(prefix=&quot;spring.datasource.primary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">primaryDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> DataSourceBuilder.create()<br>        		.type(HikariDataSource.class)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;secondaryDataSource&quot;)</span><br>    <span class="hljs-meta">@Qualifier(&quot;secondaryDataSource&quot;)</span><br>    <span class="hljs-meta">@ConfigurationProperties(prefix=&quot;spring.datasource.secondary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">secondaryDataSource</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> DataSourceBuilder.create()<br>        		.type(HikariDataSource.class)<br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>PrimaryConfig.java</strong></p>
<ul>
<li>@Configuration</li>
</ul>
<p>在Spring中注册成bean</p>
<ul>
<li>@EnableTransactionManagement</li>
</ul>
<p>开启事务管理</p>
<p>@EnableJpaRepositories(<br>    entityManagerFactoryRef=”entityManagerFactoryPrimary”,<br>    transactionManagerRef=”transactionManagerPrimary”,<br>    basePackages= { “com.spring.security.dao.primary” }) </p>
<ul>
<li>@EnableJpaRepositories</li>
</ul>
<p>注解用于Srping JPA的代码配置，用于取代xml形式的配置文件</p>
<ul>
<li>entityManagerFactoryRef</li>
</ul>
<p>实体管理工厂，下文代码中配置基础包为com.spring.security.entity.primary</p>
<ul>
<li>transactionManagerRef</li>
</ul>
<p>事务管理</p>
<ul>
<li>basePackages</li>
</ul>
<p>持久层基础包扫描，此处配置为com.spring.security.dao.primary</p>
<p>上述两个包的配置，意为一级数据库的实体和dao蹭接口分别所处的位置。当jpa进行实体映射时，对应包下面的实体会映射到不通的数据库。dao层接口也会随之切换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.config.datasource;<br><br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">import</span> javax.persistence.EntityManager;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;<br><span class="hljs-keyword">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Primary;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;<br><span class="hljs-keyword">import</span> org.springframework.transaction.PlatformTransactionManager;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@EnableJpaRepositories(</span><br><span class="hljs-meta">        entityManagerFactoryRef=&quot;entityManagerFactoryPrimary&quot;,</span><br><span class="hljs-meta">        transactionManagerRef=&quot;transactionManagerPrimary&quot;,</span><br><span class="hljs-meta">        basePackages= &#123; &quot;com.spring.security.dao.primary&quot; &#125;)</span> <span class="hljs-comment">//设置Repository所在位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrimaryConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span> <br>    <span class="hljs-meta">@Qualifier(&quot;primaryDataSource&quot;)</span><br>    <span class="hljs-keyword">private</span> DataSource primaryDataSource;<br>    <br>    <span class="hljs-meta">@Autowired(required=false)</span><br>    <span class="hljs-keyword">private</span> JpaProperties jpaProperties;<br><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@Bean(name = &quot;entityManagerPrimary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EntityManager <span class="hljs-title">entityManager</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> entityManagerFactoryPrimary(builder).getObject().createEntityManager();<br>    &#125;<br><br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@Bean(name = &quot;entityManagerFactoryPrimary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactoryPrimary</span> <span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder<br>                .dataSource(primaryDataSource)<br>                .properties(getVendorProperties())<br>                .packages(<span class="hljs-string">&quot;com.spring.security.entity.primary&quot;</span>) <span class="hljs-comment">//设置实体类所在位置</span><br>                .persistenceUnit(<span class="hljs-string">&quot;primaryPersistenceUnit&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; <span class="hljs-title">getVendorProperties</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jpaProperties.getHibernateProperties(<span class="hljs-keyword">new</span> HibernateSettings());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Primary</span><br>    <span class="hljs-meta">@Bean(name = &quot;transactionManagerPrimary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManagerPrimary</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(entityManagerFactoryPrimary(builder).getObject());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>SecondaryConfig.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.spring.security.config.datasource;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.HibernateSettings;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;<br><span class="hljs-keyword">import</span> org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.config.EnableJpaRepositories;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.JpaTransactionManager;<br><span class="hljs-keyword">import</span> org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;<br><span class="hljs-keyword">import</span> org.springframework.transaction.PlatformTransactionManager;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.EnableTransactionManagement;<br><br><span class="hljs-keyword">import</span> javax.persistence.EntityManager;<br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@EnableJpaRepositories(</span><br><span class="hljs-meta">        entityManagerFactoryRef=&quot;entityManagerFactorySecondary&quot;,</span><br><span class="hljs-meta">        transactionManagerRef=&quot;transactionManagerSecondary&quot;,</span><br><span class="hljs-meta">        basePackages= &#123; &quot;com.spring.security.dao.secondary&quot; &#125;)</span> <span class="hljs-comment">//设置Repository所在位置</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondaryConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JpaProperties jpaProperties;<br>    <br>    <span class="hljs-meta">@Autowired</span> <br>    <span class="hljs-meta">@Qualifier(&quot;secondaryDataSource&quot;)</span><br>    <span class="hljs-keyword">private</span> DataSource secondaryDataSource;<br><br>    <span class="hljs-meta">@Bean(name = &quot;entityManagerSecondary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> EntityManager <span class="hljs-title">entityManager</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> entityManagerFactorySecondary(builder).getObject().createEntityManager();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;entityManagerFactorySecondary&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="hljs-title">entityManagerFactorySecondary</span> <span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder<br>                .dataSource(secondaryDataSource)<br>                .properties(getVendorProperties())<br>                .packages(<span class="hljs-string">&quot;com.spring.security.entity.secondary&quot;</span>) <span class="hljs-comment">//设置实体类所在位置</span><br>                .persistenceUnit(<span class="hljs-string">&quot;secondaryPersistenceUnit&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Map&lt;String, Object&gt; <span class="hljs-title">getVendorProperties</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jpaProperties.getHibernateProperties(<span class="hljs-keyword">new</span> HibernateSettings());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(name = &quot;transactionManagerSecondary&quot;)</span><br>    <span class="hljs-function">PlatformTransactionManager <span class="hljs-title">transactionManagerSecondary</span><span class="hljs-params">(EntityManagerFactoryBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JpaTransactionManager(entityManagerFactorySecondary(builder).getObject());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果需要扩展更多数据库，可以根据上述配置自行增加。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>多数据源</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程之闭锁与栅栏</title>
    <url>/2020/12/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%97%AD%E9%94%81%E4%B8%8E%E6%A0%85%E6%A0%8F/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>闭锁与栅栏是在多线程编程中的概念，因为在多线程中，我们不能控制线程的执行状态，所以给线程加锁，让其按照我们的想法有秩序的执行。</p>
<ul>
<li>闭锁</li>
</ul>
<p>CountDownLatch，实例化时需要传入一个int类型的数字（count），意为等待count个线程完成之后才能执行下一步动作。</p>
<p>如今天要做的事情是吃晚饭，再去散步。假设11个人相约晚饭后一起去散步，我们得等11个人全都吃完晚饭了才能出发去散步。简而言之就是做了才到达某一种状态。</p>
<ul>
<li>栅栏</li>
</ul>
<p>CyclicBarrier，实例化时需要传入一个int类型的数字（parties），意为等待parties个线程都准备就绪后才能执行自己的任务。</p>
<p>如今天要做的事情是吃晚饭，8个人约好一起去某餐厅吃饭，得等到人齐了才能去吃饭。简而言之就是到达某种状态后一起做。</p>
<h1 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h1><h2 id="闭锁-CountDownLatch"><a href="#闭锁-CountDownLatch" class="headerlink" title="闭锁 CountDownLatch"></a>闭锁 CountDownLatch</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		CountDownLatch latch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">3</span>);<br> <br>                <span class="hljs-comment">// 模拟三个任务</span><br>		List&lt;String&gt; jobs = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		jobs.add(<span class="hljs-string">&quot;first&quot;</span>);<br>		jobs.add(<span class="hljs-string">&quot;second&quot;</span>);<br>		jobs.add(<span class="hljs-string">&quot;third&quot;</span>);<br>        <br>                <span class="hljs-comment">// 循环执行任务</span><br>		<span class="hljs-keyword">for</span> (String job : jobs) &#123;<br>			<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : 进入run方法&quot;</span>);<br>					latch.countDown();<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : 执行&quot;</span> + job);<br>				&#125;<br>			&#125;).start();<br>		&#125;<br>		<br>		<span class="hljs-keyword">try</span> &#123;<br>			latch.await();<br>		&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>			e.printStackTrace();<br>		&#125;<br>		<span class="hljs-comment">// 任务都执行完后才执行</span><br>		System.out.println(<span class="hljs-string">&quot;回到main线程&quot;</span>);<br>	&#125;<br><br>&#125;<br> <br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>Thread-1 : 进入run方法</p>
<p>Thread-2 : 进入run方法</p>
<p>Thread-2 : 执行third</p>
<p>Thread-0 : 进入run方法</p>
<p>Thread-1 : 执行second</p>
<p>Thread-0 : 执行first</p>
<p>回到main线程</p>
<p>通过执行结果可看出，当所有线程都执行完后才能回到主线程继续执行后面的输出。</p>
<h2 id="栅栏-CyclicBarrier"><a href="#栅栏-CyclicBarrier" class="headerlink" title="栅栏 CyclicBarrier"></a>栅栏 CyclicBarrier</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.BrokenBarrierException;<br><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		CyclicBarrier barrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">3</span>);<br>		<span class="hljs-comment">// 模拟创建三个任务</span><br>		List&lt;String&gt; jobs = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		jobs.add(<span class="hljs-string">&quot;first&quot;</span>);<br>		jobs.add(<span class="hljs-string">&quot;second&quot;</span>);<br>		jobs.add(<span class="hljs-string">&quot;third&quot;</span>);<br>		<span class="hljs-comment">//循环执行任务</span><br>		<span class="hljs-keyword">for</span> (String job : jobs) &#123;<br>			<span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br><br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : 进入run方法&quot;</span>);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">// 等待</span><br>						barrier.await();<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>						e.printStackTrace();<br>					&#125;<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : 执行&quot;</span> + job);<br>				&#125;<br>			&#125;).start();<br>		&#125;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>Thread-1 : 进入run方法</p>
<p>Thread-2 : 进入run方法</p>
<p>Thread-0 : 进入run方法</p>
<p>Thread-0 : 执行first</p>
<p>Thread-1 : 执行second</p>
<p>Thread-2 : 执行third</p>
<p>通过执行结果可看出，当所有线程都执行都进入到run方法后，才能继续执行自己内部的方法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
        <tag>闭锁</tag>
        <tag>栅栏</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池原理及使用方式</title>
    <url>/2020/12/07/%E6%B5%85%E8%B0%88Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h1><ul>
<li>什么是线程池？</li>
</ul>
<p>池的概念大家也许都有所听闻，池就是相当于一个容器，里面有许许多多的东西你可以即拿即用。java中有线程池、连接池等等。线程池就是在系统启动或者实例化池时创建一些空闲的线程，等待工作调度，执行完任务后，线程并不会立即被销毁，而是重新处于空闲状态，等待下一次调度。</p>
<ul>
<li>线程池的工作机制？</li>
</ul>
<p>在线程池的编程模式中，任务提交并不是直接提交给线程，而是提交给池。线程池在拿到任务之后，就会寻找有没有空闲的线程，有则分配给空闲线程执行，暂时没有则会进入等待队列，继续等待空闲线程。如果超出最大接受的工作数量，则会触发线程池的拒绝策略。</p>
<ul>
<li>为什么使用线程池？</li>
</ul>
<p>线程的创建与销毁需要消耗大量资源，重复的创建与销毁明显不必要。而且池的好处就是响应快，需要的时候自取，就不会存在等待创建的时间。线程池可以很好地管理系统内部的线程，如数量以及调度。</p>
<h1 id="二、常用线程池介绍"><a href="#二、常用线程池介绍" class="headerlink" title="二、常用线程池介绍"></a>二、常用线程池介绍</h1><p>Java类ExecutorService是线程池的父接口，并非顶层接口。以下四种常用线程池的类型都可以是ExecutorService。</p>
<ul>
<li>单一线程池 Executors.newSingleThreadExecutor()</li>
</ul>
<p>内部只有唯一一个线程进行工作调度，可以保证任务的执行顺序（FIFO,LIFO）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建单一线程池</span><br>		ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<br>		List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		list.add(<span class="hljs-string">&quot;first&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;second&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;third&quot;</span>);<br>		list.forEach(o -&gt; &#123;<br>			<span class="hljs-comment">// 遍历集合提交任务</span><br>			singleThreadExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>				<br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + o);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">// 间隔1s</span><br>						Thread.sleep(<span class="hljs-number">1000</span>);<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						e.printStackTrace();<br>					&#125;<br>				&#125;<br>			&#125;);<br>		&#125;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 执行结果：</p>
<p>pool-1-thread-1 : first</p>
<p>pool-1-thread-1 : second</p>
<p>pool-1-thread-1 : third</p>
<ul>
<li>可缓存线程池 Executors.newCachedThreadPool() </li>
</ul>
<p>如果线程池中有可使用的线程，则使用，如果没有，则在池中新建一个线程，可缓存线程池中线程数量最大为Integer.MAX_VALUE。通常用它来运行一些执行时间短，且经常用到的任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建可缓存线程池</span><br>		ExecutorService cachedThreadPool = Executors.newCachedThreadPool();<br>		List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		list.add(<span class="hljs-string">&quot;first&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;second&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;third&quot;</span>);<br>		list.forEach(o -&gt; &#123;<br>			<br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-comment">// 间隔3s</span><br>				Thread.sleep(<span class="hljs-number">3000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<br>			<span class="hljs-comment">// 遍历集合提交任务</span><br>			cachedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>				<br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + o);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">// 间隔1s</span><br>						Thread.sleep(<span class="hljs-number">1000</span>);<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						e.printStackTrace();<br>					&#125;<br>				&#125;<br>			&#125;);<br>		&#125;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>pool-1-thread-1 : first</p>
<p>pool-1-thread-1 : second</p>
<p>pool-1-thread-1 : third</p>
<p>因为间隔时间长，下一个任务运行时，上一个任务已经完成，所以线程可以继续复用，如果间隔时间调短，那么部分线程将会使用新线程来运行。</p>
<p>把每个任务等待时间从3s调低至1s:</p>
<p>执行结果：</p>
<p>pool-1-thread-1 : first</p>
<p>pool-1-thread-2 : second</p>
<p>pool-1-thread-1 : third</p>
<ul>
<li>定长线程池 Executors.newFixedThreadPool(int nThreads)</li>
</ul>
<p>创建一个固定线程数量的线程池，参数手动传入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建可缓存线程池</span><br>		ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br>		List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		list.add(<span class="hljs-string">&quot;first&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;second&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;third&quot;</span>);<br>		list.add(<span class="hljs-string">&quot;fourth&quot;</span>);<br>		list.forEach(o -&gt; &#123;<br>			<br>			<span class="hljs-keyword">try</span> &#123;<br>				<span class="hljs-comment">// 间隔1s</span><br>				Thread.sleep(<span class="hljs-number">1000</span>);<br>			&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>				e.printStackTrace();<br>			&#125;<br>			<br>			<span class="hljs-comment">// 遍历集合提交任务</span><br>			fixedThreadPool.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>				<br>				<span class="hljs-meta">@Override</span><br>				<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>					System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : &quot;</span> + o);<br>					<span class="hljs-keyword">try</span> &#123;<br>						<span class="hljs-comment">// 间隔1s</span><br>						Thread.sleep(<span class="hljs-number">1000</span>);<br>					&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>						e.printStackTrace();<br>					&#125;<br>				&#125;<br>			&#125;);<br>		&#125;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>pool-1-thread-1 : first</p>
<p>pool-1-thread-2 : second</p>
<p>pool-1-thread-3 : third</p>
<p>pool-1-thread-1 : fourth </p>
<ul>
<li>定时线程池 Executors.newScheduledThreadPool(int corePoolSize)</li>
</ul>
<p>创建一个定长线程池，支持定时及周期性任务执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ScheduledExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 创建定长线程池、支持定时、延迟、周期性执行任务</span><br>		ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="hljs-number">3</span>);<br>		scheduledThreadPool.scheduleAtFixedRate(<span class="hljs-keyword">new</span> Runnable() &#123;<br><br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; : 1秒后每隔3秒执行一次&quot;</span>);<br>			&#125;<br>		&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p>pool-1-thread-1 : 1秒后每隔3秒执行一次</p>
<p>pool-1-thread-1 : 1秒后每隔3秒执行一次</p>
<p>pool-1-thread-2 : 1秒后每隔3秒执行一次</p>
<p>pool-1-thread-2 : 1秒后每隔3秒执行一次</p>
<p>pool-1-thread-2 : 1秒后每隔3秒执行一次</p>
<p>pool-1-thread-2 : 1秒后每隔3秒执行一次</p>
<p>pool-1-thread-2 : 1秒后每隔3秒执行一次</p>
<h1 id="三、自定义线程池"><a href="#三、自定义线程池" class="headerlink" title="三、自定义线程池"></a>三、自定义线程池</h1><p>常用构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadPoolExecutor(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)<br></code></pre></td></tr></table></figure>

<p> 参数说明：</p>
<p>1、corePoolSize 核心线程数大小，当线程数&lt;corePoolSize ，会创建线程执行runnable</p>
<p>2、maximumPoolSize 最大线程数， 当线程数 &gt;= corePoolSize的时候，会把runnable放入workQueue中</p>
<p>3、keepAliveTime  保持存活时间，当线程数大于corePoolSize的空闲线程能保持的最大时间。</p>
<p>4、unit 时间单位</p>
<p>5、workQueue 保存任务的阻塞队列</p>
<p>6、threadFactory 创建线程的工厂</p>
<p>7、handler 拒绝策略</p>
<p>任务执行顺序：</p>
<p>​    1、当线程数小于corePoolSize时，创建线程执行任务。</p>
<p>​    2、当线程数大于等于corePoolSize并且workQueue没有满时，放入workQueue中</p>
<p>​    3、线程数大于等于corePoolSize并且当workQueue满时，新任务新建线程运行，线程总数要小于maximumPoolSize</p>
<p>​    4、当线程总数等于maximumPoolSize并且workQueue满了的时候执行handler的rejectedExecution。也就是拒绝策略。</p>
<p>ThreadPoolExecutor默认有四个拒绝策略：</p>
<p>​    1、new ThreadPoolExecutor.AbortPolicy()  直接抛出异常RejectedExecutionException</p>
<p>​    2、new ThreadPoolExecutor.CallerRunsPolicy()  直接调用run方法并且阻塞执行</p>
<p>​    3、new ThreadPoolExecutor.DiscardPolicy()  直接丢弃后来的任务</p>
<p>​    4、new ThreadPoolExecutor.DiscardOldestPolicy()  丢弃在队列中队首的任务</p>
<p>缓冲队列BlockingQueue：</p>
<p> BlockingQueue是双缓冲队列。BlockingQueue内部使用两条队列，允许两个线程同时向队列一个存储，一个取出操作。在保证并发安全的同时，提高了队列的存取效率。</p>
<p>常用的几种BlockingQueue：</p>
<ul>
<li>ArrayBlockingQueue（int i）:规定大小的BlockingQueue，其构造必须指定大小。其所含的对象是FIFO顺序排序的。</li>
<li>LinkedBlockingQueue（）或者（int i）:大小不固定的BlockingQueue，若其构造时指定大小，生成的BlockingQueue有大小限制，不指定大小，其大小有Integer.MAX_VALUE来决定。其所含的对象是FIFO顺序排序的。</li>
<li>PriorityBlockingQueue（）或者（int i）:类似于LinkedBlockingQueue，但是其所含对象的排序不是FIFO，而是依据对象的自然顺序或者构造函数的Comparator决定。</li>
<li>SynchronizedQueue（）:特殊的BlockingQueue，对其的操作必须是放和取交替完成。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingDeque;<br><span class="hljs-keyword">import</span> java.util.concurrent.RejectedExecutionHandler;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolTest</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>		<span class="hljs-comment">// 工作队列</span><br>		LinkedBlockingDeque&lt;Runnable&gt; workQueue = <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;Runnable&gt;();<br>		<span class="hljs-comment">// 拒绝策略</span><br>		RejectedExecutionHandler handler = <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy();<br>		ThreadPoolExecutor threadPoolExecutor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, TimeUnit.MILLISECONDS, workQueue, handler);<br>		threadPoolExecutor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>			<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>				System.out.println(<span class="hljs-string">&quot;自定义线程池&quot;</span>);<br>			&#125;<br>		&#125;);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 8 Stream API实例</title>
    <url>/2020/12/06/Java%208%20Stream%20API%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="一、开篇"><a href="#一、开篇" class="headerlink" title="一、开篇"></a>一、开篇</h1><ol>
<li>Stream？其实就是处理集合的一种形式，称之为流，在Java8中被引入,可被Collection中的子类调用。</li>
<li>作用？简化代码，提升你的开发效率。</li>
<li>不会？看完这篇你就能自己上手了！</li>
</ol>
<h1 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h1><p>首先将你的集合处理成流，才可以使用此API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Stream&lt;String&gt; stream &#x3D; list.stream();<br></code></pre></td></tr></table></figure>

<p> 接下来创建一个String类型的List，便于测试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();<br>list.add(1);<br>list.add(2);<br>list.add(3);<br>list.add(7);<br>list.add(4);<br>list.add(6);<br></code></pre></td></tr></table></figure>

<p> 接下来展示具体参数使用方式。</p>
<ul>
<li>filter 过滤</li>
</ul>
<p>例：需要过滤出在集合中，大于5的数字的集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; result = list.stream().filter(o -&gt; o&gt;<span class="hljs-number">5</span>).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<p> filter内部使用的是lamda表达式，也是Java8的功能，o代表集合中每一个元素，o&gt;5表示这个元素的值若大于5就返回true,就获取结果。collect表示聚合，Collectors.toList()表示将结果聚合到一个List集合。</p>
<ul>
<li>map 形成一个新对象</li>
</ul>
<p>例：需要将集合内的元素全部转换成String类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; result = list.stream().map(o-&gt;String.valueOf(o)).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<ul>
<li>sort 排序</li>
</ul>
<p>例： 需要从小到大排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; result = list.stream().sorted().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<p>例： 需要从大到小排序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; result = list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<ul>
<li>forEach 遍历</li>
</ul>
<p>例： 打印集合内每个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">list.stream().forEach(o-&gt;System.out.println(o));<br>list.forEach(o-&gt;System.out.println(o));<br></code></pre></td></tr></table></figure>

<ul>
<li>distinct 去除重复元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; result = list.stream().distinct().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>

<ul>
<li>reduce 集合内运算</li>
</ul>
<p>例： 计算集合中元素的和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer sum = list.stream().reduce(<span class="hljs-number">0</span>, (i, j) -&gt; i + j);<br></code></pre></td></tr></table></figure>

<p>reduce中第一个参数为基数，即为初始值，i,j的定义为第一个和第二个操作数，i+j即为操作，此处为加法操作。</p>
<p>如果计算乘法，就不能设置初始值为0，因为0乘任何数都为0。</p>
<ul>
<li>collect 聚合成Collection</li>
</ul>
<ol>
<li>Collectors.toMap(Function&lt;? super T, ? extends K&gt; keyMapper, Function&lt;? super T, ? extends U&gt; valueMapper)</li>
<li>Collectors.toList()</li>
<li>Collectors.toSet()</li>
<li>…</li>
</ol>
<p>例： 将list聚合成一个key为元素，value为“item”+元素的Map。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Integer, String&gt; map = list.stream().collect(Collectors.toMap(Function.identity(), o -&gt; String.format(<span class="hljs-string">&quot;item%s&quot;</span>, o)));<br></code></pre></td></tr></table></figure>

<p>结果：{1=item1, 2=item2, 3=item3, 4=item4, 6=item6, 7=item7}</p>
<p>keyMapper表示设置为key的规则，valueMapper表示设置为value的规则。</p>
<p>Function.identity()表示当前本身元素。</p>
<ul>
<li>groupBy 分组</li>
</ul>
<p>Collectors.groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</p>
<p>新建一个User实体，有姓名和年龄两个字段，并初始化一个集合便于测试。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;User&gt;();<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;与李&quot;</span>, <span class="hljs-number">18</span>));<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;CSDN&quot;</span>, <span class="hljs-number">19</span>));<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;han&quot;</span>, <span class="hljs-number">20</span>));<br>list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;han&quot;</span>, <span class="hljs-number">21</span>));<br></code></pre></td></tr></table></figure>

<p>例： 需要把名字相同的实体提出来放在一起，形成一个List集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, List&lt;User&gt;&gt; group = list.stream().collect(Collectors.groupingBy(User::getName));<br></code></pre></td></tr></table></figure>

<p>结果：{han=[User [name=han, age=20], User [name=han, age=21]], CSDN=[User [name=CSDN, age=19]], 与李=[User [name=与李, age=18]]}</p>
<p>此处使用User实体的name属性进行分组。</p>
<p>User::getName 与 o -&gt; o.getName() 含义相同，两者皆可传入。</p>
<ul>
<li>partitioningBy 分区</li>
</ul>
<p>Collectors.partitioningBy(Predicate&lt;? super T&gt; predicate)</p>
<p>例： 分别统计年龄大于等于20和小于20的学生信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Boolean, List&lt;User&gt;&gt; partitioning = list.stream().collect(Collectors.partitioningBy(o -&gt; o.getAge() &gt;= <span class="hljs-number">20</span>));<br></code></pre></td></tr></table></figure>

<p>结果：{false=[User [name=与李, age=18], User [name=CSDN, age=19]], true=[User [name=han, age=20], User [name=han, age=21]]}</p>
<p>可以看到返回结果是一个Map&lt;Boolean, List<User>&gt;,利用partitioningBy后生成的map,有且仅有两个元素，key固定为true和false,分别表示满足条件的信息和不不满足条件的信息。</p>
<h1 id="三、结尾"><a href="#三、结尾" class="headerlink" title="三、结尾"></a>三、结尾</h1><p>此文列举了Stream部分方法的使用,具体更多的方法需要自己去深入了解。通过熟悉使用Stream的api之后，你会对它的处理方式爱不释手。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>解决Spring整合Quartz Job时Bean不能依赖注入的问题</title>
    <url>/2020/12/05/%E8%A7%A3%E5%86%B3Spring%E6%95%B4%E5%90%88Quartz%20Job%E6%97%B6Bean%E4%B8%8D%E8%83%BD%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h1><p>项目环境：Spring项目整合org.quartz-scheduler</p>
<p>问题描述：实现Job类的类中，不能使用@Autowired自动注入Bean</p>
<h1 id="二、解决教程"><a href="#二、解决教程" class="headerlink" title="二、解决教程"></a>二、解决教程</h1><ul>
<li>新建CustomJobFactory类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import org.quartz.spi.TriggerFiredBundle;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.beans.factory.config.AutowireCapableBeanFactory;<br>import org.springframework.scheduling.quartz.SpringBeanJobFactory;<br><br>public class CustomJobFactory extends SpringBeanJobFactory&#123;<br>	<br>	@Autowired    <br>    private AutowireCapableBeanFactory capableBeanFactory;    <br>    <br>    @Override    <br>    protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123;    <br>        &#x2F;&#x2F;调用父类的方法    <br>        Object jobInstance &#x3D; super.createJobInstance(bundle);    <br>        &#x2F;&#x2F;进行注入    <br>        capableBeanFactory.autowireBean(jobInstance);    <br>        return jobInstance;    <br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>配置spring-context.xml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;bean id&#x3D;&quot;customJobFactory&quot; class&#x3D;&quot;com.***.CustomJobFactory&quot;&gt;&lt;&#x2F;bean&gt;<br>	<br>&lt;!-- 声明任务工厂 --&gt;  <br>&lt;bean  id&#x3D;&quot;schedulerFactoryBean&quot;  class&#x3D;&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt;<br>    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;<br>    &lt;property name&#x3D;&quot;jobFactory&quot; ref&#x3D;&quot;customJobFactory&quot;&gt;&lt;&#x2F;property&gt;<br>    &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:&#x2F;properties&#x2F;quartz.properties&quot; &#x2F;&gt;  <br>&lt;&#x2F;bean&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用方式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">@DisallowConcurrentExecution  <br>public class testJob implements Job&#123;  <br>  <br>    @Autowired  <br>    private XxxService xxxService;  <br><br>    public void execute(JobExecutionContext context) throws JobExecutionException &#123;<br>        &#x2F;&#x2F; ***<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上配置即可解决spring bean在quartz-scheduler中不能自动注入的问题。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr专题（四）Solr安全设置</title>
    <url>/2020/12/05/Solr%E4%B8%93%E9%A2%98%EF%BC%88%E5%9B%9B%EF%BC%89Solr%E5%AE%89%E5%85%A8%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>因为solr的admin界面默认只需要知道ip和端口就能直接访问，如果被别有用心的人盯上就很容易给你的系统带来重大的破坏，所以我们应该限制访问。</p>
<p>请注意本例使用的是Solr7。</p>
<p>Solr集成了以下几种验证方式：</p>
<ol>
<li>Basic自定义身份验证方式</li>
<li>Kerberos身份验证方式</li>
<li>Hadoop身份验证方式</li>
</ol>
<ul>
<li>最简单的一种大概就是限制solr服务的访问ip，如果使用tomcat当做容器，可以在server.xml中配置可访问的ip</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Valve className&#x3D;&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow&#x3D;&quot;127.0.0.1,192.168.208.119&quot;&#x2F;&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用Basic认证</li>
</ul>
<p>添加用户配置文件realm.properties：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">admin:admin123,solr_admin  <br></code></pre></td></tr></table></figure>

<p>在/server/solr-webapp/webapp/WEB-INF/web.xml中添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;security-constraint&gt;  <br>    &lt;web-resource-collection&gt;  <br>      &lt;web-resource-name&gt;solr&lt;&#x2F;web-resource-name&gt;  <br>      &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;  <br>    &lt;&#x2F;web-resource-collection&gt;  <br>    &lt;auth-constraint&gt;  <br>      &lt;role-name&gt;solr_admin&lt;&#x2F;role-name&gt;  <br>      &lt;role-name&gt;admin&lt;&#x2F;role-name&gt;  <br>    &lt;&#x2F;auth-constraint&gt;  <br>   <br>    &lt;login-config&gt;  <br>      &lt;auth-method&gt;BASIC&lt;&#x2F;auth-method&gt;  <br>      &lt;realm-name&gt;Solr Admin&lt;&#x2F;realm-name&gt;  <br>    &lt;&#x2F;login-config&gt;  <br>&lt;&#x2F;security-constraint&gt; <br></code></pre></td></tr></table></figure>

<p>在/server/contexts/solr-jetty-context.xml中的Configure属性中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;Get name&#x3D;&quot;securityHandler&quot;&gt;    <br>         &lt;Set name&#x3D;&quot;loginService&quot;&gt;    <br>                 &lt;New class&#x3D;&quot;org.eclipse.jetty.security.HashLoginService&quot;&gt;    <br>                         &lt;Set name&#x3D;&quot;name&quot;&gt;admin&lt;&#x2F;Set&gt;<br>                        &lt;Set name&#x3D;&quot;config&quot;&gt;&lt;SystemProperty name&#x3D;&quot;jetty.home&quot; default&#x3D;&quot;.&quot;&#x2F;&gt;&#x2F;etc&#x2F;realm.properties&lt;&#x2F;Set&gt;    <br>                 &lt;&#x2F;New&gt;    <br>         &lt;&#x2F;Set&gt;    <br>&lt;&#x2F;Get&gt; <br></code></pre></td></tr></table></figure>

<p>重启solr,访问admin界面，提示需要输入密码才能访问。</p>
<p><img src="https://img-blog.csdnimg.cn/20200421173125725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>全文检索</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr专题（三）SSM项目整合Solr</title>
    <url>/2020/12/05/Solr%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89SSM%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88Solr/</url>
    <content><![CDATA[<h1 id="一、环境配置"><a href="#一、环境配置" class="headerlink" title="一、环境配置"></a>一、环境配置</h1><p>所需要的jar包： org.apache.solr.solr-solrj</p>
<p>maven依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.solr&#x2F;solr-solrj --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.solr&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;solr-solrj&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;7.7.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h1 id="二、教程"><a href="#二、教程" class="headerlink" title="二、教程"></a>二、教程</h1><p>solr查询方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&#x2F;**<br> * 执行solr查询<br> * @param query SolrQuery<br> * @param pageNo 页码<br> * @param pageSize 页面数据大小<br> * @param orderBy 排序<br> * @return Map&lt;String, Object&gt;<br> *&#x2F;<br>public Map&lt;String, Object&gt; getSolrQuery(String query, String pageNo, String pageSize, String orderBy)&#123;<br>	SolrQuery solrQuery &#x3D; new SolrQuery();<br>	solrQuery.set(CommonParams.Q, query);<br>	Map&lt;String, Object&gt; map &#x3D; Maps.newHashMap();<br>	map.put(&quot;total&quot;, 0);<br>	map.put(&quot;rows&quot;, Collections.emptyList());<br>	try &#123;<br>		Integer no &#x3D; PageUtils.parseNo(pageNo);<br>		Integer size &#x3D; PageUtils.parseSize(pageSize);<br>		Integer offset &#x3D; PageUtils.getOffset(no, size);<br>		solrQuery.setStart(offset);<br>		solrQuery.setRows(size);<br>		setOrder(solrQuery, orderBy);<br>		&#x2F;&#x2F;执行查询并返回结果<br>		QueryResponse resp &#x3D; solrClient.query(solrQuery);<br>		SolrDocumentList results &#x3D; resp.getResults();<br>		&#x2F;&#x2F;获取查询到的数据总量<br>		long numFound &#x3D; results.getNumFound();<br>		if(numFound &lt;&#x3D; 0) &#123;<br>			return map;<br>		&#125;else &#123;<br>			map.put(&quot;total&quot;, numFound);<br>			map.put(&quot;rows&quot;, convert(results));<br>			return map;<br>		&#125;<br>	&#125; catch (Exception e) &#123;<br>		LOGGER.error(e.getMessage(), e);<br>		return map;<br>	&#125;<br>&#125;<br><br>&#x2F;**<br> * 设置排序方式<br> * <br> * @param solrQuery SolrQuery<br> * @param orderBy 排序字段 example:name desc<br> *&#x2F;<br>private void setOrder(SolrQuery solrQuery, String orderBy) &#123;<br>	if(VerifyUtils.isEmpty(orderBy)) &#123;<br>		return;<br>	&#125;<br>	String[] split &#x3D; orderBy.split(SPACE);<br>	if(&quot;asc&quot;.equals(split[1].toLowerCase())) &#123;<br>		solrQuery.setSort(split[0], ORDER.asc);<br>	&#125;else &#123;<br>		solrQuery.setSort(split[0], ORDER.desc);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中SolrQuery实体为Solr的查询实体，其调用方法</p>
<p>set( String name, String … val )：设置查询参数，name可以使用org.apache.solr.common.params.CommonParams类调用，具体参数与上一节 <a href="https://blog.csdn.net/qq_37171817/article/details/105385260">Solr专题（二）详解Solr查询参数</a> 一致。</p>
<p>下节主要讲解solr在项目中的安全设置。</p>
]]></content>
      <categories>
        <category>全文检索</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr专题（二）详解Solr查询参数</title>
    <url>/2020/12/05/Solr%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AF%A6%E8%A7%A3Solr%E6%9F%A5%E8%AF%A2%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>上节我们讲到了怎样去搭建solr服务，作为全文检索引擎，怎样去使用也是比较关键的。Solr有一套自己的查询方式，所以我们需要另外花时间去学习它的这套模式。</p>
<p>启动solr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">solr start<br></code></pre></td></tr></table></figure>

<p>设置堆内存大小，因为一次全量导入可能会使得堆内存溢出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"># 启动时指定堆内存大小为1g<br>solr start -m 1g<br></code></pre></td></tr></table></figure>

<p>停止solr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">solr stop -p &lt;port&gt;<br></code></pre></td></tr></table></figure>

<p>进入Solr的admin界面，会有许多的查询参数供你使用，那我们一起来了解一下各个参数的具体使用方式。</p>
<p><img src="https://img-blog.csdnimg.cn/20200408125159154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="二、参数一览"><a href="#二、参数一览" class="headerlink" title="二、参数一览"></a>二、参数一览</h1><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>q</td>
<td>主要查询参数,以冒号分割，左边是字段名，右边是值，查询全部则为*:*</td>
<td>age:20</td>
</tr>
<tr>
<td>fq</td>
<td>过滤查询参数，可添加多个，格式与q一致</td>
<td>name:韩</td>
</tr>
<tr>
<td>sort</td>
<td>排序方式，字段与排序中间以空格隔开，多个以都逗号分隔,排序值为desc或asc</td>
<td>id desc,name asc</td>
</tr>
<tr>
<td>start</td>
<td>起始位置，默认为0</td>
<td>1</td>
</tr>
<tr>
<td>rows</td>
<td>获取记录数，默认为10条</td>
<td>100</td>
</tr>
<tr>
<td>fl</td>
<td>返回指定的字段，多个以逗号分隔</td>
<td>id,name</td>
</tr>
<tr>
<td>df</td>
<td>默认的查询字段，设置后q与fq可以只输入值</td>
<td></td>
</tr>
<tr>
<td>Raw Query Parameters</td>
<td></td>
<td></td>
</tr>
<tr>
<td>wt</td>
<td>返回结果的形式，支持json、xml、python、ruby等</td>
<td>json</td>
</tr>
<tr>
<td>indent off</td>
<td>返回结果是否缩进，默认缩进，选择则为不缩进</td>
<td></td>
</tr>
<tr>
<td>debugQuery</td>
<td>返回结果是否显示debug信息</td>
<td></td>
</tr>
<tr>
<td>dismax</td>
<td></td>
<td></td>
</tr>
<tr>
<td>edismax</td>
<td></td>
<td></td>
</tr>
<tr>
<td>hl</td>
<td>开启高亮显示</td>
<td></td>
</tr>
<tr>
<td>hl.fl</td>
<td>要高亮显示的域</td>
<td></td>
</tr>
<tr>
<td>hl.simple.pre</td>
<td>高亮显示的前缀</td>
<td></td>
</tr>
<tr>
<td>hl.simple.post</td>
<td>高亮显示的后缀</td>
<td></td>
</tr>
</tbody></table>
<h1 id="三、示例操作"><a href="#三、示例操作" class="headerlink" title="三、示例操作"></a>三、示例操作</h1><ul>
<li>参数【q】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408132023254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【fq】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408132343794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【sort】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408132603937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【start、rows】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408132742245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【fl】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408132828835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【df】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408132940804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【wt】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408133019280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>参数【indent off】</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200408133059521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 下一节我将会讲解怎样将Solr使用到自己的Java项目中，敬请期待。</p>
]]></content>
      <categories>
        <category>全文检索</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>Solr专题（一）手把手教你搭建Solr服务</title>
    <url>/2020/12/05/Solr%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%90%AD%E5%BB%BASolr%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="一、Solr是什么，能解决什么问题？"><a href="#一、Solr是什么，能解决什么问题？" class="headerlink" title="一、Solr是什么，能解决什么问题？"></a>一、Solr是什么，能解决什么问题？</h1><p>Solr是一个高性能，采用Java开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。</p>
<p>简而言之就是在项目中可以作为搜索引擎，提供资源的高效查询。</p>
<p>Q:数据库不是能提供查询的接口吗？为什么要用额外的框架来做?</p>
<p>A:因为模糊查询不能使用数据库的索引，所以数据库提供的模糊查询效率很低。而Solr本身也可以看做是数据库（no sql）类似于MongoDB存文档数据的菲关系型数据库。许多大型网站的搜索引擎绝不是通过查询数据库来做的，而是由Solr、Elasticsearch 这样的全文检索框架来负责。</p>
<h1 id="二、同类型产品比较"><a href="#二、同类型产品比较" class="headerlink" title="二、同类型产品比较"></a>二、同类型产品比较</h1><p>全文检索框架还有ElasticSearch，它们两者之间的区别如下：</p>
<ul>
<li>Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能;</li>
<li>Solr 支持更多格式的数据，而 Elasticsearch 仅支持json文件格式；</li>
<li>Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供；</li>
<li>Solr 在传统的搜索应用中表现好于 Elasticsearch，但在处理实时搜索应用时效率明显低于 Elasticsearch。</li>
<li>Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</li>
</ul>
<h1 id="三、搭建服务"><a href="#三、搭建服务" class="headerlink" title="三、搭建服务"></a>三、搭建服务</h1><p>本例中Solr版本为7.7.2</p>
<h2 id="1-下载Solr"><a href="#1-下载Solr" class="headerlink" title="1.下载Solr"></a>1.下载Solr</h2><p>官方下载网站： <a href="https://lucene.apache.org/solr/downloads.html">https://lucene.apache.org/solr/downloads.html</a></p>
<h2 id="2-版本变更记录"><a href="#2-版本变更记录" class="headerlink" title="2.版本变更记录"></a>2.版本变更记录</h2><p>参考博文:  <a href="https://blog.csdn.net/jiangchao858/article/details/52443745">https://blog.csdn.net/jiangchao858/article/details/52443745</a></p>
<p>说明：Solr从5.0.0开始内嵌jetty服务器，可直接启动，之前版本需依赖外部容器（tomcat、jetty…）中启动。</p>
<h2 id="3-安装与启动"><a href="#3-安装与启动" class="headerlink" title="3.安装与启动"></a>3.安装与启动</h2><p>免安装，下载解压即用。</p>
<p>常用命令：</p>
<ul>
<li>启动：solr start</li>
<li>停止：solr stop -p 8983</li>
<li>重启：solr restart</li>
</ul>
<p>启动方式：找到bin目录，在地址栏输入cmd,打开命令界面</p>
<p><img src="https://img-blog.csdnimg.cn/20200407132640857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 输入solr start，使用默认端口启用jetty服务。</p>
<p><img src="https://img-blog.csdnimg.cn/20200407133122983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 在浏览器输入localhost:8983/solr查看效果</p>
<p><img src="https://img-blog.csdnimg.cn/20200407133247153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="4、建立core"><a href="#4、建立core" class="headerlink" title="4、建立core"></a>4、建立core</h2><p>core就相当于数据库中的表，用来存放数据。</p>
<p>在/server/solr下新建一个文件夹，文件夹的名称就是core的名称，再将/server/solr/configsets/sample_techproducts_configs中的conf文件夹复制到新建的文件夹下。</p>
<p><img src="https://img-blog.csdnimg.cn/20200407134444474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 完成后重启solr服务，再进入solr的admin界面进行添加Core</p>
<p><img src="https://img-blog.csdnimg.cn/20200407134844910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20200407134928430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 添加成功后，文件夹里会多出两个文件（data、core.properties）</p>
<p><img src="https://img-blog.csdnimg.cn/20200407135105610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 进入自己建立的core进行管理：</p>
<p><img src="https://img-blog.csdnimg.cn/20200407135254304.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> <img src="https://img-blog.csdnimg.cn/20200407135501478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 至此，Solr服务的搭建已经成功了，接下来是运用教程。</p>
<h2 id="5、导入数据"><a href="#5、导入数据" class="headerlink" title="5、导入数据"></a>5、导入数据</h2><p>是指将数据库里面的数据导入到Solr中。</p>
<p>首先导入需要的jar包，将dist下的两个jar包复制到/server/solr-webapp/webapp/WEB-INF/lib文件夹下</p>
<p><img src="https://img-blog.csdnimg.cn/20200407142048297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
 <img src="https://img-blog.csdnimg.cn/20200407142351329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>如果没有mysql驱动包的需要复制一份过来：</p>
<img src="https://img-blog.csdnimg.cn/20201020113133110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<p>在你自己的core里的conf下新建一个data-config.xml的配置文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;<br>&lt;dataConfig&gt;<br>&lt;dataSource driver&#x3D;&quot;com.mysql.jdbc.Driver&quot; url&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;mydb?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;root&quot;&#x2F;&gt;<br>&lt;document name&#x3D;&quot;SysUser&quot;&gt;<br>	&lt;entity name&#x3D;&quot;SysUser&quot; pk&#x3D;&quot;id&quot;<br>	    query&#x3D;&#39;SELECT id,name,age FROM sys_suer&#39;<br>	    deltaImportQuery&#x3D;&#39;SELECT id,name,age FROM sys_user WHERE id &#x3D; &quot;$&#123;dataimporter.delta.id&#125;&quot;&#39;<br>	    deltaQuery&#x3D;&quot;SELECT id FROM sys_user where create_date &gt; &#39;$&#123;dataimporter.last_index_time&#125;&#39;&quot; &gt;<br>		&lt;field column&#x3D;&quot;id&quot; name&#x3D;&quot;id&quot;&#x2F;&gt;<br>		&lt;field column&#x3D;&quot;name&quot; name&#x3D;&quot;name&quot;&#x2F;&gt;<br>		&lt;field column&#x3D;&quot;age&quot; name&#x3D;&quot;age&quot;&#x2F;&gt;<br>	&lt;&#x2F;entity&gt;<br>&lt;&#x2F;document&gt;<br>&lt;&#x2F;dataConfig&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>dataSource表示连接数据库的配置</li>
<li>document表示文档信息</li>
<li>entity表示实体信息</li>
<li> –query表示全量导入时调用的sql语句</li>
<li> –deltaImportQuery表示增量导入时调用的sql语句</li>
<li> –deltaQuery表示增量导入时查出来的数据</li>
<li> –field表示字段</li>
<li>  –column表示数据库中字段名称</li>
<li>  –name表示存在solr的core中的名称</li>
<li>${dataimporter.last_index_time}表示最后一次导入数据的时间</li>
</ul>
<p>具体流程：选择全量导入（全部数据导入）时调用query查询数据并导入到Solr中。选择增量导入时，先执行deltaQuery语句获得需要导入数据的id，再根据deltaImportQuery查出数据并导入到Solr中。</p>
<p>编辑你Core下的conf/managed-schema文件：</p>
<p><img src="https://img-blog.csdnimg.cn/20200407141613971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<ul>
<li>indexed表示是否被索引，即是否被查询使用。</li>
<li>stored表示是否存到Solr库。</li>
<li>type表示搜索类型，当前为string类型的搜索，还可以自己配置，如IK中文分词器。</li>
</ul>
<p>编辑core下conf/solrconfig.xml</p>
<p>新增以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- dataimport --&gt;<br>&lt;requestHandler name&#x3D;&quot;&#x2F;dataimport&quot; class&#x3D;&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;&gt;<br>  &lt;lst name&#x3D;&quot;defaults&quot;&gt;<br>    &lt;str name&#x3D;&quot;config&quot;&gt;data-config.xml&lt;&#x2F;str&gt;<br>  &lt;&#x2F;lst&gt;<br>&lt;&#x2F;requestHandler&gt;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200407142704430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 配好之后重启solr服务，并进入admin界面</p>
<p><img src="https://img-blog.csdnimg.cn/20200407143325275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 只有点击刷新状态按钮，才回刷新显示状态，出现Indexing completed则为导入完成。</p>
<p><img src="https://img-blog.csdnimg.cn/20200407143834355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="6、查询数据"><a href="#6、查询数据" class="headerlink" title="6、查询数据"></a>6、查询数据</h2> <img src="https://img-blog.csdnimg.cn/20200407144059716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p> 输入查询条件，点击执行查询，即可感受到全文检索的魅力。</p>
<p>下一节将会对Solr Query进行一个详细的讲解。</p>
]]></content>
      <categories>
        <category>全文检索</category>
      </categories>
      <tags>
        <tag>Solr</tag>
        <tag>全文检索</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows中使用MyCat实现读写分离</title>
    <url>/2020/12/05/Windows%E4%B8%AD%E4%BD%BF%E7%94%A8MyCat%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    <content><![CDATA[<h1 id="一、关于MyCat"><a href="#一、关于MyCat" class="headerlink" title="一、关于MyCat"></a>一、关于MyCat</h1><p>什么是MyCat?</p>
<ol>
<li>一个彻底开源的，面向企业应用开发的大数据库集群 。</li>
<li>支持事务、ACID、可以替代MySQL的加强版数据库。    </li>
<li>一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群。   </li>
<li>一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server。   </li>
<li>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品。   </li>
<li>一个新颖的数据库中间件产品。</li>
</ol>
<p>MyCat能做什么，有什么用途？</p>
<ol>
<li>分库分表，把一个<a href="http://lib.csdn.net/base/mysql">数据库</a>切分成多个部分放到不同的数据库(server)上，从而缓解单一数据库的性能问题。</li>
<li>读写分离，线性的提升数据库的读性能，消除读写锁冲突从而提升数据库的写性能。</li>
</ol>
<p>MyCat官方链接：</p>
<p>GitHub：<a href="https://github.com/MyCATApache/Mycat-Server">https://github.com/MyCATApache/Mycat-Server</a></p>
<p>官网： <a href="http://www.mycat.io/">http://www.mycat.io/</a></p>
<p>下载路径：<a href="https://github.com/MyCATApache/Mycat-download">https://github.com/MyCATApache/Mycat-download</a> </p>
<p>具体下载哪个版本以发布为准，官方推荐1.4，1.5。</p>
<h1 id="二、使用教程"><a href="#二、使用教程" class="headerlink" title="二、使用教程"></a>二、使用教程</h1><p>注意：mycat不负责任何数据同步问题，因此需提前配置好mysql的主从复制数据自动同步。</p>
<p>MyCat三个主要配置文件，<strong>rule.xml</strong>表示分片规则、<strong>schema.xml</strong>是最主要的配置项，可配置物理数据库连接与分片等、<strong>server.xml</strong>可配置连接用户名与密码等。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105181155488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 1.在server.xml添加用户</p>
<p>在mycat:server标签下添加user</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;user name&#x3D;&quot;admin&quot;&gt;<br>	&lt;property name&#x3D;&quot;password&quot;&gt;admin&lt;&#x2F;property&gt;<br>	&lt;property name&#x3D;&quot;schemas&quot;&gt;api&lt;&#x2F;property&gt;<br>&lt;&#x2F;user&gt;<br></code></pre></td></tr></table></figure>

<p>name表示连接时用户名称，password表示连接密码，api表示schema.xml中名为api的schema标签配置，同时也是数据库名称。</p>
<p>2.在schema.xml中配置’api’</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- 数据库配置，与server.xml中的数据库对应 --&gt;<br>&lt;schema name&#x3D;&quot;api&quot; checkSQLschema&#x3D;&quot;false&quot; dataNode&#x3D;&quot;apiNode&quot;&gt;&lt;&#x2F;schema&gt;<br><br>&lt;!-- 分片配置 --&gt;<br>&lt;dataNode name&#x3D;&quot;apiNode&quot; dataHost&#x3D;&quot;apiHost&quot; database&#x3D;&quot;api&quot; &#x2F;&gt;<br><br>&lt;!-- 物理数据库配置 --&gt;<br>&lt;dataHost name&#x3D;&quot;apiHost&quot; maxCon&#x3D;&quot;1000&quot; minCon&#x3D;&quot;10&quot; balance&#x3D;&quot;1&quot;  writeType&#x3D;&quot;0&quot; dbType&#x3D;&quot;mysql&quot; dbDriver&#x3D;&quot;native&quot;&gt;<br>    &lt;heartbeat&gt;select user();&lt;&#x2F;heartbeat&gt;<br>    &lt;writeHost host&#x3D;&quot;apiWriteHost&quot; url&#x3D;&quot;127.0.0.1:3306&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;root&quot;&gt;  <br>        &lt;readHost host&#x3D;&quot;apiReadHost&quot; url&#x3D;&quot;127.0.0.1:3307&quot; user&#x3D;&quot;root&quot; password&#x3D;&quot;root&quot;&gt;&lt;&#x2F;readHost&gt;<br>    &lt;&#x2F;writeHost&gt;<br>&lt;&#x2F;dataHost&gt;<br></code></pre></td></tr></table></figure>

<p><strong>schema</strong>中的<strong>name</strong>是数据库名称</p>
<p><strong>sqlMaxLimit</strong>配置默认查询数量 。</p>
<p><strong>database</strong>为真实数据库名 。</p>
<p><strong>balance</strong>=”0”, 不开启读写分离机制，所有读操作都发送到当前可用的writeHost 上。</p>
<p><strong>balance</strong>=”1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡。</p>
<p><strong>balance</strong>=”2”，所有读操作都随机的在 writeHost、 readhost 上分发。</p>
<p><strong>balance</strong>=”3”， 所有读请求随机的分发到 wiriterHost 对应的 readhost 执行,writerHost 不负担读压力，注意 balance=3 只在 1.4 及其以后版本有， 1.3 没有。</p>
<p><strong>writeType</strong>=”0”, 所有写操作发送到配置的第一个 writeHost，第一个挂了切到还生存的第二个writeHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties 。</p>
<p><strong>writeType</strong>=”1”，所有写操作都随机的发送到配置的 writeHost。</p>
<p>3.Mycat启动</p>
<p>点击bin/mycat.bat，安装mycat服务</p>
<p><img src="https://img-blog.csdnimg.cn/20200105183004737.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 启动服务，默认端口8066。</p>
<p>4.用Mysql客户端连接Mycat,并写入数据</p>
<p>用户名和密码就是在server.xml中配置的数据。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105183911416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>在MyCat连接中插入一条数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105184047885.png"></p>
<p> 查看3306库中的api_user表：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105184137252.png"></p>
<p>查看3307库中的api_user表： </p>
<p><img src="https://img-blog.csdnimg.cn/20200105184214124.png"></p>
<p>有一个需要注意的是，主节点（写库）宕机时，读节点也不能读。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105185250415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20200105185354256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Mycat</tag>
        <tag>读写分离</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql主从分离与双机热备超详细配置</title>
    <url>/2020/12/05/Mysql%E4%B8%BB%E4%BB%8E%E5%88%86%E7%A6%BB%E4%B8%8E%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87%E8%B6%85%E8%AF%A6%E7%BB%86%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>本例是在Windows环境，基于一台已经安装好的Mysql57,在本机安装第二台Mysql57服务。</p>
<p>读完本篇内容，你可以了解到Mysql的主从分离与双机热备的知识，以及配置期间问题的解决方案。</p>
<h1 id="二、过程"><a href="#二、过程" class="headerlink" title="二、过程"></a>二、过程</h1><h2 id="1、安装第二台数据库"><a href="#1、安装第二台数据库" class="headerlink" title="1、安装第二台数据库"></a>1、安装第二台数据库</h2><p>复制一份mysql的安装目录，取名MySQL Server 5.7_3307（从数据库）。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105141004808.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 清空Data文件夹，并修改my.ini</p>
<p><img src="https://img-blog.csdnimg.cn/20200105141337377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> client&gt;port 改成3307。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105141501694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>mysqld&gt;port 改成3307。</p>
<p> <img src="https://img-blog.csdnimg.cn/2020010514160554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> mysqld&gt;datadir 改为从数据库的Data文件路径。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105141727815.png"></p>
<p>在C:/ProgramData/MySQL/MySQL Server 5.7_3307建一个Uploads文件夹，没有的文件需要补齐。或者自己选择文件路径。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105141917823.png"></p>
<p> 在从数据库的bin文件夹下打开命令行，执行mysql安装初始化命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mysqld -initialize -insecure -user&#x3D;mysql<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200105142411204.png"></p>
<p> 此时从数据库的Data目录会增加文件。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105142453912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>将主数据库的数据库文件夹复制过来（主库Data目录下，文件夹名称就是数据库名称），如果是InnoDB引擎，需要将Data下的ibdata1文件复制过来，否则不能显示表。</p>
<p>此处将之前数据库的api数据库（看你需要复制哪些数据库，不复制也没问题，Mysql自身表需要复制）复制到从数据库。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105145351487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>在从库bin目录下打开命令行并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">mysqld --install MySQL57_3307<br></code></pre></td></tr></table></figure>

<p>MySQL57_3307为服务名称，出现Service successfully installed.即为注册成功。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105143548327.png"></p>
<p> 使用win+r，弹出命令输入框，输入services.msc，出现服务窗口。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105143933942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>注册成功。但是选中MySQL57_3307，右键属性。发现未指定mysql启动文件。</p>
<p> <img src="https://img-blog.csdnimg.cn/20200105144043434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> win+r，输入regedit打开注册表。按照以下路径打开：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105144249516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>找到MySQL57_3307，将ImagePath修改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&quot;D:\MySQL\MySQL Server 5.7_3307\bin\mysqld.exe&quot; --defaults-file&#x3D;&quot;D:\MySQL\MySQL Server 5.7_3307\my.ini&quot; MySQL57<br></code></pre></td></tr></table></figure>

<p>刷新服务并启动。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105145504950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 用HeidiSQL(与Navicat同为Mysql客户端)连接，由于复制了主库的mysql库，所以用户名和密码与主库一致，端口为从库的3307。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105145840682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>连接成功：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105150033286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 表文件成功复制：</p>
<p> <img src="https://img-blog.csdnimg.cn/2020010515403237.png"></p>
<h2 id="2、配置主从"><a href="#2、配置主从" class="headerlink" title="2、配置主从"></a>2、配置主从</h2><p>在my.ini里的mysqld后进行配置</p>
<p>主库配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># Server Id.</span><br>server-id=1<br><br><span class="hljs-comment"># 设置同步数据库名    </span><br>binlog-<span class="hljs-keyword">do</span>-db=api<br><br><span class="hljs-comment"># 不记录日志的库,即不需要同步的库</span><br><span class="hljs-keyword">binlog</span>-<span class="hljs-keyword">ignore</span>-db=mysql<br><br><span class="hljs-comment"># Log for sync </span><br><span class="hljs-keyword">log</span>-<span class="hljs-keyword">bin</span>=mysql-<span class="hljs-keyword">bin</span> <br></code></pre></td></tr></table></figure>

<p>从库配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># Server Id.</span><br>server-id=2<br><br><span class="hljs-comment"># 从服务器同步数据库名 </span><br>replicate-<span class="hljs-keyword">do</span>-db=api<br><br><span class="hljs-comment"># 不从服务器同步数据库名</span><br><span class="hljs-keyword">replicate</span>-<span class="hljs-keyword">ignore</span>-db = mysql,information_schema,performance_schema<br><br><span class="hljs-comment"># Log for sync </span><br><span class="hljs-keyword">log</span>-<span class="hljs-keyword">bin</span>=mysql-<span class="hljs-keyword">bin</span> <br></code></pre></td></tr></table></figure>

<p>需要重启主库与从库服务，后在主库执行查询，查看主库状态：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">STATUS</span>;<br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200105152039184.png"></p>
<p> 在从库执行语句，同步数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CHANGE</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">TO</span> MASTER_HOST=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, MASTER_PORT=<span class="hljs-number">3306</span>, MASTER_USER=<span class="hljs-string">&#x27;root&#x27;</span>, MASTER_PASSWORD=<span class="hljs-string">&#x27;root&#x27;</span>, MASTER_LOG_FILE=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>, MASTER_LOG_POS=<span class="hljs-number">154</span>;<br></code></pre></td></tr></table></figure>

<p>在从库执行开始同步：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> <span class="hljs-keyword">SLAVE</span>;<br></code></pre></td></tr></table></figure>

<p>执行查看从库状态：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">SLAVE</span> <span class="hljs-keyword">STATUS</span>;<br></code></pre></td></tr></table></figure>

<p> 结果为yes，表示执行成功。</p>
<p><img src="https://img-blog.csdnimg.cn/20200105152707360.png"></p>
<p>在主库插入数据，验证从库是否同步。</p>
<p>主库执行：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105154134921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 主库数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105154634751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 查看从库数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105154255313.png"></p>
<p> 数据同步成功。</p>
<h2 id="3、配置双机热备"><a href="#3、配置双机热备" class="headerlink" title="3、配置双机热备"></a>3、配置双机热备</h2><p>3306库配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># Server Id.</span><br>server-id=1<br><br><span class="hljs-comment"># 设置同步数据库名    </span><br>binlog-<span class="hljs-keyword">do</span>-db=api<br><br><span class="hljs-comment"># 不记录日志的库,即不需要同步的库</span><br><span class="hljs-keyword">binlog</span>-<span class="hljs-keyword">ignore</span>-db=mysql<br><br><span class="hljs-comment"># 从服务器同步数据库名</span><br><span class="hljs-keyword">replicate</span>-<span class="hljs-keyword">do</span>-db=api<br><br><span class="hljs-comment"># 不从服务器同步数据库名</span><br><span class="hljs-keyword">replicate</span>-<span class="hljs-keyword">ignore</span>-db = mysql,information_schema,performance_schema<br><br><span class="hljs-comment"># Log for sync </span><br><span class="hljs-keyword">log</span>-<span class="hljs-keyword">bin</span>=mysql-<span class="hljs-keyword">bin</span> <br></code></pre></td></tr></table></figure>

<p>3307库配置：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># Server Id.</span><br>server-id=2<br><br><span class="hljs-comment"># 从服务器同步数据库名 </span><br>replicate-<span class="hljs-keyword">do</span>-db=api<br><br><span class="hljs-comment"># 不从服务器同步数据库名</span><br><span class="hljs-keyword">replicate</span>-<span class="hljs-keyword">ignore</span>-db = mysql,information_schema,performance_schema<br><br><span class="hljs-comment"># 设置同步数据库名</span><br><span class="hljs-keyword">binlog</span>-<span class="hljs-keyword">do</span>-db=api<br><br><span class="hljs-comment"># 不记录日志的库,即不需要同步的库</span><br><span class="hljs-keyword">binlog</span>-<span class="hljs-keyword">ignore</span>-db=mysql<br><br><span class="hljs-comment"># Log for sync </span><br><span class="hljs-keyword">log</span>-<span class="hljs-keyword">bin</span>=mysql-<span class="hljs-keyword">bin</span> <br></code></pre></td></tr></table></figure>

<p>查询3306库MASTER信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">STATUS</span>; <br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200105165414227.png"></p>
<p>在3307库设置SLAVE信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CHANGE</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">TO</span> MASTER_HOST=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, MASTER_PORT=<span class="hljs-number">3306</span>, MASTER_USER=<span class="hljs-string">&#x27;root&#x27;</span>, MASTER_PASSWORD=<span class="hljs-string">&#x27;root&#x27;</span>, MASTER_LOG_FILE=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>, MASTER_LOG_POS=<span class="hljs-number">781</span>;<br></code></pre></td></tr></table></figure>

<p>查询3307库MASTER信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">STATUS</span>; <br></code></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200105165414227.png"></p>
<p>在3306库设置SLAVE信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CHANGE</span> <span class="hljs-keyword">MASTER</span> <span class="hljs-keyword">TO</span> MASTER_HOST=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, MASTER_PORT=<span class="hljs-number">3307</span>, MASTER_USER=<span class="hljs-string">&#x27;root&#x27;</span>, MASTER_PASSWORD=<span class="hljs-string">&#x27;root&#x27;</span>, MASTER_LOG_FILE=<span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>, MASTER_LOG_POS=<span class="hljs-number">781</span>;<br></code></pre></td></tr></table></figure>

<h3 id="测试1：在3306库插入数据"><a href="#测试1：在3306库插入数据" class="headerlink" title="测试1：在3306库插入数据"></a>测试1：在3306库插入数据</h3><p>3306：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105165916224.png"></p>
<p> 3307：</p>
<p> <img src="https://img-blog.csdnimg.cn/20200105170000249.png"></p>
<p> 结果一致，正确。</p>
<h3 id="测试2：在3307插入数据"><a href="#测试2：在3307插入数据" class="headerlink" title="测试2：在3307插入数据"></a>测试2：在3307插入数据</h3><p>3307：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105170111496.png"></p>
<p> 3306：</p>
<p><img src="https://img-blog.csdnimg.cn/20200105170144208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>结果一致，正确。 </p>
<h2 id="三、问题"><a href="#三、问题" class="headerlink" title="三、问题"></a>三、问题</h2><p>在配置主从或双机热备失败，导致数据不一致时，不要手动删除mysql-bin文件，</p>
<p><img src="https://img-blog.csdnimg.cn/20200105170731671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>可以先在数据库中停止从关系</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">STOP</span> <span class="hljs-keyword">SLAVE</span>;<br></code></pre></td></tr></table></figure>

<p> 然后重置主从关系，效果是文件夹中恢复为只有mysql-bin.000001,SHOW MASTER STATUS也是mysql-bin.000001。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">RESET</span> <span class="hljs-keyword">SLAVE</span>;<br><span class="hljs-keyword">RESET</span> <span class="hljs-keyword">MASTER</span>;<br></code></pre></td></tr></table></figure>

<p>如果是双机热备，两个数据库都应执行此操作。</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>主从分离</tag>
        <tag>双机热备</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次线上OOM问题分析与解决</title>
    <url>/2020/12/05/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%BA%BF%E4%B8%8AOOM%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="一、问题情况"><a href="#一、问题情况" class="headerlink" title="一、问题情况"></a>一、问题情况</h1><p>最近用户反映系统响应越来越慢，而且不是偶发性的慢。根据后台日志，可以看到系统已经有oom现象。</p>
<p>根据jdk自带的jconsole工具，可以监视到系统处于堵塞时期。cup占满，活动线程数持续增加，堆内存接近峰值。</p>
<h1 id="二、分析情况"><a href="#二、分析情况" class="headerlink" title="二、分析情况"></a>二、分析情况</h1><p><strong>使用jconsole分析：</strong></p>
<p>找到jdk安装路径，点击bin目录下的jconsole.exe,运行。</p>
<img src="https://img-blog.csdnimg.cn/20200103090558992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<img src="https://img-blog.csdnimg.cn/20200103090701931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<img src="https://img-blog.csdnimg.cn/20200103090751456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>当时线上情况是堆内存使用量7个G左右，接近峰值；活动线程80个左右；CPU占用率80%左右。系统随时可能宕机。</p>
<p>根据用户反映的情况，系统每隔一段时间都会卡顿，且堆内存是一段时间上升，然后突然下降，再上升，所以我第一反应是：会不会是系统频繁的进行FullGC，导致系统在一段时间内不可用？</p>
<p>首先认识一下什么是Full GC（需要一定的java内存模型知识）：</p>
<p>含义：FullGC是发生在永久代和老年代的一种垃圾回收机制。</p>
<p>触发条件：老年代内存满时。</p>
<p>特点：执行时间长，期间系统不可用。</p>
<p>于是查看老年代占用情况：</p>
<img src="https://img-blog.csdnimg.cn/20200103091732168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p> 使用期间老年代内存峰值已经达到7个G左右，接近上限。</p>
<p>于是用jstat -gc pid查看gc回收情况：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103092335167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 案发当时Full GC执行次数为28次，总执行时长为27秒。可以实锤是频繁Full GC导致系统线程堵塞。</p>
<p> 上面介绍到了，老年代内存满时会触发FullGC,那么哪种情况下会进入老年代呢？</p>
<p>（1）对象在新生代中经历固定次数minor GC,会进入老年代</p>
<p>可通过-XX:MaxTenuringThreshold设置，默认15</p>
<p>（2）当新生代中minor GC回收后，存活对象大于survivor to区容量时，进入老年代</p>
<p>（3）大对象直接进入老年代</p>
<p>可通过-XX:PretenureSizeThreshold 设置</p>
<p><strong>使用jvisualvm分析：</strong></p>
<p>在jdk的bin目录下,找到jvisualvm.exe,点击运行。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103125930176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> <img src="https://img-blog.csdnimg.cn/20200103130207283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 这里可以很清楚的看到堆内存的内容分布情况。当时系统是<strong>byte[]和InternalAprOutputBuffer占用内存最大，同为2.9G。</strong></p>
<p>在此不能很直观的分析具体原因，建议使用Eclipse的Mat插件进行分析。</p>
<p>放上Mat插件的安装教程：<a href="https://mp.csdn.net/postedit/103815484">https://mp.csdn.net/postedit/103815484</a></p>
<p>放上系统当时的Dump:</p>
<img src="https://img-blog.csdnimg.cn/20200103130631579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>问题就在于这两处占用太多堆内存。</p>
<p>接着我们去查看Dominator Tree,可以查看到保持存活的最大对象集合：</p>
<img src="https://img-blog.csdnimg.cn/20200103130804396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<p> 至少有一半都是<strong>InternalAprOutputBuffer对象。</strong>Shallow Heap 表示原本大小，Retained Heap表示在堆中占用内存的大小，单位bytes(1kb = 1024bytes)，每个对象在堆中占约47.6兆空间，难以想象。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103130911328.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>那么这些对象里都是些什么内容呢？为什么会这么多？</p>
<p>点开树形，发现内容就是这个容量为50000000的byte数组。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103131514184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>再看看左边的Attributes值,的确有50000000的长度，那里面到底存放的是那些数据呢？</p>
<p>点击图片右下角的加号，展开数据，发现只有前面的几百条有数据，后面的一直到50000000都是0。意思就是实际byte[]中只有311条为有效值，其余都是以0填充的，且占用了几千万个值，造成了内存的暴涨。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103131802909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>再结合org.apache.coyote.http11.InternalAprOutputBuffer类是Tomcat的一个类，猜想是不是跟Tomcat的配置有关，于是打开Tomcat的server.xml一探究竟。</p>
<p><img src="https://img-blog.csdnimg.cn/20200103132250915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>有没有觉得这50000000很眼熟？就是这个byte[]的长度。</p>
<p>那么为什么要设置这个参数呢？</p>
<p>据同事说，加这个参数是为了解决get请求中url参数过长，超大而报错的问题。</p>
<p>但是，各大浏览器均对url的长度有所限制，而且这个值在Tomcat中默认是4K,这里大约都是50M了，所以为了解决问题，最后把这里改成了8K,就是8192，然后再修改接口，参数过大的查询用Post去请求。</p>
<p>至此，问题解决，服务器运行顺畅，没有再出现卡死的情况。</p>
]]></content>
      <categories>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOM</tag>
        <tag>内存溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse安装Mat工具分析教程</title>
    <url>/2020/12/05/Eclipse%E5%AE%89%E8%A3%85Mat%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="一、关于Mat"><a href="#一、关于Mat" class="headerlink" title="一、关于Mat"></a>一、关于Mat</h1><p>MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。可以用于查找内存泄露以及查看内存消耗情况。MAT是基于Eclipse开发的，是一款免费的性能分析工具。可以再官网<a href="http://www.eclipse.org/mat/%E4%B8%8B%E8%BD%BD%EF%BC%8C%E6%88%96%E8%80%85%E7%9B%B4%E6%8E%A5%E5%9C%A8Eclipse%E9%87%8C%E4%B8%8B%E8%BD%BD%E3%80%82">http://www.eclipse.org/mat/下载，或者直接在Eclipse里下载。</a></p>
<h1 id="二、Eclipse安装Mat"><a href="#二、Eclipse安装Mat" class="headerlink" title="二、Eclipse安装Mat"></a>二、Eclipse安装Mat</h1><p>Eclipse首页 点击help&gt;Eclipse Marketplace</p>
<img src="https://img-blog.csdnimg.cn/20200103100321787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>安装完成后重启Eclipse，如果在Window&gt;Perspective&gt;Open Perspective&gt;other能找到Memory Alalysis就表示安装成功。</p>
<p>点击Memory Alalysis，弹出分析界面：</p>
<p><img src="https://img-blog.csdnimg.cn/20200103140754471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 点击左上角File&gt;Open Heap Dump,并选则Dump下来的文件</p>
<img src="https://img-blog.csdnimg.cn/20200103115535786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p><img src="https://img-blog.csdnimg.cn/20200103115557186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20200103115641925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<img src="https://img-blog.csdnimg.cn/20200103115728989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>可以清楚的看到问题信息。 </p>
]]></content>
      <categories>
        <category>Eclipse</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>Mat</tag>
        <tag>内存分析</tag>
      </tags>
  </entry>
  <entry>
    <title>理解JAVA内存模型</title>
    <url>/2020/12/04/%E7%90%86%E8%A7%A3JAVA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、关于JAVA内存模型"><a href="#一、关于JAVA内存模型" class="headerlink" title="一、关于JAVA内存模型"></a>一、关于JAVA内存模型</h1><p>JAVA内存模型是java基础，每个开发人员都需要有一定的了解，只有更好更多的了解底层的东西，才能促进自己更好的进步。</p>
<p>本文记录的是JDK1.8之前的内存模型。在java中，主要将内存分为以下几块：</p>
<p>（1）<strong>堆（Heap）</strong></p>
<p>是内存区域中最大的一块，被所有线程共享，用来存放new出来的实例对象。</p>
<p>（2）<strong>栈 (Stack)</strong></p>
<p>分为Java虚拟机栈和本地方法栈。</p>
<p><strong>Java虚拟机栈 (JVM Stack)：</strong></p>
<p>每个JVM线程都有一个私有栈，用来执行Java方法。</p>
<p><strong>本地方法栈 (Native Method Stacks)：</strong></p>
<p>与虚拟机栈所发挥的作用是非常相似的，其<strong>区别</strong>不过是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务</strong>，而<strong>本地方法栈则是为虚拟机使用到的Native方法服务</strong>。</p>
<p>（3）<strong>方法区</strong></p>
<p>用来存放虚拟机加载的类的信息，静态变量、常量。</p>
<p>（4）<strong>程序计数器</strong></p>
<p>程序计数器就是记录当前线程执行程序的位置，改变计数器的值来确定执行的下一条指令，比如循环、分支、方法跳转、异常处理，线程恢复都是依赖程序计数器来完成。</p>
<p><img src="https://img-blog.csdnimg.cn/20191227135912460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="二、JVM常用参数"><a href="#二、JVM常用参数" class="headerlink" title="二、JVM常用参数"></a>二、JVM常用参数</h1><p>-Xms 初始堆大小</p>
<p>-Xmx 最大堆大小</p>
<p>-Xmn 年轻代大小</p>
<p>-XX:PermSize 永久代初始值</p>
<p>-XX:MaxPermSize 永久代最大值</p>
<p>-XX:NewRatio 年轻代与老年代的比值</p>
<p>-XX:SurvivorRatio Eden区与Survivor区的大小比值</p>
<p>-XX:+PrintGCDateStamps 打印gc时间</p>
<p>-XX:+PrintGCDetails 打印gc日志</p>
<p>-Xloggc:../tomcat_gc.log gc日志位置</p>
<h1 id="三、参数设定位置"><a href="#三、参数设定位置" class="headerlink" title="三、参数设定位置"></a>三、参数设定位置</h1><p>以windows中的tomcat部署为例：</p>
<p>编辑bin目录下的catalina.bat文件，在文件头部加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">set CATALINA_OPTS&#x3D;-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:..&#x2F;tomcat_gc.log<br></code></pre></td></tr></table></figure>

<p>启动tomcat服务，执行gc后，生成gc日志</p>
<p><img src="https://img-blog.csdnimg.cn/20200107140456558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> <img src="https://img-blog.csdnimg.cn/20200107140542174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>Jvm</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot+Shiro+JPA+LayUI的后台管理系统</title>
    <url>/2020/12/04/SpringBoot-Shiro-JPA-LayUI%E7%9A%84%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="一、系统说明"><a href="#一、系统说明" class="headerlink" title="一、系统说明"></a>一、系统说明</h1><p>资源下载路径：<a href="https://download.csdn.net/download/qq_37171817/12056804">https://download.csdn.net/download/qq_37171817/12056804</a></p>
<p>本系统是一个用SpringBoot做后台开发框架，Shiro做权限管理框架，Spring Data Jpa 做持久层框架，Layui、Layui mini做为前端框架的前后端分离的项目。</p>
<p>即拿即用，上手即会，可以方便你快速的开发一套属于自己的系统。</p>
<p>系统使用Nginx-1.16.1作web服务器，使用Apache Tomcat-7.0.96作应用服务器。浏览器直接访问Nginx服务器，后台请求由Nginx进行转发。服务器部署环境为windows。</p>
<h1 id="二、系统数据库设计"><a href="#二、系统数据库设计" class="headerlink" title="二、系统数据库设计"></a>二、系统数据库设计</h1><p><img src="https://img-blog.csdnimg.cn/20191226180136149.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="三、代码结构"><a href="#三、代码结构" class="headerlink" title="三、代码结构"></a>三、代码结构</h1><p><img src="https://img-blog.csdnimg.cn/20191226180954750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="四、功能界面展示"><a href="#四、功能界面展示" class="headerlink" title="四、功能界面展示"></a>四、功能界面展示</h1><p><img src="https://img-blog.csdnimg.cn/20191226181225695.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="五、项目运行配置说明"><a href="#五、项目运行配置说明" class="headerlink" title="五、项目运行配置说明"></a>五、项目运行配置说明</h1><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p><img src="https://img-blog.csdnimg.cn/20191227090339490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>首先在配置里添加一个监听本地80端口的server。</p>
<p>1、后端请求的url重写：拦截/rest/<strong>的路径，将</strong>内容添加到<a href="http://localhost:8080的末尾，意为向服务器端发送">http://localhost:8080的末尾，意为向服务器端发送</a> <a href="http://localhost:8080/**%E7%9A%84%E8%AF%B7%E6%B1%82%E3%80%82">http://localhost:8080/**的请求。</a></p>
<p>2、资源文件映射：拦截/file/**的路径，映射到本地D:/demo/shiro_boot/file文件夹，实现文件服务器的功能。</p>
<p>3、网页文件映射：拦截根路径，映射到本地的D:/demo/shiro_boot/code/web/manage文件夹，索引页面就是index.html。就是说启动Nginx服务之后，浏览器访问<a href="http://localhost,就能直接显示d/demo/shiro_boot/code/web/manage/index.html%E9%A1%B5%E9%9D%A2%E3%80%82">http://localhost,就能直接显示D:/demo/shiro_boot/code/web/manage/index.html页面。</a></p>
<p>4、定义404错误：当访问Nginx发生404错误时，重定向到/404.html路径。</p>
<p>5、定义404页面路径：当访问/404.html路径时，映射到D:/demo/shiro_boot/code/web/manage/page/404.html。</p>
<p>注意Nginx的location配置是有先后顺序的，在一次请求中，如果在前面就已经对路径进行拦截处理了，就不会被后面的location拦截到。</p>
<h2 id="web中js配置"><a href="#web中js配置" class="headerlink" title="web中js配置"></a>web中js配置</h2><p>1、全局ajax请求配置</p>
<p><img src="https://img-blog.csdnimg.cn/20191227091740979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>2、全局的js函数配置</p>
<p><img src="https://img-blog.csdnimg.cn/20191227092208578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h2 id="后端配置"><a href="#后端配置" class="headerlink" title="后端配置"></a>后端配置</h2><p><img src="https://img-blog.csdnimg.cn/20191227092724366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>Shiro</tag>
        <tag>Spring Data JPA</tag>
        <tag>LayUI</tag>
        <tag>后台管理</tag>
      </tags>
  </entry>
  <entry>
    <title>学会使用BeanUtils，提高你的开发效率</title>
    <url>/2020/12/04/%E5%AD%A6%E4%BC%9A%E4%BD%BF%E7%94%A8BeanUtils%EF%BC%8C%E6%8F%90%E9%AB%98%E4%BD%A0%E7%9A%84%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/</url>
    <content><![CDATA[<h1 id="一、关于BeanUtils"><a href="#一、关于BeanUtils" class="headerlink" title="一、关于BeanUtils"></a>一、关于BeanUtils</h1><p>一说到BeanUtils，大家可能不清楚指的哪个BeanUtils。因为它在很多包里面都有，其中挺常用的就是</p>
<p>（1）org.apache.commons.beanutils.BeanUtils</p>
<p>（2）org.springframework.beans.BeanUtils</p>
<p>这两者有什么区别呢？</p>
<p>（1）类的性质不同</p>
<p>apache:</p>
<p><img src="https://img-blog.csdnimg.cn/20191226110621279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>springframework:</p>
<p><img src="https://img-blog.csdnimg.cn/20191226110655188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>apache的是普通类，springframework的是抽象类。</p>
<p>（2）部分相同方法使用方式不同</p>
<p>名字相同，方法名称相同，参数类型和个数都相同，需要实现的功能也一样，但结果大相径庭。</p>
<p>举例：copyProperties (用来在对象之间复制属性值)</p>
<p>apache:</p>
<p><img src="https://img-blog.csdnimg.cn/20191226111230707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70">!</p>
<p>springframework:</p>
<p><img src="https://img-blog.csdnimg.cn/20191226111154382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>眼尖的伙伴已经注意到了，apache的第一个参数是目标对象，第二个是源对象；springframework的第一个参数是源对象，第二个是目标对象。所以大家在开发的时候一定要注意引用的是哪个包。</p>
<h1 id="二、根据已有方法扩展"><a href="#二、根据已有方法扩展" class="headerlink" title="二、根据已有方法扩展"></a>二、根据已有方法扩展</h1><p>因为开发的时候有很多类的属性都要重设值，很多时候大把的get、set方法占用你的篇幅与时间，导致拉低开发效率。</p>
<p>所以在此扩展了一些经常用到的方法，供大家参考。</p>
<p>\1. 使用org.apache.commons.beanutils.BeanUtils.populate方法</p>
<p>意为将Map中的数据封装到实体类。</p>
<p>扩展之后可以将Map中的数据封装到实体类，并支持日期格式的转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以Map的key和实体的字段名称为对应，复制Map中的值到实体中</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target 目标对象</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> params Map</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> T</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">copyFields</span><span class="hljs-params">(T target, Map&lt;String, Object&gt; params)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == params || params.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        org.apache.commons.beanutils.BeanUtils.populate(target, params);<br>    &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;<br>        LOGGER.error(e.getMessage(), e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 注意：遇到日期类型不能转换，所以需要自己手动注册一个时间转换器。</p>
<p>这里是在静态代码块里面注册的，将格式为yyyy-MM-dd的字符串转换成Date类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br>     <span class="hljs-comment">// 注册BeanUtils转换器</span><br>     ConvertUtils.register(<span class="hljs-keyword">new</span> Converter() &#123;<br><br>         <span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span><br>         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">convert</span><span class="hljs-params">(Class type, Object value)</span> </span>&#123;<br><br>             <span class="hljs-keyword">try</span> &#123;<br>                 <span class="hljs-keyword">return</span> DateUtils.parseDate(String.valueOf(value), <span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                 LOGGER.error(e.getMessage(), e);<br>             &#125;<br>             <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>         &#125;<br>     &#125;, Date.class);<br> &#125;<br></code></pre></td></tr></table></figure>

<p> 2、使用org.springframework.beans.BeanUtils.getPropertyDescriptors方法</p>
<p>意为获取类的属性描述器</p>
<p>扩展之后可以从一个实体中复制非空字段的值到另一个实体中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以字段名称为关系，从一个实体中复制非空字段的值到另一个实体中</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target 目标实体</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> source 源实体</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> T</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, S&gt; <span class="hljs-function">T <span class="hljs-title">copyNotNullFields</span><span class="hljs-params">(T target, S source)</span> </span>&#123;<br>    Map&lt;String, Object&gt; params = getFiledValues(source, o -&gt; (o != <span class="hljs-keyword">null</span>));<br>    T newTarget = copyFields(target, params);<br>    <span class="hljs-keyword">return</span> newTarget;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里可以根据对属性值的判断，将符合条件的属性与其值封装成Map。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读取实体，以实体字段名为key,值为value,并将满足条件的value封装成一个Map</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> obj 源实体</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> predicate 条件</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> Map&lt;String, Object&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, Object&gt; <span class="hljs-title">getFiledValues</span><span class="hljs-params">(Object obj, Predicate&lt;Object&gt; predicate)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == obj) &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptyMap();<br>    &#125;<br>    Map&lt;String, Object&gt; map = Maps.newHashMap();<br>    Arrays.asList(org.springframework.beans.BeanUtils.getPropertyDescriptors(obj.getClass())<br>    .stream()<br>    .filter(o -&gt; !o.getName().equals(<span class="hljs-string">&quot;class&quot;</span>))<br>    .forEach(o -&gt; <br>    &#123;<br>        String propertyName = o.getName();<br>        Method readMethod = o.getReadMethod();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object propertyValue = readMethod.invoke(obj);<br>            <span class="hljs-keyword">if</span>(predicate.test(propertyValue)) &#123;<br>                map.put(propertyName, propertyValue);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException | IllegalArgumentException |         InvocationTargetException e) &#123;<br>            LOGGER.error(e.getMessage(), e);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> map;<br>&#125; <br></code></pre></td></tr></table></figure>

<h1 id="三、心得"><a href="#三、心得" class="headerlink" title="三、心得"></a>三、心得</h1><p>在开发时，如果经常在一些重复性的，且不必要的地方浪费时间时，那就要想一下方法来避免了，因为这会拉低你的开发效率。</p>
<p>首先自己要思考，怎样才能去很好的解决。如果不能解决，那可以参考已有的解决方案（面向各大搜索引擎编程），学习他们解决问题的思路，看自己能不能活学活用。</p>
<p>然后可以对已有的轮子进行一些自己的优化与封装，使得更加的符合自己的业务场景。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>BeanUtils</tag>
      </tags>
  </entry>
  <entry>
    <title>一篇文章教你快速上手接口管理工具swagger</title>
    <url>/2020/12/04/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%95%99%E4%BD%A0%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7swagger/</url>
    <content><![CDATA[<h1 id="一、关于swagger"><a href="#一、关于swagger" class="headerlink" title="一、关于swagger"></a>一、关于swagger</h1><p>1、什么是swagger?</p>
<p>swagger是spring fox的一套产品，可以作为后端开发者测试接口的工具，也可以作为前端取数据的接口文档。</p>
<p>2、为什么使用？</p>
<p>相比于传统的接口文档书写，开发者可以以更高的效率来进行接口测试与开发。而且使得更具可读性。</p>
<p>3、怎样配置？</p>
<p>引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;2.5.0&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>            &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;<br>            &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;<br>            &lt;version&gt;2.5.0&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<p>配置代码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">import io.swagger.annotations.ApiOperation;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import springfox.documentation.builders.ApiInfoBuilder;<br>import springfox.documentation.builders.RequestHandlerSelectors;<br>import springfox.documentation.service.ApiInfo;<br>import springfox.documentation.service.Contact;<br>import springfox.documentation.spi.DocumentationType;<br>import springfox.documentation.spring.web.plugins.Docket;<br>import springfox.documentation.swagger2.annotations.EnableSwagger2;<br><br>@Configuration  &#x2F;&#x2F; 注册成ioc组件<br>@EnableSwagger2  &#x2F;&#x2F;开启swagger2<br>public class SwaggerConfig &#123;<br><br>   &#x2F;&#x2F; 扫描所有带@ApiOperation注解的类<br>    @Bean<br>    public Docket api() &#123;<br>        return new Docket(DocumentationType.SWAGGER_2)<br>                .apiInfo(apiInfo())<br>                .select()<br>                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class))<br>                .build();<br>    &#125;<br>    <br>    &#x2F;&#x2F;api接口作者相关信息<br>    private ApiInfo apiInfo() &#123;<br>        Contact contact &#x3D; new Contact(&quot;与李&quot;, &quot;&quot;, &quot;1451633962@qq.com&quot;);<br>        ApiInfo apiInfo &#x3D; new ApiInfoBuilder().license(&quot;&quot;).title(&quot;CSDN&quot;).description(&quot;接口文档&quot;).contact(contact).version(&quot;3.0&quot;).build();<br>        return apiInfo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="二、使用教程"><a href="#二、使用教程" class="headerlink" title="二、使用教程"></a>二、使用教程</h1><p>@Api ：对rest接口类的注解</p>
<ul>
<li><p>value 对资源的标签名</p>
</li>
<li><p>description 描述</p>
</li>
</ul>
<p>@ApiOperation ：对方法的注解</p>
<ul>
<li><p>value 对资源的标签名</p>
</li>
<li><p>notes 对方法操作的描述</p>
</li>
</ul>
<p>@ApiImplicitParams ：对多个参数的描述的集合</p>
<p>@ApiImplicitParam：在@ApiImplicitParams里面</p>
<ul>
<li><p>name 属性字段名</p>
</li>
<li><p>value 属性字段含义</p>
</li>
<li><p>required 是否必填（true/false）</p>
</li>
<li><p>paramType 参数位置（”query”为参数放置url,”body”为post方法放在body里…）</p>
</li>
<li><p>dataType 参数类型（”String”、”int”…）</p>
</li>
</ul>
<p>@ApiModel ：对实体类的描述</p>
<p>@ApiModelProperty ：对实体字段的描述</p>
<ul>
<li><p>name 属性名称</p>
</li>
<li><p>value 属性描述</p>
</li>
<li><p>hidden 是否不再swagger页面展示（true/false）</p>
</li>
</ul>
<h1 id="三、踩过的坑"><a href="#三、踩过的坑" class="headerlink" title="三、踩过的坑"></a>三、踩过的坑</h1><p>1、swagger-ui页面卡死</p>
<p><img src="https://img-blog.csdnimg.cn/20191225153214624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>原因：返回的实体或者入参实体中字段重复嵌套，导致swagger页面在展示model时需要大量循环计算，导致cpu占满，浏览器资源耗尽导致页面卡死。</p>
<p>解决方案：</p>
<ul>
<li><p>注意实体中字段的数据的嵌套，隐藏改字段或者修改实体，避免嵌套。</p>
</li>
<li><p>不用swagger,用其他接口测试工具(0_0)</p>
</li>
</ul>
<p>2、POST请求时，Data Type未显示字段注释</p>
<p><img src="https://img-blog.csdnimg.cn/20191225154608545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p> 解决方案：</p>
<p> 给请求实体加上@RequestBody注解</p>
<p><img  src="https://img-blog.csdnimg.cn/20191225154823236.png"  ><span class="image-caption">img</span><img  src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw=="  ><span class="image-caption">点击并拖拽以移动</span></p>
<p><img src="https://img-blog.csdnimg.cn/20191225154734567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
        <tag>接口测试</tag>
      </tags>
  </entry>
  <entry>
    <title>入门alibaba的EasyExcel</title>
    <url>/2020/12/04/%E5%85%A5%E9%97%A8alibaba%E7%9A%84EasyExcel/</url>
    <content><![CDATA[<h1 id="一、关于EasyExcel"><a href="#一、关于EasyExcel" class="headerlink" title="一、关于EasyExcel"></a>一、关于EasyExcel</h1><p>1、什么是EasyExcel，有什么作用？</p>
<p>  EasyExcel是一个基于Java的简单、省内存的读写Excel的开源项目。在尽可能节约内存的情况下支持读写百M的Excel。</p>
<p>2、为什么选择EasyExcel，而不是Apache poi或者jxl?</p>
<p>  Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。</p>
<p>3、怎样使用？</p>
<p>  以下章节能让你快速使用EasyExcel对excel文件进行读写操作。</p>
<h1 id="二、入门EasyExcel"><a href="#二、入门EasyExcel" class="headerlink" title="二、入门EasyExcel"></a>二、入门EasyExcel</h1><p>1、新建一个maven项目、导入easyexcel的jar包。</p>
<p>maven项目的jar包可以在<a href="https://mvnrepository.com/%E9%87%8C%E9%9D%A2%E6%90%9C%E7%B4%A2%EF%BC%8C%E8%83%BD%E5%BF%AB%E9%80%9F%E7%9A%84%E6%90%9C%E7%B4%A2%E5%88%B0%E6%83%B3%E8%A6%81%E7%9A%84jar%E5%8C%85%EF%BC%8C%E4%BB%A5%E5%8F%8A%E7%89%88%E6%9C%AC%E3%80%82">https://mvnrepository.com/里面搜索，能快速的搜索到想要的jar包，以及版本。</a></p>
<p><img src="https://img-blog.csdnimg.cn/20191223135736815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20191223135815753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>我这里选择的是当前最新的2.1.4版本。</p>
<p><img src="https://img-blog.csdnimg.cn/20191223135454348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>2、新建一个实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.entity;<br><br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.ExcelProperty;<br><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.format.DateTimeFormat;<br><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.format.NumberFormat;<br><span class="hljs-keyword">import</span> com.alibaba.excel.annotation.write.style.ColumnWidth;<br><br><span class="hljs-comment">// 表示列宽</span><br><span class="hljs-meta">@ColumnWidth(20)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> </span>&#123;    <br>    <br>    <span class="hljs-comment">// index--表示属性在第几列，value--表示标题</span><br>    <span class="hljs-meta">@ExcelProperty(value = &quot;姓名&quot;, index = 0)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-comment">// @DateTimeFormat--对日期格式的转换</span><br>    <span class="hljs-meta">@DateTimeFormat(&quot;yyyy-MM-dd&quot;)</span><br>    <span class="hljs-meta">@ExcelProperty(value = &quot;生日&quot;, index = 1)</span><br>    <span class="hljs-keyword">private</span> Date birthday;<br><br>    <span class="hljs-meta">@ExcelProperty(value = &quot;电话&quot;, index = 2)</span><br>    <span class="hljs-keyword">private</span> String telphone;<br>    <br>    <span class="hljs-comment">// @NumberFormat--对数字格式的转换</span><br>    <span class="hljs-meta">@NumberFormat(&quot;#.##&quot;)</span><br>    <span class="hljs-meta">@ExcelProperty(value = &quot;工资&quot;, index = 3)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBirthday</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBirthday</span><span class="hljs-params">(Date birthday)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.birthday = birthday;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTelphone</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> telphone;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTelphone</span><span class="hljs-params">(String telphone)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.telphone = telphone;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> salary;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-keyword">double</span> salary)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、提供一个供外部调用写入Excel的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.controller;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.URLEncoder;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-keyword">import</span> com.alibaba.excel.EasyExcel;<br><span class="hljs-keyword">import</span> com.google.common.collect.Lists;<br><span class="hljs-keyword">import</span> com.hgl.entity.UserEntity;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/excel&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelWriteController</span></span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试写入Excel文件</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doDownLoad</span><span class="hljs-params">(HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        response.setContentType(<span class="hljs-string">&quot;application/vnd.ms-excel&quot;</span>);<br>        response.setCharacterEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>        String fileName = URLEncoder.encode(<span class="hljs-string">&quot;第一个文件&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        response.setHeader(<span class="hljs-string">&quot;Content-disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + fileName + <span class="hljs-string">&quot;.xlsx&quot;</span>);<br>        EasyExcel.write(response.getOutputStream(), UserEntity.class).sheet(<span class="hljs-string">&quot;模板&quot;</span>).doWrite(getData());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造假数据，实际上应该从数据库查出来</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> List&lt;UserEntity&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;UserEntity&gt; <span class="hljs-title">getData</span><span class="hljs-params">()</span></span>&#123;<br>        List&lt;UserEntity&gt; users = Lists.newArrayList();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>            UserEntity user = <span class="hljs-keyword">new</span> UserEntity();<br>            user.setBirthday(<span class="hljs-keyword">new</span> Date());<br>            user.setName(<span class="hljs-string">&quot;user_&quot;</span> + i);<br>            user.setSalary(<span class="hljs-number">1.285</span> * i);<br>            user.setTelphone(<span class="hljs-string">&quot;1888888888&quot;</span> + i);<br>            users.add(user);<br>        &#125;<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下载结果：</p>
<p><img src="https://img-blog.csdnimg.cn/20191223163418123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>4、提供一个供外部调用读取Excel的接口 </p>
<p>首先需要写一个监听器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.listener;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> com.alibaba.excel.context.AnalysisContext;<br><span class="hljs-keyword">import</span> com.alibaba.excel.event.AnalysisEventListener;<br><span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<br><span class="hljs-keyword">import</span> com.google.common.collect.Lists;<br><span class="hljs-keyword">import</span> com.hgl.entity.UserEntity;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、注意监听器不能由spring容器管理，每次调用时都需要手动new</span><br><span class="hljs-comment"> * 2、监听器内部需要使用ioc中的bean时，可以通过构造方法传入</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> guilin</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnalysisEventListener</span>&lt;<span class="hljs-title">UserEntity</span>&gt;</span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;UserEntity&gt; data = Lists.newArrayList();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(UserListener.class);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *    解析每条数据时都会调用 </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(UserEntity user, AnalysisContext context)</span> </span>&#123;<br>        data.add(user);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *    所有数据解析完之后调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext context)</span> </span>&#123;<br>        <span class="hljs-comment">// 可以在此处执行业务操作</span><br>        <span class="hljs-comment">// 本例就打印到控制台即可，表示读取完成</span><br>        LOGGER.info(JSON.toJSONString(data));<br>    &#125;<br><br>&#125; <br></code></pre></td></tr></table></figure>

<p>读取方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hgl.controller;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><span class="hljs-keyword">import</span> org.springframework.web.multipart.MultipartFile;<br><br><span class="hljs-keyword">import</span> com.alibaba.excel.EasyExcel;<br><span class="hljs-keyword">import</span> com.hgl.entity.UserEntity;<br><span class="hljs-keyword">import</span> com.hgl.listener.UserListener;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/excel&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelReadController</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试读取Excel文件</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> file</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> String</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@PostMapping(&quot;/read&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">doDownLoad</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>         EasyExcel.read(file.getInputStream(), UserEntity.class, <span class="hljs-keyword">new</span> UserListener()).sheet().doRead();<br>         <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>使用postman测试读数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20191223161627284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>成功读到数据：</p>
<p><img src="https://img-blog.csdnimg.cn/20191223163326474.png"></p>
<h1 id="三、收尾"><a href="#三、收尾" class="headerlink" title="三、收尾"></a>三、收尾</h1><p>这篇文章提供了最简单的使用EasyExcel进行读写操作的例子，更多使用方法请参考官方文档或开源社区。</p>
<p>附上官方文档地址：<a href="https://alibaba-easyexcel.github.io/">https://alibaba-easyexcel.github.io/</a></p>
<p>GitHub开源地址：<a href="https://github.com/alibaba/easyexcel">https://github.com/alibaba/easyexcel</a></p>
]]></content>
      <categories>
        <category>Excel</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Excel</tag>
        <tag>alibaba</tag>
        <tag>EasyExcel</tag>
      </tags>
  </entry>
  <entry>
    <title>关于给Tomcat设置maxPostSize的问题</title>
    <url>/2020/12/03/%E5%85%B3%E4%BA%8E%E7%BB%99Tomcat%E8%AE%BE%E7%BD%AEmaxPostSize%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="一、为什么要设置maxPostSize"><a href="#一、为什么要设置maxPostSize" class="headerlink" title="一、为什么要设置maxPostSize"></a>一、为什么要设置maxPostSize</h1><p>tomcat容器对传输数据的大小有限制，如果上传了超过此值的文件，就会报错，使得程序不能正常使用。</p>
<h1 id="二、设置方法"><a href="#二、设置方法" class="headerlink" title="二、设置方法"></a>二、设置方法</h1><p>找到tomcat目录下的/conf/server.xml，为其添加maxPostSize参数</p>
<p><img src="https://img-blog.csdnimg.cn/20191204091134382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>参数值“-1”表示不做大小限制。不设置maxPostSize参数意为使用默认的大小，默认2097152bytes,即为2megabytes。</p>
<h1 id="三、设值注意事项"><a href="#三、设值注意事项" class="headerlink" title="三、设值注意事项"></a>三、设值注意事项</h1><p>需要注意一点的是，在不同版本的tomcat下不限制传输数据大小的场景时，对maxPostSize的值设置并不是相同的！</p>
<p>具体差别：</p>
<p>tomcat7.0.63之前 给maxPostSize设置小于等于0的值都可表示不限制</p>
<p>tomcat7.0.63及之后 给maxPostSize设置小于0的值可表示不限制</p>
<p>如果在tomcat7.0.63之后设置maxPostSize=“0”，那将会获取不到传输的数据。</p>
<h1 id="四、官方文档"><a href="#四、官方文档" class="headerlink" title="四、官方文档"></a>四、官方文档</h1><p>附上tomcat changeLog</p>
<p><img src="https://img-blog.csdnimg.cn/20191204110920881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>windows下安装使用jenkins实现自动化构建与部署war包</title>
    <url>/2020/11/29/Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8jenkins%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2war%E5%8C%85/</url>
    <content><![CDATA[<h1 id="一、jenkins安装"><a href="#一、jenkins安装" class="headerlink" title="一、jenkins安装"></a>一、jenkins安装</h1><p>jenkins官方下载路径：<a href="https://jenkins.io/zh/">https://jenkins.io/zh/</a></p>
<p>本例版本：jenkins-2.190.3，windows版</p>
<p><img src="https://img-blog.csdnimg.cn/2019120314344868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70">选择长期支持版本下载，版本按需所取。</p>
<p>安装时按照安装向导执行。</p>
<h1 id="二、初次使用"><a href="#二、初次使用" class="headerlink" title="二、初次使用"></a>二、初次使用</h1><p>1、jenkins默认8080端口，若端口冲突，可在根目录下的jenkins.xml修改启动端口</p>
<p><img src="https://img-blog.csdnimg.cn/20191203144022227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>2、修改之后记得在服务管理里重启jenkins服务</p>
<p><img src="https://img-blog.csdnimg.cn/2019120314463581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>3、以admin账户登录，在Manage jenkins里配置管理</p>
<p>配置Configure Global Security</p>
<p><img src="https://img-blog.csdnimg.cn/20191203145401790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>选择以下配置</p>
<p><img src="https://img-blog.csdnimg.cn/20191203145454968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>配置Global Tool Configuration</p>
<p><img src="https://img-blog.csdnimg.cn/20191203145640201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>添加maven、jdk配置，注意不要勾选Install automatically（意为自动安装，本地有环境的话不用勾选，仅配置即可）</p>
<p><img src="https://img-blog.csdnimg.cn/20191203145814928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20191203145851556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>4、添加一个item</p>
<p><img src="https://img-blog.csdnimg.cn/20191203144754589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>输入任务名称，选择Freestyle project </p>
<p><img src="https://img-blog.csdnimg.cn/20191203145043861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>5、输入项目的各项配置</p>
<p><img src="https://img-blog.csdnimg.cn/201912031504003.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/2019120315073645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>还可以在构建的时候选择执行windows命令，选择增加构建步骤。如用maven打成war包后，将war包复制到tomcat的webapps中，并关闭重启tomcat服务，实现自动部署。</p>
<p>具体命令实例如下：（原文链接：<a href="https://blog.csdn.net/u014296316/article/details/90768490%EF%BC%89">https://blog.csdn.net/u014296316/article/details/90768490）</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">@rem 停止在运行的tomact<br>cd  D:\Program Files\apache-tomcat\bin<br>call shutdown.bat<br><br>title my-project<br>ping -n <span class="hljs-number">3</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><br>@rem 清除root文件夹下内容<br>rd/s/q <span class="hljs-string">&quot;D:\Program Files\apache-tomcat\webapps\ROOT&quot;</span><br>md <span class="hljs-string">&quot;D:\Program Files\apache-tomcat\webapps\ROOT&quot;</span><br><br>@rem 将war包移动到root文件夹下<br>move <span class="hljs-string">&quot;D:\sftp\dev\my-project.war&quot;</span>  <span class="hljs-string">&quot;D:\Program Files\apache-tomcat\webapps\ROOT&quot;</span><br><br>@rem 解压war包<br>cd D:\Program Files\apache-tomcat\webapps\ROOT<br>jar -xvf my-project.war<br><br>@rem 删除war包文件<br>del my-project.war<br><br>@rem  启动Tomcat<br>cd  D:\Program Files\apache-tomcat\bin<br>call startup.bat<br></code></pre></td></tr></table></figure>
<p>最后保存。</p>
<p>6、构建项目</p>
<p><img src="https://img-blog.csdnimg.cn/20191203151250587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>查看构建历史，红色为失败、灰色为终止、蓝色为成功。</p>
<p><img src="https://img-blog.csdnimg.cn/20191203151421937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>查看控制台输出</p>
<p><img src="https://img-blog.csdnimg.cn/20191203151528413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20191203151606102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="三、遇到的坑"><a href="#三、遇到的坑" class="headerlink" title="三、遇到的坑"></a>三、遇到的坑</h1><p>1、忘记密码？</p>
<p>解决方法：找到根目录下的conf.xml,注释或删除这一段代码，再重启服务</p>
<p><img src="https://img-blog.csdnimg.cn/20191203151839884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>2、依赖环境中的maven的项目，在maven环境修改后，项目maven配置不能切换</p>
<p>解决方法：删除项目，重新选择项目的maven环境，重启服务。</p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>自动化</tag>
        <tag>流水线</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat+Nginx+Redis实现session共享</title>
    <url>/2020/11/29/Tomcat-Nginx-Redis%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>中间件：Tomcat、Redis、Nginx</p>
<p>jar包：commons-pool2-2.4.2.jar、jedis-2.8.0.jar、tomcat-redis-session-manager-2.0.0.jar</p>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>多台Tomacat需要配置不同的端口号</p>
<p><font color=red>/lib </font></p>
<p>将jar包存放到此位置</p>
<p><font color=red>/conf/server.xml</font></p>
<img src="https://img-blog.csdnimg.cn/20191128144308378.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<img src="https://img-blog.csdnimg.cn/20191128144359433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" alt="" style="zoom:67%;" />

<p><font color=red>/conf/context.xml</font></p>
<img src="https://img-blog.csdnimg.cn/20191128144802479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>host为Redis的ip地址，port为端口，database为数据库。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>/conf/nginx.conf</p>
<img src="https://img-blog.csdnimg.cn/20191128145135781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" />

<p>upstream意为配置服务器列表，本例中开启了两台tomcat，端口分别为8080与9999。</p>
<p>proxy_pass意为配置代理服务器。</p>
<p>此配置意为监听本地（192.168.0.113）的80端口，并将请求以轮询方式转发给8080和9999的tomcat服务器。</p>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis不需要特殊配置，启动即可。</p>
<h1 id="三、测试"><a href="#三、测试" class="headerlink" title="三、测试"></a>三、测试</h1><p>先后启动Redis服务、两台tomcat服务器、Nginx服务器。</p>
<p>在Tomcat启动页面加上标识，判断两台服务器中sessionId是否一致。</p>
<p>/webapps/ROOT/index.jsp:</p>
<p><img src="https://img-blog.csdnimg.cn/20191128145904190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/20191128162322240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<h1 id="四、结果"><a href="#四、结果" class="headerlink" title="四、结果"></a>四、结果</h1><p><img src="https://img-blog.csdnimg.cn/20191128145904190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/20191128162322240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p><img src="https://img-blog.csdnimg.cn/20191128162353184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/20191128162739595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>如果F5刷新页面不能切换端口对应的页面，可能是由于浏览器缓存造成。</p>
<p>解决方法：清除缓存刷新，alt+F5</p>
<p>此时可看到多个tomcat服务在不断轮询，且sessionId一致。</p>
<p>再用Redis桌面管理工具查看信息：</p>
<p><img src="https://img-blog.csdnimg.cn/20191128162353184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70" style="zoom:67%;" /><img src="https://img-blog.csdnimg.cn/20191128162739595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MTcxODE3,size_16,color_FFFFFF,t_70"></p>
<p>可以看到session信息已经交给Redis管理。</p>
<h1 id="五、弊端"><a href="#五、弊端" class="headerlink" title="五、弊端"></a>五、弊端</h1><p>此种方式依赖于tomcat容器，如果中间件换成jetty或者其他，就不受用。</p>
<p>还有一种较好实现方式：Spring Session + Redis</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Tomcat</tag>
        <tag>Nginx</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>MarkDown本地编辑神组合</title>
    <url>/2020/11/29/MarkDown%E6%9C%AC%E5%9C%B0%E7%BC%96%E8%BE%91%E7%A5%9E%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<h1 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h1><p>Typora官方版是一款界面简约且专业可靠的跨平台Markdown编辑器,，支持markdown的标准语法，支持动态预览、一键预览。同时，Typora还支持代码块的语法高亮，对于表格、数学公式这些 MD 里比较难以输入的元素，该软件也提供了相当高效的辅助。</p>
<p>Typora官网：<a href="https://typora.io/">https://typora.io/</a></p>
<p>下载链接：<a href="https://typora.io/windows/typora-setup-x64.exe">https://typora.io/windows/typora-setup-x64.exe</a></p>
<h1 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h1><p>所谓图床工具，就是自动把本地图片转换成链接的一款工具，网络上有很多图床工具，就目前使用种类而言，PicGo 算得上一款比较优秀的图床工具。它是一款用 <code>Electron-vue</code> 开发的软件，可以支持微博，七牛云，腾讯云COS，又拍云，GitHub，阿里云OSS，SM.MS，imgur 等8种常用图床，功能强大，简单易用。</p>
<p>GitHub地址：<a href="https://github.com/Molunerfinn/PicGo">https://github.com/Molunerfinn/PicGo</a></p>
<p>下载链接：<a href="https://github.com/Molunerfinn/PicGo/releases/download/v2.2.2/PicGo-Setup-2.2.2.exe">https://github.com/Molunerfinn/PicGo/releases/download/v2.2.2/PicGo-Setup-2.2.2.exe</a> （截至博客发布日期最新稳定版本）</p>
<h1 id="GitHub图床"><a href="#GitHub图床" class="headerlink" title="GitHub图床"></a>GitHub图床</h1><p>图床，我的理解就是图片存放到公网上的空间。用GitHub做图床最大的好处就是免费，当然也有其他免费的图床可以使用，这里我们以GitHub图床为例。</p>
<h1 id="配置整合"><a href="#配置整合" class="headerlink" title="配置整合"></a>配置整合</h1><p>1、需要一个GitHub账号，没有的需要自行创建</p>
<p>2、创建一个repository，名称可以随便取</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129110457138.png" alt="" style="zoom:67%;" />

<p>3、运行PicGo，找到GitHub图床设置</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129110621534.png" alt="" style="zoom:67%;" />

<p>其中，</p>
<p>仓库名：username/repositoryname，即为你在GitHub上的用户名再加上你建立的仓库名。</p>
<p>分支名：我这里创建仓库时，默认分支不再是master，而是main，所以分支名为main。</p>
<p>Token：需要在GitHub个人设置中添加，方法如下：</p>
<p>​               打开个人设置，找到developer settings</p>
<img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129111105348.png" alt="" style="zoom:67%;" />

<p>​                点击Personal access tokens并点击Generate new token</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129111231617.png"></p>
<p>​            勾选下列选项后创建Token</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129111348262.png"></p>
<p>​            复制该Token，粘贴到PicGo</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129111527858.png"></p>
<p>指定存储路径：仓库中存放文件的文件夹名称，可以随便取，这里取名为img。</p>
<p>自定义域名：上传图片后，生成这张图片的公网链接，建议使用github的cdn域名。如<a href="">https://cdn.jsdelivr.net/gh/</a>${username}/${repositoryname}@{version}，’${}’我这里是为了区分变量，其中username和repositoryname含义同上，version为分支名。参照这种格式，我这里自定义域名应为<a href="">https://cdn.jsdelivr.net/gh/hanguilin/images@main</a>。</p>
<p>4、设置Typora图像偏好为PicGo</p>
<p>打开Typora-&gt;文件-&gt;偏好设置-&gt;图像，设置为</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129112410802.png"></p>
<p>接着验证图片上传选项，此时Typora会上传自己的两张图标到GitHub图床</p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129112833004.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129113153446.png"></p>
<h1 id="上手使用"><a href="#上手使用" class="headerlink" title="上手使用"></a>上手使用</h1><img src="https://cdn.jsdelivr.net/gh/hanguilin/images@main/img/image-20201129113553309.png" style="zoom:67%;" />

<p>现在就可以开始你的创作啦！</p>
]]></content>
      <categories>
        <category>MarkDown</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>PicGo</tag>
        <tag>GitHub图床</tag>
      </tags>
  </entry>
</search>
